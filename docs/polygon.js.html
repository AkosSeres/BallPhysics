<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>polygon.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Ball.html">Ball</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Ball.html#.collide">collide</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Ball.html#.fromObject">fromObject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Ball.html#applyDeltaVelInPoint">applyDeltaVelInPoint</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Ball.html#collided">collided</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Ball.html#containsPoint">containsPoint</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Ball.html#effectiveMass">effectiveMass</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Ball.html#getAmInPoint">getAmInPoint</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Ball.html#move">move</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Ball.html#rotate">rotate</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Ball.html#toJSObject">toJSObject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Ball.html#velInPlace">velInPlace</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Body.html">Body</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Body.html#.collide">collide</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Body.html#.fromObject">fromObject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Body.html#applyDeltaVelInPoint">applyDeltaVelInPoint</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Body.html#calculatePosAndMass">calculatePosAndMass</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Body.html#collideWithBall">collideWithBall</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Body.html#collideWithFixedBall">collideWithFixedBall</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Body.html#collideWithWall">collideWithWall</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Body.html#containsPoint">containsPoint</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Body.html#effectiveMass">effectiveMass</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Body.html#getAmInPoint">getAmInPoint</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Body.html#move">move</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Body.html#rotate">rotate</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Body.html#toJSObject">toJSObject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Body.html#velInPlace">velInPlace</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Line.html">Line</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Line.html#.intersect">intersect</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Line.html#.intersectWithLineSegment">intersectWithLineSegment</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Line.html#distFromPoint">distFromPoint</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="LineSegment.html">LineSegment</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="LineSegment.html#.intersect">intersect</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="LineSegment.html#distFromPoint">distFromPoint</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Physics.html">Physics</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#.fromJSON">fromJSON</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#.fromObject">fromObject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#addBall">addBall</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#addBody">addBody</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#addFixedBall">addFixedBall</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#addRectBody">addRectBody</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#addRectWall">addRectWall</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#addSoftBall">addSoftBall</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#addSoftSquare">addSoftSquare</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#addSpring">addSpring</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#addWall">addWall</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#getCopyOfBalls">getCopyOfBalls</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#getCopyOfBodies">getCopyOfBodies</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#getItemDataFromId">getItemDataFromId</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#getObjectAtCoordinates">getObjectAtCoordinates</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#removeObjFromSystem">removeObjFromSystem</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#setAirFriction">setAirFriction</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#setBounds">setBounds</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#setGravity">setGravity</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#toJSObject">toJSObject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#toJSON">toJSON</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Physics.html#update">update</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Polygon.html">Polygon</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Polygon.html#.createCircle">createCircle</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Polygon.html#.fracture">fracture</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Polygon.html#.intersection">intersection</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Polygon.html#getSideLine">getSideLine</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Polygon.html#getSideSegment">getSideSegment</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Polygon.html#getSideVector">getSideVector</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Polygon.html#isPointInside">isPointInside</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Polygon.html#makeAntiClockwise">makeAntiClockwise</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Polygon.html#reverseOrder">reverseOrder</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="SoftBall.html">SoftBall</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="SoftBall.html#.fromObject">fromObject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="SoftBall.html#.updatePressureBasedForces">updatePressureBasedForces</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="SoftBall.html#containsPoint">containsPoint</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="SoftBall.html#toJSObject">toJSObject</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Spring.html">Spring</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Spring.html#.createStickOrSpring">createStickOrSpring</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Spring.html#.fromObject">fromObject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Spring.html#attachObject">attachObject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Spring.html#lockRotation">lockRotation</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Spring.html#pinHere">pinHere</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Spring.html#toJSObject">toJSObject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Spring.html#unlockRotation">unlockRotation</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Spring.html#unpin">unpin</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Spring.html#update">update</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Stick.html">Stick</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Stick.html#update">update</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Vec2.html">Vec2</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#add">add</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#dist">dist</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#div">div</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#lerp">lerp</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#mult">mult</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#rotate">rotate</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#setMag">setMag</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#sub">sub</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#toJSObject">toJSObject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#.add">add</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#.angle">angle</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#.angleACW">angleACW</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#.cross">cross</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#.crossScalarFirst">crossScalarFirst</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#.crossScalarSecond">crossScalarSecond</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#.dist">dist</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#.div">div</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#.dot">dot</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#.fromAngle">fromAngle</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#.fromObject">fromObject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#.lerp">lerp</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#.mult">mult</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#.normalized">normalized</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Vec2.html#.sub">sub</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Wall.html">Wall</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Wall.html#.fromObject">fromObject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Wall.html#calculateCenterAndRadius">calculateCenterAndRadius</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Wall.html#collideWithBall">collideWithBall</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Wall.html#containsPoint">containsPoint</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Wall.html#toJSObject">toJSObject</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#arrayBuffertoBase64">arrayBuffertoBase64</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#base64ToArrayBuffer">base64ToArrayBuffer</a></span></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#codeTable">codeTable</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">polygon.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Vec2 = require('./vec2');
const LineSegment = require('./linesegment');
const Line = require('./line');

/**
 * Class representing a mathematical polygon
 */
class Polygon {
    /**
     * Creates the polygon
     * @param {Vec2[]} points_ Array of the points for the polygon in order
     */
    constructor(points_) {
        if (points_.length &lt; 3) {
            throw new Error(
                'Not enough points in polygon (minimum required: 3)'
            );
        }
        this.points = points_;
        this.makeAntiClockwise();
    }

    /**
     * Returns the vector of the side with the given number
     * The vector has the orientation of the order of the points
     * @param {number} num The number of the side
     * @return {Vec2} The side vector
     */
    getSideVector(num) {
        if (num &lt; 0) num += Math.abs(Math.floor(num)) * this.points.length;
        return Vec2.sub(this.points[(num + 1) % this.points.length],
            this.points[num % this.points.length]);
    }

    /**
     * Returns the side with the given number as a LineSegment
     * @param {number} num The number of the side
     * @return {LineSegment} The side line segment
     */
    getSideSegment(num) {
        if (num &lt; 0) num += Math.abs(Math.floor(num)) * this.points.length;
        return new LineSegment(this.points[(num + 1) % this.points.length],
            this.points[num % this.points.length]);
    }

    /**
     * Returns the side with the given number as a Line
     * @param {number} num The number of the side
     * @return {Line} The side line
     */
    getSideLine(num) {
        if (num &lt; 0) num += Math.abs(Math.floor(num)) * this.points.length;
        return new Line(this.points[(num + 1) % this.points.length],
            this.points[num % this.points.length]);
    }

    /**
     * @return {number} The number of sides of the polygon
     */
    get sides() {
        return this.points.length;
    }

    /**
     * Turns the order of the points to anticlockwise,
     * which is the standard in mathematics
     */
    makeAntiClockwise() {
        let angleSum = 0;

        for (let i = 1; i &lt;= this.sides; i++) {
            let vec1 = this.getSideVector(i);
            let vec2 = this.getSideVector(i - 1);
            vec2.mult(-1);
            angleSum += Vec2.angleACW(vec1, vec2);
        }

        if (this.sides === 3) {
            if (angleSum > Math.PI * 1.5) this.reverseOrder();
        } else if (this.sides === 4) {
            if (Vec2.angleACW(this.getSideVector(1),
                this.getSideVector(0)) >= Math.PI) {
                this.reverseOrder();
            }
        } else if (this.sides > 4) {
            let realAngle = angleSum - this.sides * Math.PI;
            if (realAngle > 0) {
                this.reverseOrder();
            }
        }
    }

    /**
     * Reverses the order of points in the polygon
     */
    reverseOrder() {
        this.points = this.points.reverse();
    }

    /**
     * Determines if a given point is inside the polygon or not
     * @param {Vec2} point The point to investigate
     * @return {boolean} If the point is inside or not
     */
    isPointInside(point) {
        if (Vec2.dist(point, this.centerPoint) > this.boundRadius) return false;

        // Find a point that is outside of the shape for sure
        let outsidePoint = this.centerPoint.copy;
        outsidePoint.add(Vec2.mult(new Vec2(1.1, 0.6), this.boundRadius));

        // Create a LineSegment between the points
        let segment = new LineSegment(point, outsidePoint);

        // Count the intersections
        let intersectionCount = 0;
        [...Array(this.sides).keys()].
            map((number) => this.getSideSegment(number)).forEach((side) => {
                if (LineSegment.intersect(side, segment)) intersectionCount++;
            });

        if (intersectionCount % 2 == 0) return false;
        else if (intersectionCount % 2 == 1) return true;
    }

    /**
     * Returns the mathematical average of the point of the polygon
     * @return {Vec2} The center point
     */
    get centerPoint() {
        let center = new Vec2(0, 0);
        this.points.forEach((p) => {
            center.add(p);
        });
        center.div(this.sides);
        return center;
    }

    /**
     * Returns the radius of the smallest possible
     * circle containing the whole polygon centered
     * around the polygon's centerPoint
     * The circle's center is the centerPoint of the polygon
     * @return {number} The radius
     */
    get boundRadius() {
        let center = this.centerPoint;
        return Math.max(...this.points.map((p) => Vec2.dist(p, center)));
    }

    /**
     * @return {LineSegment[]} Array containing the sides of the polygon
     */
    get allSides() {
        return [...Array(this.sides).keys()].
            map((number) => this.getSideSegment(number));
    }

    /**
     * Determines the intersecting area of two polygons
     * Returns undefined if there is none
     * @param {Polygon} poly1 The first polygon
     * @param {Polygon} poly2 The second polygon
     * @return {Polygon} The intersection area
     */
    static intersection(poly1, poly2) {
        if (Vec2.dist(poly1.centerPoint, poly2.centerPoint) >
            poly1.boundRadius + poly2.boundRadius) return undefined;

        // Determine intersection points
        let sideIntersections = [];
        let sides1 = poly1.allSides;
        let sides2 = poly2.allSides;
        sides1.forEach((side1, idx1) => {
            sides2.forEach((side2, idx2) => {
                let intersectionOfSides = LineSegment.intersect(side1, side2);
                if (intersectionOfSides) {
                    intersectionOfSides['isIntersectionPoint'] = true;
                    sideIntersections.push({
                        intersectionPoint: intersectionOfSides,
                        sideNumber1: idx1,
                        sideNumber2: idx2,
                    });
                };
            });
        });

        if (sideIntersections.length === 0) {
            if (poly1.isPointInside(poly2.points[0])) {
                return new Polygon(poly2.points.map((p) => p.copy));
            }
            if (poly2.isPointInside(poly1.points[0])) {
                return new Polygon(poly1.points.map((p) => p.copy));
            }
        }

        // Put the intersection points into the copy of polygons
        let new1 = new Polygon(poly1.points.map((p) => p.copy));
        for (let i = new1.points.length - 1; i >= 0; i--) {
            let intersectionsOnThis =
                sideIntersections.filter((it) => it.sideNumber1 == i);
            if (intersectionsOnThis.length > 1) {
                intersectionsOnThis.sort((a, b) => {
                    return Vec2.dist(new1.points[i], a.intersectionPoint)
                        - Vec2.dist(new1.points[i], b.intersectionPoint);
                });
            }
            if (intersectionsOnThis.length > 0) {
                new1.points.splice(i + 1, 0,
                    ...intersectionsOnThis.map((it) => it.intersectionPoint));
            }
        }
        let new2 = new Polygon(poly2.points.map((p) => p.copy));
        for (let i = new2.points.length - 1; i >= 0; i--) {
            let intersectionsOnThis =
                sideIntersections.filter((it) => it.sideNumber2 == i);
            if (intersectionsOnThis.length > 1) {
                intersectionsOnThis.sort((a, b) => {
                    return Vec2.dist(new2.points[i], a.intersectionPoint)
                        - Vec2.dist(new2.points[i], b.intersectionPoint);
                });
            }
            if (intersectionsOnThis.length > 0) {
                new2.points.splice(i + 1, 0,
                    ...intersectionsOnThis.map((it) => it.intersectionPoint));
            }
        }

        // Find a starting point outside of the other poly
        let currInv = {
            polyNum: 1,
            pointNum: 0,
        };
        for (let i = 0; i &lt; new1.points.length; i++) {
            if (new1.points[i].isIntersectionPoint) {
                currInv.pointNum = i;
                break;
            } else if (new2.isPointInside(new1.points[i])) {
                currInv.pointNum = i;
                break;
            }
        }
        let isDone = false;
        let finalPoints = [];
        while (!isDone) {
            let currentPoly = (currInv.polyNum === 1) ? new1 : new2;
            let otherPoly = (currInv.polyNum === 1) ? new2 : new1;
            finalPoints.push(
                currentPoly.points[
                    currInv.pointNum % currentPoly.points.length].copy
            );
            if (finalPoints.length > 2 &amp;&amp;
                finalPoints[0].x == finalPoints[finalPoints.length - 1].x &amp;&amp;
                finalPoints[0].y == finalPoints[finalPoints.length - 1].y) {
                finalPoints.pop();
                break;
            }
            if (finalPoints.length > new1.points.length + new2.points.length) {
                break;
            }

            if (currentPoly.points[currInv.pointNum %
                currentPoly.points.length].isIntersectionPoint) {
                if (currentPoly.points[(currInv.pointNum + 1) %
                    currentPoly.points.length].isIntersectionPoint) {
                    currInv.pointNum++;
                } else if (otherPoly.isPointInside(
                    currentPoly.points[(currInv.pointNum + 1) %
                    currentPoly.points.length]) &amp;&amp;
                    !currentPoly.points[(currInv.pointNum + 1) %
                        currentPoly.points.length].isIntersectionPoint) {
                    currInv.pointNum++;
                } else {
                    currInv.pointNum = otherPoly.points.indexOf(
                        currentPoly.points[currInv.pointNum %
                        currentPoly.points.length]) + 1;
                    currInv.polyNum = (currInv.polyNum === 1) ? 2 : 1;
                }
            } else {
                currInv.pointNum++;
            }
        }

        return new Polygon(finalPoints);
    }

    /**
     * Creates a regular polygon (circle) with
     * the given center point and radius
     * @param {number} radius The radius of the circle
     * @param {Vec2} center The center of the circle
     * @param {number} resolution The resolution of the circle
     * @return {Polygon} The created Polygon
     */
    static createCircle(radius, center, resolution = 25) {
        let pts = [...Array(resolution).keys()].map((number) => {
            let p = Vec2.fromAngle(2 * Math.PI * number / resolution);
            p.setMag(radius);
            p.add(center);
            return p;
        });
        return new Polygon(pts);
    }

    /**
     * Creates a fracture diagram based on the given points
     * Looks like a Voronoi diagram
     * @param {Vec2[]} middlePoints Points of fractures
     * @param {number} maxLength Max length of sides on the peripherals
     * @return {Polygon[]} The fractured shapes
     */
    static fracture(middlePoints, maxLength = 500) {
        let shapes = middlePoints.map((p, i) => {
            let lines = [];
            for (let j = 0; j &lt; middlePoints.length; j++) {
                if (i === j) continue;
                let otherPoint = middlePoints[j];
                let avg = Vec2.div(Vec2.add(p, otherPoint), 2);
                let e = Vec2.sub(p, otherPoint);
                e.rotate(Math.PI / 2);

                lines.push(new Line(avg, Vec2.add(e, avg)));
            }

            lines = lines.filter((line, idx) => {
                let connectingSegment = new LineSegment(line.a, p);
                for (let j = 0; j &lt; lines.length; j++) {
                    if (idx === j) continue;
                    let sectP = Line.intersectWithLineSegment(lines[j], connectingSegment);
                    if (sectP) return false;
                }
                return true;
            });

            lines = lines.sort((a, b) => {
                return Vec2.sub(a.a, a.b).heading - Vec2.sub(b.a, b.b).heading;
            });

            let shape = lines.map((line, index) => {
                let intersectPoints = [];
                for (let j = 0; j &lt; lines.length; j++) {
                    if (index === j) continue;
                    let newIntersection = Line.intersect(line, lines[j]);
                    if (newIntersection) intersectPoints.push(newIntersection);
                }
                let e = Vec2.sub(line.a, line.b);
                intersectPoints = intersectPoints.filter((ip) => {
                    let v = Vec2.sub(ip, p);
                    e.setMag(1);
                    let dist = Vec2.dot(v, e);
                    return dist > 0;
                });
                if (intersectPoints.length === 0) {
                    intersectPoints.push(Vec2.add(Vec2.mult(e, maxLength * 1.2), line.a));
                }
                intersectPoints = intersectPoints.sort((a, b) => {
                    return Vec2.dist(a, p) - Vec2.dist(b, p);
                });
                return intersectPoints[0];
            });

            return shape;
        });

        return shapes.filter((shape) => shape.length >= 3).map((shape) => new Polygon(shape));
    }
}

module.exports = Polygon;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a> on Tue Dec 29 2020 19:12:47 GMT+0000 (Coordinated Universal Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
