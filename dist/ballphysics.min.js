"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function (f) {
    if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") {
        module.exports = f();
    } else if (typeof define === "function" && define.amd) {
        define([], f);
    } else {
        var g;if (typeof window !== "undefined") {
            g = window;
        } else if (typeof global !== "undefined") {
            g = global;
        } else if (typeof self !== "undefined") {
            g = self;
        } else {
            g = this;
        }g.BallPhysics = f();
    }
})(function () {
    var define, module, exports;return function () {
        function r(e, n, t) {
            function o(i, f) {
                if (!n[i]) {
                    if (!e[i]) {
                        var c = "function" == typeof require && require;if (!f && c) return c(i, !0);if (u) return u(i, !0);var a = new Error("Cannot find module '" + i + "'");throw a.code = "MODULE_NOT_FOUND", a;
                    }var p = n[i] = { exports: {} };e[i][0].call(p.exports, function (r) {
                        var n = e[i][1][r];return o(n || r);
                    }, p, p.exports, r, e, n, t);
                }return n[i].exports;
            }for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
                o(t[i]);
            }return o;
        }return r;
    }()({ 1: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var vec2_1 = require("./vec2");
            /**
             * A class representing a ball
             * A ball is an object in the physics engine that
             * has a shape of a circle and it is affected by gravity
             */

            var Ball = function () {
                /**
                 * Crete a ball
                 * The mass of the ball is calculated from its radius
                 * @param {Vec2} pos The position of the center of the circle
                 * @param {Vec2} vel The velocity of the circle
                 * @param {number} r The radius of the circe
                 * @param {number} k Coefficient of restitution
                 * @param {number} ang The angular velocity of the ball (optional)
                 * @param {number} fc The friction coefficient (optional, defaults to 0.4)
                 */
                function Ball(pos, vel, r, k, ang, fc) {
                    _classCallCheck(this, Ball);

                    this.pos = pos.copy;
                    this.lastPos = this.pos.copy;
                    this.r = r;
                    this.fc = 0.4;
                    this.amc = 2 / 5;
                    this.rotation = 0;
                    if (ang) this.ang = ang;else this.ang = 0;
                    if (fc || fc === 0) this.fc = fc;
                    if (k) this.k = k;else this.k = 0.8;
                    if (vel != undefined) this.vel = vel.copy;else this.vel = new vec2_1.default(0, 0);
                }
                /**
                 * Get the mass of the ball
                 * @return {number} The mass
                 */


                _createClass(Ball, [{
                    key: "move",

                    /**
                     * Moves the ball by the given coordinates
                     * @param {number} x x coordinate
                     * @param {number} y y coordinate
                     */
                    value: function move(x, y) {
                        this.pos.x += x;
                        this.pos.y += y;
                    }
                    /**
                     * Checks if two balls are colliding or not
                     * @param {Ball} ball the other ball
                     * @return {boolean} True if they colidre
                     */

                }, {
                    key: "collided",
                    value: function collided(ball) {
                        if (this.pos.dist(ball.pos) < this.r + ball.r) return true;else return false;
                    }
                    /**
                     * Static function for collision between two balls
                     * @param {Ball} ball1 First ball
                     * @param {Ball} ball2 Second ball
                     */

                }, {
                    key: "m",
                    get: function get() {
                        return this.r * this.r * Math.PI;
                    }
                    /**
                     * Get the moment of inertia of the ball
                     * @return {number} The moment of inertia
                     */

                }, {
                    key: "am",
                    get: function get() {
                        return this.amc * this.r * this.r * this.m;
                    }
                    /**
                     * Get a copy of the ball that is not a reference to it
                     * @return {Ball} The copy of the ball
                     */

                }, {
                    key: "copy",
                    get: function get() {
                        var ret = new Ball(this.pos.copy, this.vel.copy, this.r, this.k, this.ang, this.fc);
                        ret.lastPos = this.lastPos.copy;
                        ret.rotation = this.rotation;
                        return ret;
                    }
                }], [{
                    key: "collide",
                    value: function collide(ball1, ball2) {
                        if (!ball1.collided(ball2)) return;
                        var pos1 = ball1.pos;
                        var pos2 = ball2.pos;
                        var r1 = ball1.r;
                        var r2 = ball2.r;
                        var k = (ball1.k + ball2.k) / 2;
                        var m1 = ball1.m;
                        var m2 = ball2.m;
                        var dist = vec2_1.default.dist(pos1, pos2);
                        var fc = (ball1.fc + ball2.fc) / 2;
                        var cp1 = pos1.copy;
                        var cp2 = pos2.copy;
                        var too = r1 + r2 - dist;
                        var d = vec2_1.default.sub(pos1, pos2);
                        d.setMag(1);
                        d.mult(too * m2 / (m1 + m2));
                        cp1.add(d);
                        d.setMag(1);
                        d.mult(-too * m1 / (m1 + m2));
                        cp2.add(d);
                        ball1.pos = cp1;
                        ball2.pos = cp2;
                        if (vec2_1.default.dot(d, vec2_1.default.sub(ball1.vel, ball2.vel)) < 0) return;
                        d.setMag(1);
                        var vel1Parralel = vec2_1.default.cross(d, ball1.vel);
                        var vel2Parralel = vec2_1.default.cross(d, ball2.vel);
                        var vel1Perpendicular = vec2_1.default.dot(d, ball1.vel);
                        var vel2Perpendicular = vec2_1.default.dot(d, ball2.vel);
                        var vk1 = r1 * ball1.ang;
                        var vk2 = r2 * ball2.ang;
                        var vel1InPos = vel1Parralel - vk1;
                        var vel2InPos = vel2Parralel + vk2;
                        var vCommon = (vel1InPos * ball1.am + vel2InPos * ball2.am) / (ball1.am + ball2.am);
                        var tovCommon1 = vCommon - vel1InPos;
                        var tovCommon2 = vCommon - vel2InPos;
                        var maxDeltaAng1 = tovCommon1 / r1;
                        var maxDeltaAng2 = tovCommon2 / r2;
                        // Calculate the new perpendicular velocities
                        var u1Perpendicular = (1 + k) * ((m1 * vel1Perpendicular + m2 * vel2Perpendicular) / (m1 + m2)) - k * vel1Perpendicular;
                        var u2Perpendicular = (1 + k) * ((m1 * vel1Perpendicular + m2 * vel2Perpendicular) / (m1 + m2)) - k * vel2Perpendicular;
                        ball1.vel = vec2_1.default.mult(d, u1Perpendicular);
                        ball2.vel = vec2_1.default.mult(d, u2Perpendicular);
                        var deltav1Perpendicular = u1Perpendicular - vel1Perpendicular;
                        var deltav2Perpendicular = u2Perpendicular - vel2Perpendicular;
                        var deltaAng1 = -Math.sign(tovCommon1) * (deltav1Perpendicular * fc) / (ball1.amc * r1);
                        var deltaAng2 = Math.sign(tovCommon2) * (deltav2Perpendicular * fc) / (ball2.amc * r2);
                        if (deltaAng1 / maxDeltaAng1 > 1) deltaAng1 = maxDeltaAng1;
                        if (deltaAng2 / maxDeltaAng2 > 1) deltaAng2 = maxDeltaAng2;
                        deltaAng1 *= ball1.amc / (ball1.amc + 1);
                        deltaAng2 *= ball2.amc / (ball2.amc + 1);
                        ball1.ang -= deltaAng1;
                        ball2.ang += deltaAng2;
                        var u1Parralel = vel1Parralel + deltaAng1 * r1;
                        var u2Parralel = vel2Parralel + deltaAng2 * r2;
                        d.rotate(Math.PI / 2);
                        ball1.vel.add(vec2_1.default.mult(d, u1Parralel));
                        ball2.vel.add(vec2_1.default.mult(d, u2Parralel));
                    }
                }]);

                return Ball;
            }();

            exports.default = Ball;
        }, { "./vec2": 8 }], 2: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var vec2_1 = require("./vec2");
            var linesegment_1 = require("./linesegment");
            /**
             * Class representing a body
             * Bodies are movable objects
             * and they collide with other objects (balls)
             */

            var Body = function () {
                /**
                 * Creates a body and calculates it's centre of mass (position)
                 * @param {Array} points The points that make up the body
                 * @param {Vec2} vel The velocity of the body
                 * @param {number} k Coefficient of restitution
                 * @param {number} ang Angular velocity
                 * @param {number} fc Friction coefficient
                 */
                function Body(points, vel, k, ang, fc) {
                    _classCallCheck(this, Body);

                    this.points = points;
                    var pol = this.points;
                    var sum1 = 0;
                    var sum2 = 0;
                    var angle = vec2_1.default.angleACW(vec2_1.default.sub(pol[1], pol[0]), vec2_1.default.sub(pol[pol.length - 1], pol[0]));
                    sum1 += angle;
                    sum2 += Math.PI * 2 - angle;
                    for (var i = 1; i < pol.length - 1; i++) {
                        angle = vec2_1.default.angleACW(vec2_1.default.sub(pol[(i + 1) % pol.length], pol[i]), vec2_1.default.sub(pol[i - 1], pol[i]));
                        sum1 += angle;
                        sum2 += Math.PI * 2 - angle;
                    }
                    angle = vec2_1.default.angleACW(vec2_1.default.sub(pol[0], pol[pol.length - 1]), vec2_1.default.sub(pol[pol.length - 2], pol[pol.length - 1]));
                    sum1 += angle;
                    sum2 += Math.PI * 2 - angle;
                    if (sum2 < sum1) {
                        var temp = [];
                        for (var _i = pol.length - 1; _i >= 0; _i--) {
                            temp.push(pol[_i]);
                        }this.points = temp;
                    }
                    this.calculatePosAndMass();
                    this.lastPos = this.pos.copy;
                    this.fc = 0.4;
                    this.rotation = 0;
                    if (ang) this.ang = ang;else this.ang = 0;
                    if (fc || fc === 0) this.fc = fc;
                    if (k) this.k = k;else this.k = 0.8;
                    if (vel != undefined) this.vel = vel.copy;else this.vel = new vec2_1.default(0, 0);
                }
                /**
                 * Get a copy of the body that is not a reference to it
                 * @return {Body} The copy of the body
                 */


                _createClass(Body, [{
                    key: "move",

                    /**
                     * Moves the body by the given coordinates
                     * It has to move all the points of the body and
                     * also the centre of mass (pos) of the body
                     * @param {number} x x coordinate
                     * @param {number} y y coordinate
                     */
                    value: function move(x, y) {
                        this.pos.x += x;
                        this.pos.y += y;
                        this.points.forEach(function (p) {
                            p.x += x;
                            p.y += y;
                        });
                    }
                    /**
                     * Function that does the collision detection and
                     * collision behavior between the body and ball
                     * @param {Ball} ball The ball to collide with the body
                     */

                }, {
                    key: "collideWithBall",
                    value: function collideWithBall(ball) {
                        var _this = this;

                        var heading = void 0;
                        var rel = void 0;
                        var cp = void 0;
                        this.points.forEach(function (point, idx) {
                            var p = new vec2_1.default(point.x, point.y);
                            p.x -= ball.pos.x;
                            p.y -= ball.pos.y;
                            if (p.length <= ball.r) {
                                heading = p.heading + Math.PI;
                                rel = p.length;
                                var move = vec2_1.default.fromAngle(heading);
                                move.mult(ball.r - rel);
                                _this.move(move.x * -1 * ball.m / (_this.m + ball.m), move.y * -1 * ball.m / (_this.m + ball.m));
                                ball.move(move.x * 1 * _this.m / (_this.m + ball.m), move.y * 1 * _this.m / (_this.m + ball.m));
                                cp = new vec2_1.default(point.x, point.y);
                                var a = vec2_1.default.fromAngle(heading);
                                a.mult(-30);
                            }
                            p = new vec2_1.default(point.x, point.y);
                            var np = new vec2_1.default(_this.points[(idx + 1) % _this.points.length].x, _this.points[(idx + 1) % _this.points.length].y);
                            var bp = new vec2_1.default(ball.pos.x, ball.pos.y);
                            var side = new vec2_1.default(np.x - p.x, np.y - p.y);
                            var h = side.heading;
                            p.rotate(-h + Math.PI);
                            np.rotate(-h + Math.PI);
                            bp.rotate(-h + Math.PI);
                            var d = bp.y - (p.y + np.y) / 2;
                            if (d >= -ball.r && d <= ball.r && bp.x >= np.x && bp.x <= p.x) {
                                heading = h - Math.PI / 2;
                                rel = d;
                                var _move = vec2_1.default.fromAngle(heading);
                                _move.mult(ball.r - rel);
                                _this.move(_move.x * -1 * ball.m / (_this.m + ball.m), _move.y * -1 * ball.m / (_this.m + ball.m));
                                ball.move(_move.x * 1 * _this.m / (_this.m + ball.m), _move.y * 1 * _this.m / (_this.m + ball.m));
                                cp = ball.pos.copy;
                                cp.add(vec2_1.default.mult(vec2_1.default.fromAngle(heading + Math.PI), d));
                                var _a = vec2_1.default.fromAngle(heading);
                                _a.mult(-30);
                            }
                        });
                        if (heading === 0 || heading) {
                            var v1 = this.vel.copy;
                            var v2 = ball.vel.copy;
                            var ang1 = this.ang;
                            var ang2 = ball.ang;
                            var r1 = vec2_1.default.sub(cp, this.pos);
                            var r2 = vec2_1.default.sub(cp, ball.pos);
                            var am1 = this.am;
                            var am2 = ball.am;
                            var m1 = this.m;
                            var m2 = ball.m;
                            var k = (this.k + ball.k) / 2;
                            var fc = (this.fc + ball.fc) / 2;
                            var v1v = r1.copy;
                            var v2v = r2.copy;
                            v1v.rotate(Math.PI / 2);
                            v2v.rotate(-Math.PI / 2);
                            v1v.mult(ang1);
                            v2v.mult(ang2);
                            v1v.add(v1);
                            v2v.add(v2);
                            v1v.rotate(-heading);
                            v2v.rotate(-heading);
                            var dv1vx = (1 + k) * (m1 * v1v.x + m2 * v2v.x) / (m1 + m2) - (k + 1) * v1v.x;
                            var dv2vx = (1 + k) * (m1 * v1v.x + m2 * v2v.x) / (m1 + m2) - (k + 1) * v2v.x;
                            var vk = (v1v.y * m1 + v2v.y * m2) / (m1 + m2);
                            var dv1vy = -Math.sign(v1v.y) * fc * dv1vx;
                            var dv2vy = -Math.sign(v2v.y) * fc * dv2vx;
                            if (Math.abs(vk - v1v.y) > Math.abs(dv1vy)) dv1vy = vk - v1v.y;
                            if (Math.abs(vk - v2v.y) > Math.abs(dv2vy)) dv2vy = vk - v2v.y;
                            var dv1v = new vec2_1.default(dv1vx, dv1vy);
                            var dv2v = new vec2_1.default(dv2vx, dv2vy);
                            dv1v.rotate(heading);
                            dv2v.rotate(heading);
                            v1.add(dv1v);
                            v2.add(dv2v);
                            dv1v.rotate(-r1.heading);
                            dv2v.rotate(-r2.heading);
                            var dang1 = dv1v.y * m1 * r1.length / (am1 + r1.length * r1.length * m1);
                            var dang2 = -(dv2v.y * m2 * r2.length) / (am2 + r2.length * r2.length * m2);
                            ang1 += dang1;
                            ang2 += dang2;
                            var vp1 = vec2_1.default.fromAngle(r1.heading - Math.PI / 2);
                            vp1.mult(r1.length * dang1);
                            var vp2 = vec2_1.default.fromAngle(r2.heading - Math.PI / 2);
                            vp2.mult(r2.length * dang2);
                            v2.sub(vp2);
                            v1.add(vp1);
                            this.vel = v1;
                            ball.vel = v2;
                            this.ang = ang1;
                            ball.ang = ang2;
                        }
                    }
                    /**
                     * Calculates the mass, moment od intertia and
                     * the centre of mass of the body
                     */

                }, {
                    key: "calculatePosAndMass",
                    value: function calculatePosAndMass() {
                        var poligons = [];
                        poligons.push([]);
                        this.points.forEach(function (p) {
                            poligons[0].push(new vec2_1.default(p.x, p.y));
                        });
                        if (this.isConcave) {
                            var includes = function includes(arr, item) {
                                for (var i = 0; i < arr.length; i++) {
                                    if (arr[i] === item) return true;
                                }
                                return false;
                            };
                            var intersectWithPoligon = function intersectWithPoligon(segment, pol, exceptions) {
                                for (var i = 0; i < pol.length; i++) {
                                    if (!includes(exceptions, i)) {
                                        var side = new linesegment_1.default(new vec2_1.default(pol[i].x, pol[i].y), new vec2_1.default(pol[(i + 1) % pol.length].x, pol[(i + 1) % pol.length].y));
                                        if (linesegment_1.default.intersect(segment, side)) return true;
                                    }
                                }
                                return false;
                            };
                            var found = true;
                            checkAllPoligons: while (found) {
                                found = false;
                                for (var i = 0; i < poligons.length; i++) {
                                    var _pol = poligons[i];
                                    var a = vec2_1.default.sub(_pol[1], _pol[0]);
                                    var b = vec2_1.default.sub(_pol[_pol.length - 1], _pol[0]);
                                    var _angle = vec2_1.default.angleACW(a, b);
                                    if (_angle > Math.PI) {
                                        found = true;
                                        var j = 0;
                                        var k = j + 2;
                                        var newSide = new linesegment_1.default(new vec2_1.default(_pol[j].x, _pol[j].y), new vec2_1.default(_pol[k % _pol.length].x, _pol[k % _pol.length].y));
                                        var newSideHeading = new vec2_1.default(newSide.b.x - newSide.a.x, newSide.b.y - newSide.a.y).heading;
                                        while (!(a.heading > b.heading ? newSideHeading > a.heading && newSideHeading < 2 * Math.PI || newSideHeading > 0 && newSideHeading < b.heading : newSideHeading > a.heading && newSideHeading < b.heading) || intersectWithPoligon(new linesegment_1.default(new vec2_1.default(_pol[j % _pol.length].x, _pol[j % _pol.length].y), new vec2_1.default(_pol[k % _pol.length].x, _pol[k % _pol.length].y)), _pol, [(_pol.length - 1) % _pol.length, j % _pol.length, (k - 1) % _pol.length, k % _pol.length])) {
                                            k++;
                                            newSide = new linesegment_1.default(new vec2_1.default(_pol[j].x, _pol[j].y), new vec2_1.default(_pol[k % _pol.length].x, _pol[k % _pol.length].y));
                                            newSideHeading = new vec2_1.default(newSide.b.x - newSide.a.x, newSide.b.y - newSide.a.y).heading;
                                        }
                                        var pol1 = [];
                                        var pol2 = [];
                                        for (var l = j; l <= k; l++) {
                                            pol1.push(_pol[l % _pol.length]);
                                        }
                                        for (var _l = k; _l <= j + _pol.length; _l++) {
                                            pol2.push(_pol[_l % _pol.length]);
                                        }
                                        poligons[i] = pol1;
                                        poligons.push(pol2);
                                        continue checkAllPoligons;
                                    }
                                    for (var _j = 1; _j < _pol.length; _j++) {
                                        var _a2 = vec2_1.default.sub(_pol[(_j + 1) % _pol.length], _pol[_j]);
                                        var _b = vec2_1.default.sub(_pol[_j - 1], _pol[_j]);
                                        var _angle2 = vec2_1.default.angleACW(_a2, _b);
                                        if (_angle2 > Math.PI) {
                                            found = true;
                                            var _k = _j + 2;
                                            var _newSide = new linesegment_1.default(new vec2_1.default(_pol[_j].x, _pol[_j].y), new vec2_1.default(_pol[_k % _pol.length].x, _pol[_k % _pol.length].y));
                                            var _newSideHeading = new vec2_1.default(_newSide.b.x - _newSide.a.x, _newSide.b.y - _newSide.a.y).heading;
                                            while (!(_a2.heading > _b.heading ? _newSideHeading > _a2.heading && _newSideHeading < 2 * Math.PI || _newSideHeading > 0 && _newSideHeading < _b.heading : _newSideHeading > _a2.heading && _newSideHeading < _b.heading) || intersectWithPoligon(_newSide, _pol, [(_j - 1) % _pol.length, _j % _pol.length, (_k - 1) % _pol.length, _k % _pol.length])) {
                                                _k++;
                                                _newSide = new linesegment_1.default(new vec2_1.default(_pol[_j].x, _pol[_j].y), new vec2_1.default(_pol[_k % _pol.length].x, _pol[_k % _pol.length].y));
                                                _newSideHeading = new vec2_1.default(_newSide.b.x - _newSide.a.x, _newSide.b.y - _newSide.a.y).heading;
                                            }
                                            var _pol2 = [];
                                            var _pol3 = [];
                                            for (var _l2 = _j; _l2 <= _k; _l2++) {
                                                _pol2.push(_pol[_l2 % _pol.length]);
                                            }
                                            for (var _l3 = _k; _l3 <= _j + _pol.length; _l3++) {
                                                _pol3.push(_pol[_l3 % _pol.length]);
                                            }
                                            poligons[i] = _pol2;
                                            poligons.push(_pol3);
                                            continue checkAllPoligons;
                                        }
                                    }
                                }
                            }
                        }
                        for (var _i2 = poligons.length - 1; _i2 >= 0; _i2--) {
                            var _pol4 = poligons[_i2];
                            while (_pol4.length > 3) {
                                poligons.push([_pol4[0], _pol4[1], _pol4[2]]);
                                _pol4.splice(1, 1);
                            }
                        }
                        var mSum = 0;
                        var amSum = 0;
                        var pSum = new vec2_1.default(0, 0);
                        poligons.forEach(function (pol) {
                            var a = Math.sqrt(Math.pow(pol[0].x - pol[1].x, 2) + Math.pow(pol[0].y - pol[1].y, 2));
                            var b = Math.sqrt(Math.pow(pol[1].x - pol[2].x, 2) + Math.pow(pol[1].y - pol[2].y, 2));
                            var c = Math.sqrt(Math.pow(pol[2].x - pol[0].x, 2) + Math.pow(pol[2].y - pol[0].y, 2));
                            var s = (a + b + c) / 2;
                            var m = Math.sqrt(s * (s - a) * (s - b) * (s - c));
                            mSum += m;
                            pSum.x += m * (pol[0].x + pol[1].x + pol[2].x) / 3;
                            pSum.y += m * (pol[0].y + pol[1].y + pol[2].y) / 3;
                        });
                        pSum.div(mSum);
                        this.pos = pSum;
                        this.m = mSum;
                        // calculating the moment of inertia finally
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = poligons[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var _pol5 = _step.value;

                                var _a3 = Math.sqrt(Math.pow(_pol5[0].x - _pol5[1].x, 2) + Math.pow(_pol5[0].y - _pol5[1].y, 2));
                                var _b2 = Math.sqrt(Math.pow(_pol5[1].x - _pol5[2].x, 2) + Math.pow(_pol5[1].y - _pol5[2].y, 2));
                                var c = Math.sqrt(Math.pow(_pol5[2].x - _pol5[0].x, 2) + Math.pow(_pol5[2].y - _pol5[0].y, 2));
                                var w = Math.max(_a3, _b2, c);
                                var s = (_a3 + _b2 + c) / 2;
                                var m = Math.sqrt(s * (s - _a3) * (s - _b2) * (s - c));
                                var h = 2 * m / w;
                                var wpartial = Math.sqrt(Math.pow(Math.min(_a3, c, _b2), 2) - h * h);
                                var am = h * w * (h * h + w * w) / 24;
                                var d = Math.sqrt(h * h / 36 + Math.pow(Math.abs(wpartial - w / 2) / 3, 2));
                                am -= d * d * m;
                                am += Math.pow(new vec2_1.default((_pol5[0].x + _pol5[1].x + _pol5[2].x) / 3, (_pol5[0].y + _pol5[1].y + _pol5[2].y) / 3).dist(this.pos), 2) * m;
                                amSum += am;
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        this.am = amSum;
                    }
                    /**
                     * Rotates the body around it's centre of mass by a given ange
                     * Has to do the transformation for all the points
                     * @param {number} angle Rotation angle
                     */

                }, {
                    key: "rotate",
                    value: function rotate(angle) {
                        var _this2 = this;

                        this.points.forEach(function (p) {
                            var point = new vec2_1.default(p.x, p.y);
                            point.sub(_this2.pos);
                            point.rotate(angle);
                            point.add(_this2.pos);
                            p.x = point.x;
                            p.y = point.y;
                        });
                        this.rotation += angle;
                    }
                    /**
                     * Finds out if the body is concave or not
                     * @return {Boolean} True if the body is concave
                     */

                }, {
                    key: "copy",
                    get: function get() {
                        var pointsCopy = [];
                        for (var i = 0; i < this.points.length; i++) {
                            pointsCopy.push(new vec2_1.default(this.points[i].x, this.points[i].y));
                        }
                        var ret = new Body(pointsCopy, this.vel.copy, this.k, this.ang, this.fc);
                        ret.rotation = this.rotation;
                        ret.lastPos = this.lastPos.copy;
                        ret.pos = this.pos.copy;
                        return ret;
                    }
                }, {
                    key: "isConcave",
                    get: function get() {
                        var pol = this.points;
                        var angle = vec2_1.default.angleACW(vec2_1.default.sub(pol[1], pol[0]), vec2_1.default.sub(pol[pol.length - 1], pol[0]));
                        if (angle > Math.PI) return true;
                        for (var i = 1; i < pol.length - 1; i++) {
                            angle = vec2_1.default.angleACW(vec2_1.default.sub(pol[(i + 1) % pol.length], pol[i]), vec2_1.default.sub(pol[i - 1], pol[i]));
                            if (angle > Math.PI) return true;
                        }
                        angle = vec2_1.default.angleACW(vec2_1.default.sub(pol[0], pol[pol.length - 1]), vec2_1.default.sub(pol[pol.length - 2], pol[pol.length - 1]));
                        if (angle > Math.PI) return true;
                        return false;
                    }
                    /**
                     * Does the collision algorithm between two bodies
                     * @param {Body} b1 First body
                     * @param {Body} b2 Second body
                     */

                }], [{
                    key: "collide",
                    value: function collide(b1, b2) {
                        var matches = 0;
                        var heading = 0;
                        var cp = new vec2_1.default(0, 0);
                        var cps = [];
                        var intersect = false;
                        b1.points.forEach(function (p, idx) {
                            var side1 = new linesegment_1.default(new vec2_1.default(p.x, p.y), new vec2_1.default(b1.points[(idx + 1) % b1.points.length].x, b1.points[(idx + 1) % b1.points.length].y));
                            b2.points.forEach(function (pp, idxx) {
                                var side2 = new linesegment_1.default(new vec2_1.default(pp.x, pp.y), new vec2_1.default(b2.points[(idxx + 1) % b2.points.length].x, b2.points[(idxx + 1) % b2.points.length].y));
                                var sect = linesegment_1.default.intersect(side1, side2);
                                if (sect) {
                                    matches++;
                                    cp.add(sect);
                                    cps.push(sect);
                                    intersect = true;
                                }
                            });
                        });
                        if (!intersect) return;
                        cp.div(matches);
                        for (var i = 0; i < Math.floor(matches / 2); i++) {
                            heading += vec2_1.default.sub(cps[2 * i + 1], cps[2 * i]).heading;
                        }
                        heading /= matches / 2;
                        heading += Math.PI / 2;
                        var a = vec2_1.default.fromAngle(heading);
                        var move1Min = 0;
                        var move1Max = 0;
                        var move2Min = 0;
                        var move2Max = 0;
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = b1.points[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var point = _step2.value;

                                move1Min = Math.min(vec2_1.default.dot(a, vec2_1.default.sub(new vec2_1.default(point.x, point.y), cp)), move1Min);
                                move1Max = Math.max(vec2_1.default.dot(a, vec2_1.default.sub(new vec2_1.default(point.x, point.y), cp)), move1Max);
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                    _iterator2.return();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }

                        var _iteratorNormalCompletion3 = true;
                        var _didIteratorError3 = false;
                        var _iteratorError3 = undefined;

                        try {
                            for (var _iterator3 = b2.points[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                var _point = _step3.value;

                                move2Min = Math.min(vec2_1.default.dot(a, vec2_1.default.sub(new vec2_1.default(_point.x, _point.y), cp)), move2Min);
                                move2Max = Math.max(vec2_1.default.dot(a, vec2_1.default.sub(new vec2_1.default(_point.x, _point.y), cp)), move2Max);
                            }
                        } catch (err) {
                            _didIteratorError3 = true;
                            _iteratorError3 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                                    _iterator3.return();
                                }
                            } finally {
                                if (_didIteratorError3) {
                                    throw _iteratorError3;
                                }
                            }
                        }

                        if (Math.abs(move1Min - move2Max) < Math.abs(move2Min - move1Max)) {
                            b1.move(-a.x * move1Min, -a.y * move1Min);
                            b2.move(-a.x * move2Max, -a.y * move2Max);
                        } else {
                            b1.move(-a.x * move1Max, -a.y * move1Max);
                            b2.move(-a.x * move2Min, -a.y * move2Min);
                        }
                        var k = (b1.k + b2.k) / 2;
                        // let vel1parralel = Vec2.cross(b1.vel, a);
                        var vel1perpendicular = vec2_1.default.dot(b1.vel, a);
                        // let vel2parralel = Vec2.cross(b2.vel, a);
                        var vel2perpendicular = vec2_1.default.dot(b2.vel, a);
                        var newVel1Perpendicular = (1 + k) * (b1.m * vel1perpendicular + b2.m * vel2perpendicular) / (b1.m + b2.m) - k * vel1perpendicular;
                        var newVel2Perpendicular = (1 + k) * (b1.m * vel1perpendicular + b2.m * vel2perpendicular) / (b1.m + b2.m) - k * vel2perpendicular;
                        b1.vel.add(vec2_1.default.mult(a.copy, newVel1Perpendicular - vel1perpendicular));
                        b2.vel.add(vec2_1.default.mult(a.copy, newVel2Perpendicular - vel2perpendicular));
                    }
                }]);

                return Body;
            }();

            exports.default = Body;
        }, { "./linesegment": 3, "./vec2": 8 }], 3: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var vec2_1 = require("./vec2");
            /**
             * Class representing a segment of a line
             */

            var LineSegment = function () {
                /**
                 * Create a segment
                 * @param {Vec2} a Starting point
                 * @param {Vec2} b Ending point
                 */
                function LineSegment(a, b) {
                    _classCallCheck(this, LineSegment);

                    this.a = a;
                    this.b = b;
                }
                /**
                 * Get the length of the segment
                 * @return {number} The length
                 */


                _createClass(LineSegment, [{
                    key: "distFromPoint",

                    /**
                     * Get the distance between a point and the line segment
                     * @param {Vec2} p The point as a vector
                     * @return {number} The distance
                     */
                    value: function distFromPoint(p) {
                        var e = vec2_1.default.sub(this.a, this.b);
                        var A = vec2_1.default.sub(p, this.b);
                        var B = vec2_1.default.sub(p, this.a);
                        var a = A.length;
                        var b = B.length;
                        var c = e.length;
                        if (c === 0) return a;
                        var gamma = vec2_1.default.angle(A, B);
                        var betha = vec2_1.default.angle(A, e);
                        var alpha = Math.PI - gamma - betha;
                        var area = Math.sin(alpha) * b * c / 2;
                        var m = 2 * area / c;
                        if (alpha > Math.PI / 2) return b;
                        if (betha > Math.PI / 2) return a;
                        return m;
                    }
                    /**
                     * Get if they intersect or not
                     * If they intersect it returns the intersection point
                     * If they not it returns undefined
                     * @param {LineSegment} segment1 A segment
                     * @param {LineSegment} segment2 Other segment
                     * @return {Vec2} Intersetion point
                     */

                }, {
                    key: "length",
                    get: function get() {
                        return vec2_1.default.dist(this.a, this.b);
                    }
                }], [{
                    key: "intersect",
                    value: function intersect(segment1, segment2) {
                        var v1 = vec2_1.default.sub(segment1.b, segment1.a);
                        var a1 = v1.y / v1.x;
                        var c1 = segment1.b.y - segment1.b.x * a1;
                        var v2 = vec2_1.default.sub(segment2.b, segment2.a);
                        var a2 = v2.y / v2.x;
                        var c2 = segment2.b.y - segment2.b.x * a2;
                        if (v1.x === 0 && v2.x !== 0) {
                            if (segment1.a.x >= segment2.a.x && segment1.a.x <= segment2.b.x || segment1.a.x <= segment2.a.x && segment1.a.x >= segment2.b.x) {
                                var h = a2 * segment1.a.x + c2;
                                if (h > segment1.a.y && h < segment1.b.y || h < segment1.a.y && h > segment1.b.y) {
                                    return new vec2_1.default(segment1.a.x, h);
                                }
                            }
                            return undefined;
                        }
                        if (v2.x === 0 && v1.x !== 0) {
                            if (segment2.a.x >= segment1.a.x && segment2.a.x <= segment1.b.x || segment2.a.x <= segment1.a.x && segment2.a.x >= segment1.b.x) {
                                var _h = a1 * segment2.a.x + c1;
                                if (_h > segment2.a.y && _h < segment2.b.y || _h < segment2.a.y && _h > segment2.b.y) {
                                    return new vec2_1.default(segment2.a.x, _h);
                                }
                            }
                            return undefined;
                        }
                        if (v1.x === 0 && v2.x === 0) {
                            if (segment1.a.x === segment2.a.x) {
                                var _interval = void 0;
                                if (segment1.a.y < segment1.b.y) {
                                    _interval = [segment1.a.y, segment1.b.y];
                                } else {
                                    _interval = [segment1.b.y, segment1.a.y];
                                }
                                var _interval2 = void 0;
                                if (segment2.a.y < segment2.b.y) {
                                    _interval2 = [segment2.a.y, segment2.b.y];
                                } else {
                                    _interval2 = [segment2.b.y, segment2.a.y];
                                }
                                var _interval3 = [_interval[0] > _interval2[0] ? _interval[0] : _interval2[0], _interval[1] < _interval2[1] ? _interval[1] : _interval2[1]];
                                if (_interval3[0] <= _interval3[1]) {
                                    return new vec2_1.default(segment1.a.x, (_interval3[0] + _interval3[1]) / 2);
                                }
                            }
                            return undefined;
                        }
                        var interval1 = void 0;
                        if (segment1.a.x < segment1.b.x) {
                            interval1 = [segment1.a.x, segment1.b.x];
                        } else {
                            interval1 = [segment1.b.x, segment1.a.x];
                        }
                        var interval2 = void 0;
                        if (segment2.a.x < segment2.b.x) {
                            interval2 = [segment2.a.x, segment2.b.x];
                        } else {
                            interval2 = [segment2.b.x, segment2.a.x];
                        }
                        var interval = [interval1[0] > interval2[0] ? interval1[0] : interval2[0], interval1[1] < interval2[1] ? interval1[1] : interval2[1]];
                        // If they are parralel the only time they intersect is when c1 == c2.
                        if (a1 === a2 && c1 === c2 && interval[0] <= interval[1]) {
                            return new vec2_1.default((interval[0] + interval[1]) / 2, (interval[0] + interval[1]) / 2 * a1 + c1);
                        }
                        var x = (c2 - c1) / (a1 - a2);
                        if (x >= interval[0] && x <= interval[1]) {
                            return new vec2_1.default(x, x * a1 + c1);
                        } else return undefined;
                    }
                }]);

                return LineSegment;
            }();

            exports.default = LineSegment;
        }, { "./vec2": 8 }], 4: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var vec2_1 = require("./vec2");
            exports.Vec2 = vec2_1.default;
            var ball_1 = require("./ball");
            exports.Ball = ball_1.default;
            var wall_1 = require("./wall");
            exports.Wall = wall_1.default;
            var linesegment_1 = require("./linesegment");
            exports.LineSegment = linesegment_1.default;
            var stick_1 = require("./stick");
            exports.Stick = stick_1.default;
            var spring_1 = require("./spring");
            exports.Spring = spring_1.default;
            var softball_1 = require("./softball");
            exports.SoftBall = softball_1.default;
            var body_1 = require("./body");
            exports.Body = body_1.default;
            /**
             * Class that creates a new world ba the physics engine
             */

            var Physics = function () {
                /**
                 * Create and initalize a new world
                 */
                function Physics() {
                    _classCallCheck(this, Physics);

                    this.balls = [];
                    this.bodies = [];
                    this.fixedBalls = [];
                    this.softBalls = [];
                    this.walls = [];
                    this.bounds = [];
                    this.springs = [];
                    // Air friction has to be between 0 and 1
                    // 0 - no movement
                    // 1 - no friction
                    this.airFriction = 1;
                    this.gravity = new vec2_1.default(0, 0);
                }
                /**
                 * Updates the world by a given amount of time
                 * @param {number} t Elapsed time
                 * @param {boolean} precise If this is true,
                 * then the simulation is going to be more precise
                 */


                _createClass(Physics, [{
                    key: "update",
                    value: function update(t, precise) {
                        var _this3 = this;

                        // Do the simulation on the reversed system
                        // if the simulation is in precise mode
                        var clonedSystem = precise ? this.copy : new Physics();
                        if (precise) {
                            clonedSystem.bodies.reverse();
                            clonedSystem.balls.reverse();
                            clonedSystem.update(t, false);
                        }
                        // At first move objets
                        for (var i = 0; i < this.balls.length; i++) {
                            // Move
                            this.balls[i].lastPos = this.balls[i].pos.copy;
                            this.balls[i].pos.add(vec2_1.default.mult(this.balls[i].vel, t));
                            // Angular velocity
                            this.balls[i].rotation += this.balls[i].ang * t;
                            this.balls[i].rotation %= Math.PI * 2;
                        }
                        for (var _i3 = 0; _i3 < this.bodies.length; _i3++) {
                            this.bodies[_i3].lastPos = this.bodies[_i3].pos.copy;
                            this.bodies[_i3].move(this.bodies[_i3].vel.x * t, this.bodies[_i3].vel.y * t);
                            this.bodies[_i3].rotate(this.bodies[_i3].ang * t);
                        }
                        // Update springs multiple times
                        for (var _i4 = 0; _i4 < 3; _i4++) {
                            var _iteratorNormalCompletion4 = true;
                            var _didIteratorError4 = false;
                            var _iteratorError4 = undefined;

                            try {
                                for (var _iterator4 = this.springs[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                                    var element = _step4.value;

                                    element.update(t / 3 / 2);
                                }
                            } catch (err) {
                                _didIteratorError4 = true;
                                _iteratorError4 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                                        _iterator4.return();
                                    }
                                } finally {
                                    if (_didIteratorError4) {
                                        throw _iteratorError4;
                                    }
                                }
                            }
                        }
                        for (var _i5 = 0; _i5 < this.balls.length; _i5++) {
                            // Apply gravity
                            if (this.gravity) {
                                this.balls[_i5].vel.add(new vec2_1.default(this.gravity.x * t, this.gravity.y * t));
                            }
                            // Collision
                            for (var j = _i5 + 1; j < this.balls.length; j++) {
                                if (this.balls[_i5].layer != this.balls[j].layer || !this.balls[_i5].layer && !this.balls[j].layer) {
                                    ball_1.default.collide(this.balls[_i5], this.balls[j]);
                                }
                            }
                            // Collision with walls
                            var _iteratorNormalCompletion5 = true;
                            var _didIteratorError5 = false;
                            var _iteratorError5 = undefined;

                            try {
                                for (var _iterator5 = this.walls[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                                    var wall = _step5.value;

                                    wall.collideWithBall(this.balls[_i5]);
                                }
                                // Collision with fixed balls
                            } catch (err) {
                                _didIteratorError5 = true;
                                _iteratorError5 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion5 && _iterator5.return) {
                                        _iterator5.return();
                                    }
                                } finally {
                                    if (_didIteratorError5) {
                                        throw _iteratorError5;
                                    }
                                }
                            }

                            var _iteratorNormalCompletion6 = true;
                            var _didIteratorError6 = false;
                            var _iteratorError6 = undefined;

                            try {
                                for (var _iterator6 = this.fixedBalls[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                                    var b = _step6.value;

                                    var ball = this.balls[_i5];
                                    var heading = void 0;
                                    var rel = 0;
                                    var p = new vec2_1.default(b.x, b.y);
                                    p.x -= ball.pos.x;
                                    p.y -= ball.pos.y;
                                    p.mult(-1);
                                    if (p.length <= ball.r + b.r) {
                                        heading = p.heading;
                                        rel = p.length;
                                    }
                                    if (heading === 0 || heading) {
                                        var pos = new vec2_1.default(ball.pos.x, ball.pos.y);
                                        var vel = new vec2_1.default(ball.vel.x, ball.vel.y);
                                        pos.rotate(-heading + Math.PI / 2);
                                        vel.rotate(-heading + Math.PI / 2);
                                        vel.y *= -ball.k;
                                        pos.y += ball.r + b.r - rel;
                                        var _dvy4 = vel.y * (1 + 1 / ball.k);
                                        var _dvx4 = Math.abs(_dvy4) * ball.fc * Math.sign(vel.x - ball.ang * ball.r) * -1;
                                        if (Math.abs(_dvx4) > Math.abs(vel.x - ball.ang * ball.r)) {
                                            _dvx4 = -vel.x + ball.ang * ball.r;
                                        }
                                        vel.x += _dvx4 - ball.r * ball.r * ball.m * _dvx4 / (ball.am + ball.r * ball.r * ball.m);
                                        ball.ang -= ball.r * ball.r * ball.m * _dvx4 / ((ball.am + ball.r * ball.r * ball.m) * ball.r);
                                        pos.rotate(heading - Math.PI / 2);
                                        vel.rotate(heading - Math.PI / 2);
                                        ball.pos.x = pos.x;
                                        ball.pos.y = pos.y;
                                        ball.vel.x = vel.x;
                                        ball.vel.y = vel.y;
                                    }
                                }
                                // Bounce off the edges
                            } catch (err) {
                                _didIteratorError6 = true;
                                _iteratorError6 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion6 && _iterator6.return) {
                                        _iterator6.return();
                                    }
                                } finally {
                                    if (_didIteratorError6) {
                                        throw _iteratorError6;
                                    }
                                }
                            }

                            if (this.bounds.length > 0) {
                                if (this.balls[_i5].pos.x - this.balls[_i5].r < this.bounds[0]) {
                                    var ball = this.balls[_i5];
                                    ball.vel.x *= -ball.k;
                                    ball.pos.x = this.bounds[1] + ball.r;
                                    var dvx = ball.vel.x * (1 + 1 / ball.k);
                                    var dvy = Math.abs(dvx) * ball.fc * Math.sign(ball.vel.y + ball.ang * ball.r) * -1;
                                    if (Math.abs(dvy) > Math.abs(ball.vel.y + ball.ang * ball.r)) {
                                        dvy = -ball.vel.y - ball.ang * ball.r;
                                    }
                                    ball.vel.y += dvy - ball.r * ball.r * ball.m * dvy / (ball.am + ball.r * ball.r * ball.m);
                                    ball.ang += ball.r * ball.r * ball.m * dvy / ((ball.am + ball.r * ball.r * ball.m) * ball.r);
                                } else if (this.balls[_i5].pos.x + this.balls[_i5].r > this.bounds[0] + this.bounds[2]) {
                                    var _ball = this.balls[_i5];
                                    _ball.vel.x *= -_ball.k;
                                    _ball.pos.x = this.bounds[0] + this.bounds[2] - _ball.r;
                                    var _dvx = _ball.vel.x * (1 + 1 / _ball.k);
                                    var _dvy = Math.abs(_dvx) * _ball.fc * Math.sign(_ball.vel.y - _ball.ang * _ball.r) * -1;
                                    if (Math.abs(_dvy) > Math.abs(_ball.vel.y - _ball.ang * _ball.r)) {
                                        _dvy = -_ball.vel.y + _ball.ang * _ball.r;
                                    }
                                    _ball.vel.y += _dvy + _ball.r * _ball.r * _ball.m * _dvy / (_ball.am + _ball.r * _ball.r * _ball.m);
                                    _ball.ang -= _ball.r * _ball.r * _ball.m * _dvy / ((_ball.am + _ball.r * _ball.r * _ball.m) * _ball.r);
                                }
                                if (this.balls[_i5].pos.y + this.balls[_i5].r > this.bounds[1] + this.bounds[3]) {
                                    var _ball2 = this.balls[_i5];
                                    _ball2.vel.y *= -_ball2.k;
                                    _ball2.pos.y = this.bounds[1] + this.bounds[3] - _ball2.r;
                                    var _dvy2 = _ball2.vel.y * (1 + 1 / _ball2.k);
                                    var _dvx2 = Math.abs(_dvy2) * _ball2.fc * Math.sign(_ball2.vel.x + _ball2.ang * _ball2.r) * -1;
                                    if (Math.abs(_dvx2) > Math.abs(_ball2.vel.x + _ball2.ang * _ball2.r)) {
                                        _dvx2 = -_ball2.vel.x - _ball2.ang * _ball2.r;
                                    }
                                    _ball2.vel.x += _dvx2 - _ball2.r * _ball2.r * _ball2.m * _dvx2 / (_ball2.am + _ball2.r * _ball2.r * _ball2.m);
                                    _ball2.ang += _ball2.r * _ball2.r * _ball2.m * _dvx2 / ((_ball2.am + _ball2.r * _ball2.r * _ball2.m) * _ball2.r);
                                } else if (this.balls[_i5].pos.y - this.balls[_i5].r < this.bounds[1]) {
                                    var _ball3 = this.balls[_i5];
                                    _ball3.vel.y *= -_ball3.k;
                                    _ball3.pos.y = this.bounds[1] + _ball3.r;
                                    var _dvy3 = _ball3.vel.y * (1 + 1 / _ball3.k);
                                    var _dvx3 = Math.abs(_dvy3) * _ball3.fc * Math.sign(_ball3.vel.x - _ball3.ang * _ball3.r) * -1;
                                    if (Math.abs(_dvx3) > Math.abs(_ball3.vel.x - _ball3.ang * _ball3.r)) {
                                        _dvx3 = -_ball3.vel.x + _ball3.ang * _ball3.r;
                                    }
                                    _ball3.vel.x += _dvx3 + _ball3.r * _ball3.r * _ball3.m * _dvx3 / (_ball3.am + _ball3.r * _ball3.r * _ball3.m);
                                    _ball3.ang -= _ball3.r * _ball3.r * _ball3.m * _dvx3 / ((_ball3.am + _ball3.r * _ball3.r * _ball3.m) * _ball3.r);
                                }
                            }
                        }
                        for (var _i6 = 0; _i6 < this.bodies.length; _i6++) {
                            var _iteratorNormalCompletion7 = true;
                            var _didIteratorError7 = false;
                            var _iteratorError7 = undefined;

                            try {
                                for (var _iterator7 = this.balls[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                                    var _ball4 = _step7.value;

                                    if (_ball4.layer != this.bodies[_i6].layer || !_ball4.layer && !this.bodies[_i6].layer) {
                                        this.bodies[_i6].collideWithBall(_ball4);
                                    }
                                }
                            } catch (err) {
                                _didIteratorError7 = true;
                                _iteratorError7 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion7 && _iterator7.return) {
                                        _iterator7.return();
                                    }
                                } finally {
                                    if (_didIteratorError7) {
                                        throw _iteratorError7;
                                    }
                                }
                            }

                            for (var _j2 = _i6 + 1; _j2 < this.bodies.length; _j2++) {
                                if (this.bodies[_i6].layer != this.bodies[_j2].layer || !this.bodies[_j2].layer && !this.bodies[_i6].layer) {
                                    body_1.default.collide(this.bodies[_i6], this.bodies[_j2]);
                                }
                            }
                            // Apply gravity
                            if (this.gravity) {
                                this.bodies[_i6].vel.add(new vec2_1.default(this.gravity.x * t, this.gravity.y * t));
                            }
                        }
                        // Update soft balls
                        this.softBalls.forEach(function (sb) {
                            softball_1.default.updatePressureBasedForces(sb, t);
                        });
                        // Update springs again multiple times
                        for (var _i7 = 0; _i7 < 3; _i7++) {
                            var _iteratorNormalCompletion8 = true;
                            var _didIteratorError8 = false;
                            var _iteratorError8 = undefined;

                            try {
                                for (var _iterator8 = this.springs[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                                    var _element = _step8.value;

                                    _element.update(t / 3 / 2);
                                }
                            } catch (err) {
                                _didIteratorError8 = true;
                                _iteratorError8 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion8 && _iterator8.return) {
                                        _iterator8.return();
                                    }
                                } finally {
                                    if (_didIteratorError8) {
                                        throw _iteratorError8;
                                    }
                                }
                            }
                        }
                        // Apply air friction
                        this.balls.forEach(function (b) {
                            b.vel.mult(Math.pow(_this3.airFriction, t));
                            b.ang *= Math.pow(_this3.airFriction, t);
                        });
                        this.bodies.forEach(function (b) {
                            b.vel.mult(Math.pow(_this3.airFriction, t));
                            b.ang *= Math.pow(_this3.airFriction, t);
                        });
                        // Then take the average of this system and the other system
                        // if in precise mode
                        if (precise) {
                            clonedSystem.bodies.reverse();
                            clonedSystem.balls.reverse();
                            // Take the average of the balls
                            this.balls.forEach(function (ball, i) {
                                ball.move((clonedSystem.balls[i].pos.x - ball.pos.x) * 0.5, (clonedSystem.balls[i].pos.y - ball.pos.y) * 0.5);
                                ball.vel.add(new vec2_1.default((clonedSystem.balls[i].vel.x - ball.vel.x) * 0.5, (clonedSystem.balls[i].vel.y - ball.vel.y) * 0.5));
                                ball.rotation = (ball.rotation + clonedSystem.balls[i].rotation) / 2;
                                ball.ang = (ball.ang + clonedSystem.balls[i].ang) / 2;
                            });
                            // Take the average of the bodies
                            this.bodies.forEach(function (body, i) {
                                var other = clonedSystem.bodies[i];
                                body.move((other.pos.x - body.pos.x) * 0.5, (other.pos.y - body.pos.y) * 0.5);
                                body.vel.add(new vec2_1.default((other.vel.x - body.vel.x) * 0.5, (other.vel.y - body.vel.y) * 0.5));
                                body.rotate((other.rotation - body.rotation) / 2);
                                body.ang = (body.ang + other.ang) / 2;
                            });
                        }
                    }
                    /**
                     * Returns a copy of this system
                     * @return {Physics} The copy of this system
                     */

                }, {
                    key: "setAirFriction",

                    /**
                     * Air friction. has to be between 0 and 1
                     * 0 - no movement
                     * 1 - no friction
                     * @param {number} airFriction Has to be between 0 and 1
                     */
                    value: function setAirFriction(airFriction) {
                        if (!isFinite(airFriction)) return;
                        this.airFriction = airFriction;
                        if (this.airFriction < 0) this.airFriction = 0;
                        if (this.airFriction > 1) this.airFriction = 1;
                    }
                    /**
                     * Sets the gravity in the world
                     * @param {Vec2} dir The acceleration vector of the gravity
                     */

                }, {
                    key: "setGravity",
                    value: function setGravity(dir) {
                        this.gravity = dir.copy;
                    }
                    /**
                     * Appends a new ball to the world
                     * @param {Ball} ball Ball to add to the world
                     */

                }, {
                    key: "addBall",
                    value: function addBall(ball) {
                        this.balls.push(ball);
                    }
                    /**
                     * Appends a new body to the world
                     * @param {Body} body Body to add to the world
                     */

                }, {
                    key: "addBody",
                    value: function addBody(body) {
                        this.bodies.push(body);
                    }
                    /**
                     * Appends a new soft ball to the world
                     * @param {SoftBall} softBall SoftBall to be added to the world
                     */

                }, {
                    key: "addSoftBall",
                    value: function addSoftBall(softBall) {
                        var _balls, _springs;

                        (_balls = this.balls).push.apply(_balls, _toConsumableArray(softBall.points));
                        (_springs = this.springs).push.apply(_springs, _toConsumableArray(softBall.sides));
                        this.softBalls.push(softBall);
                    }
                    /**
                     * Appends a rectangular wall to the world
                     * @param {number} x x coordinate of the rectangular wall
                     * @param {number} y y coordinate of the rectangular wall
                     * @param {number} w width of the rectangular wall
                     * @param {number} h height of the rectangular wall
                     */

                }, {
                    key: "addRectWall",
                    value: function addRectWall(x, y, w, h) {
                        var points = [];
                        points.push(new vec2_1.default(x - w / 2, y - h / 2));
                        points.push(new vec2_1.default(x + w / 2, y - h / 2));
                        points.push(new vec2_1.default(x + w / 2, y + h / 2));
                        points.push(new vec2_1.default(x - w / 2, y + h / 2));
                        this.walls.push(new wall_1.default(points));
                        // this.bodies.push(new Body(points, new Vec2(0, 0), 0.5, 0, 0.3));
                    }
                    /**
                     * Appends a rectangular body to the world
                     * @param {number} x x coordinate of the rectangular body
                     * @param {number} y y coordinate of the rectangular body
                     * @param {number} w width of the rectangular body
                     * @param {number} h height of the rectangular body
                     * @param {number} fc friction coefficient of the body
                     * @param {number} k coefficient of restitution of the body
                     */

                }, {
                    key: "addRectBody",
                    value: function addRectBody(x, y, w, h, fc, k) {
                        var points = [];
                        points.push(new vec2_1.default(x - w / 2, y - h / 2));
                        points.push(new vec2_1.default(x + w / 2, y - h / 2));
                        points.push(new vec2_1.default(x + w / 2, y + h / 2));
                        points.push(new vec2_1.default(x - w / 2, y + h / 2));
                        this.bodies.push(new body_1.default(points, new vec2_1.default(0, 0), 0.5, 0, 0.3));
                    }
                    /**
                     * Append a new wall to the world
                     * @param {Wall} wall Wall to append to the world
                     */

                }, {
                    key: "addWall",
                    value: function addWall(wall) {
                        this.walls.push(wall);
                    }
                    /**
                     * Appends a fixed ball to the world
                     * A fixed ball is immovable and other objects collide with it
                     * @param {number} x x coordinate of the fixed ball
                     * @param {number} y y coordinate of the fixed ball
                     * @param {number} r radius of the fixed ball
                     */

                }, {
                    key: "addFixedBall",
                    value: function addFixedBall(x, y, r) {
                        this.fixedBalls.push({
                            x: x, y: y, r: r
                        });
                    }
                    /**
                     * Appends a new spring to the world
                     * @param {Spring} spring Spring to add to the world
                     */

                }, {
                    key: "addSpring",
                    value: function addSpring(spring) {
                        this.springs.push(spring);
                    }
                    /**
                     * Sets the size of the world (without this the world
                     * does not have bounds)
                     * @param {number} x x coordinate of the centre of the world
                     * @param {number} y y coordinate of the centre of the world
                     * @param {number} w Width of the world
                     * @param {number} h Height of the world
                     */

                }, {
                    key: "setBounds",
                    value: function setBounds(x, y, w, h) {
                        this.bounds = [x, y, w, h];
                    }
                    /**
                     * Search for any object at the given coordinate then returns it
                     * Return false if nothing is found
                     * @param {number} x x coordinate
                     * @param {number} y y coordinate
                     * @return {Ball} The found object
                     */

                }, {
                    key: "getObjectAtCoordinates",
                    value: function getObjectAtCoordinates(x, y) {
                        var ret = undefined;
                        var v = new vec2_1.default(x, y);
                        this.balls.forEach(function (ball) {
                            if (ball.pos.dist(v) < ball.r) ret = ball;
                        });
                        return ret;
                    }
                    /**
                     * Returns an array of copies of all balls in the system
                     * @return {Array<Ball>} The array of the copied balls
                     */

                }, {
                    key: "getCopyOfBalls",
                    value: function getCopyOfBalls() {
                        var ret = [];
                        this.balls.forEach(function (item) {
                            ret.push(item.copy);
                        });
                        return ret;
                    }
                    /**
                     * Returns an array of copies of all bodies in the system
                     * @return {Array<Body>} The array of the copied bodies
                     */

                }, {
                    key: "getCopyOfBodies",
                    value: function getCopyOfBodies() {
                        var ret = [];
                        this.bodies.forEach(function (item) {
                            ret.push(item.copy);
                        });
                        return ret;
                    }
                }, {
                    key: "copy",
                    get: function get() {
                        var _this4 = this;

                        var ret = new Physics();
                        ret.balls = this.getCopyOfBalls();
                        ret.bodies = this.getCopyOfBodies();
                        ret.fixedBalls = this.fixedBalls;
                        ret.walls = this.walls;
                        ret.bounds = this.bounds;
                        ret.gravity = this.gravity;
                        this.springs.forEach(function (spring) {
                            var TypeOfSpring = spring.constructor == spring_1.default ? spring_1.default : stick_1.default;
                            var copiedSpring = new TypeOfSpring(spring.length, spring.springConstant);
                            copiedSpring.rotationLocked = spring.rotationLocked;
                            copiedSpring.pinned = spring.pinned;
                            spring.objects.forEach(function (obj) {
                                var idx = _this4.balls.indexOf(obj);
                                if (idx != -1) copiedSpring.attachObject(ret.balls[idx]);else {
                                    idx = _this4.bodies.indexOf(obj);
                                    if (idx != -1) copiedSpring.attachObject(ret.bodies[idx]);
                                }
                            });
                            ret.springs.push(copiedSpring);
                        });
                        return ret;
                    }
                }]);

                return Physics;
            }();

            exports.Physics = Physics;
        }, { "./ball": 1, "./body": 2, "./linesegment": 3, "./softball": 5, "./spring": 6, "./stick": 7, "./vec2": 8, "./wall": 9 }], 5: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var vec2_1 = require("./vec2");
            var ball_1 = require("./ball");
            var stick_1 = require("./stick");
            var linesegment_1 = require("./linesegment");
            /**
             * Class representing a softbody object
             * They work like a ball, with pressure inside
             */

            var SoftBall = function () {
                /**
                 * Creates a SoftBall
                 * @param {Vec2} pos The starting position of the soft ball
                 * @param {number} r The radius of the soft ball
                 * @param {number} pressure The "hardness" of the soft ball
                 * @param {number} fc Friction coefficient
                 * @param {number} resolution The number of points that make up the ball
                 */
                function SoftBall(pos, r, pressure, fc, resolution) {
                    _classCallCheck(this, SoftBall);

                    this.points = [];
                    if (fc || fc === 0) this.fc = fc;else this.fc = 0.4;
                    this.pressure = pressure;
                    if (!resolution) this.resolution = 30;else this.resolution = resolution;
                    r = Math.abs(r);
                    this.r = r;
                    var layerNuber = Math.random();
                    for (var i = 0; i < this.resolution; i++) {
                        var newPos = new vec2_1.default(pos.x, pos.y);
                        newPos.add(vec2_1.default.mult(vec2_1.default.fromAngle(i / this.resolution * Math.PI * 2), r));
                        this.points.push(new ball_1.default(newPos, new vec2_1.default(0, 0), r * Math.sin(Math.PI / this.resolution), 0, 0, this.fc));
                        this.points[this.points.length - 1].layer = layerNuber;
                    }
                    this.sides = [];
                    for (var _i8 = 0; _i8 < this.resolution; _i8++) {
                        var side = new stick_1.default(2 * r * Math.sin(Math.PI / this.resolution));
                        side.attachObject(this.points[_i8]);
                        side.attachObject(this.points[(_i8 + 1) % this.resolution]);
                        if (_i8 % 2 === 0) side.lockRotation();
                        this.sides.push(side);
                    }
                }
                /**
                 * Updates the pressure-based forces in the soft ball
                 * @param {SoftBall} softBall The soft ball to update
                 * @param {number} t Elapsed time
                 */


                _createClass(SoftBall, null, [{
                    key: "updatePressureBasedForces",
                    value: function updatePressureBasedForces(softBall, t) {
                        var poligons = [];
                        poligons.push([]);
                        softBall.points.forEach(function (p) {
                            poligons[0].push(new vec2_1.default(p.pos.x, p.pos.y));
                        });
                        if (function (pol) {
                            var angle = vec2_1.default.angleACW(vec2_1.default.sub(pol[1], pol[0]), vec2_1.default.sub(pol[pol.length - 1], pol[0]));
                            if (angle > Math.PI) return true;
                            for (var i = 1; i < pol.length - 1; i++) {
                                angle = vec2_1.default.angleACW(vec2_1.default.sub(pol[(i + 1) % pol.length], pol[i]), vec2_1.default.sub(pol[i - 1], pol[i]));
                                if (angle > Math.PI) return true;
                            }
                            angle = vec2_1.default.angleACW(vec2_1.default.sub(pol[0], pol[pol.length - 1]), vec2_1.default.sub(pol[pol.length - 2], pol[pol.length - 1]));
                            if (angle > Math.PI) return true;
                            return false;
                        }(poligons[0])) {
                            var includes = function includes(arr, item) {
                                for (var i = 0; i < arr.length; i++) {
                                    if (arr[i] === item) return true;
                                }
                                return false;
                            };
                            var intersectWithPoligon = function intersectWithPoligon(segment, pol, exceptions) {
                                for (var i = 0; i < pol.length; i++) {
                                    if (!includes(exceptions, i)) {
                                        var side = new linesegment_1.default(new vec2_1.default(pol[i].x, pol[i].y), new vec2_1.default(pol[(i + 1) % pol.length].x, pol[(i + 1) % pol.length].y));
                                        if (linesegment_1.default.intersect(segment, side)) return true;
                                    }
                                }
                                return false;
                            };
                            var found = true;
                            checkAllPoligons: while (found) {
                                found = false;
                                for (var i = 0; i < poligons.length; i++) {
                                    var _pol6 = poligons[i];
                                    var a = vec2_1.default.sub(_pol6[1], _pol6[0]);
                                    var b = vec2_1.default.sub(_pol6[_pol6.length - 1], _pol6[0]);
                                    var _angle3 = vec2_1.default.angleACW(a, b);
                                    if (_angle3 > Math.PI) {
                                        found = true;
                                        var j = 0;
                                        var k = j + 2;
                                        var newSide = new linesegment_1.default(new vec2_1.default(_pol6[j].x, _pol6[j].y), new vec2_1.default(_pol6[k % _pol6.length].x, _pol6[k % _pol6.length].y));
                                        var newSideHeading = new vec2_1.default(newSide.b.x - newSide.a.x, newSide.b.y - newSide.a.y).heading;
                                        while (!(a.heading > b.heading ? newSideHeading > a.heading && newSideHeading < 2 * Math.PI || newSideHeading > 0 && newSideHeading < b.heading : newSideHeading > a.heading && newSideHeading < b.heading) || intersectWithPoligon(new linesegment_1.default(new vec2_1.default(_pol6[j % _pol6.length].x, _pol6[j % _pol6.length].y), new vec2_1.default(_pol6[k % _pol6.length].x, _pol6[k % _pol6.length].y)), _pol6, [(_pol6.length - 1) % _pol6.length, j % _pol6.length, (k - 1) % _pol6.length, k % _pol6.length])) {
                                            k++;
                                            newSide = new linesegment_1.default(new vec2_1.default(_pol6[j].x, _pol6[j].y), new vec2_1.default(_pol6[k % _pol6.length].x, _pol6[k % _pol6.length].y));
                                            newSideHeading = new vec2_1.default(newSide.b.x - newSide.a.x, newSide.b.y - newSide.a.y).heading;
                                        }
                                        var pol1 = [];
                                        var pol2 = [];
                                        for (var l = j; l <= k; l++) {
                                            pol1.push(_pol6[l % _pol6.length]);
                                        }
                                        for (var _l4 = k; _l4 <= j + _pol6.length; _l4++) {
                                            pol2.push(_pol6[_l4 % _pol6.length]);
                                        }
                                        poligons[i] = pol1;
                                        poligons.push(pol2);
                                        continue checkAllPoligons;
                                    }
                                    for (var _j3 = 1; _j3 < _pol6.length; _j3++) {
                                        var _a4 = vec2_1.default.sub(_pol6[(_j3 + 1) % _pol6.length], _pol6[_j3]);
                                        var _b3 = vec2_1.default.sub(_pol6[_j3 - 1], _pol6[_j3]);
                                        var _angle4 = vec2_1.default.angleACW(_a4, _b3);
                                        if (_angle4 > Math.PI) {
                                            found = true;
                                            var _k2 = _j3 + 2;
                                            var _newSide2 = new linesegment_1.default(new vec2_1.default(_pol6[_j3].x, _pol6[_j3].y), new vec2_1.default(_pol6[_k2 % _pol6.length].x, _pol6[_k2 % _pol6.length].y));
                                            var _newSideHeading2 = new vec2_1.default(_newSide2.b.x - _newSide2.a.x, _newSide2.b.y - _newSide2.a.y).heading;
                                            while (!(_a4.heading > _b3.heading ? _newSideHeading2 > _a4.heading && _newSideHeading2 < 2 * Math.PI || _newSideHeading2 > 0 && _newSideHeading2 < _b3.heading : _newSideHeading2 > _a4.heading && _newSideHeading2 < _b3.heading) || intersectWithPoligon(_newSide2, _pol6, [(_j3 - 1) % _pol6.length, _j3 % _pol6.length, (_k2 - 1) % _pol6.length, _k2 % _pol6.length])) {
                                                _k2++;
                                                _newSide2 = new linesegment_1.default(new vec2_1.default(_pol6[_j3].x, _pol6[_j3].y), new vec2_1.default(_pol6[_k2 % _pol6.length].x, _pol6[_k2 % _pol6.length].y));
                                                _newSideHeading2 = new vec2_1.default(_newSide2.b.x - _newSide2.a.x, _newSide2.b.y - _newSide2.a.y).heading;
                                            }
                                            var _pol7 = [];
                                            var _pol8 = [];
                                            for (var _l5 = _j3; _l5 <= _k2; _l5++) {
                                                _pol7.push(_pol6[_l5 % _pol6.length]);
                                            }
                                            for (var _l6 = _k2; _l6 <= _j3 + _pol6.length; _l6++) {
                                                _pol8.push(_pol6[_l6 % _pol6.length]);
                                            }
                                            poligons[i] = _pol7;
                                            poligons.push(_pol8);
                                            continue checkAllPoligons;
                                        }
                                    }
                                }
                            }
                        }
                        for (var _i9 = poligons.length - 1; _i9 >= 0; _i9--) {
                            var _pol9 = poligons[_i9];
                            while (_pol9.length > 3) {
                                poligons.push([_pol9[0], _pol9[1], _pol9[2]]);
                                _pol9.splice(1, 1);
                            }
                        }
                        var mSum = 0;
                        poligons.forEach(function (pol) {
                            var a = Math.sqrt(Math.pow(pol[0].x - pol[1].x, 2) + Math.pow(pol[0].y - pol[1].y, 2));
                            var b = Math.sqrt(Math.pow(pol[1].x - pol[2].x, 2) + Math.pow(pol[1].y - pol[2].y, 2));
                            var c = Math.sqrt(Math.pow(pol[2].x - pol[0].x, 2) + Math.pow(pol[2].y - pol[0].y, 2));
                            var s = (a + b + c) / 2;
                            var m = Math.sqrt(s * (s - a) * (s - b) * (s - c));
                            mSum += m;
                        });
                        var overPressure = softBall.pressure * (softBall.r * softBall.r * Math.PI / mSum) - softBall.pressure;
                        softBall.sides.forEach(function (side) {
                            var force = vec2_1.default.sub(side.objects[0].pos, side.objects[1].pos);
                            force.mult(overPressure);
                            force.rotate(Math.PI / 2);
                            force.mult(t);
                            side.objects[0].vel.add(vec2_1.default.div(force, side.objects[0].m));
                            side.objects[1].vel.add(vec2_1.default.div(force, side.objects[1].m));
                        });
                    }
                }]);

                return SoftBall;
            }();

            exports.default = SoftBall;
        }, { "./ball": 1, "./linesegment": 3, "./stick": 7, "./vec2": 8 }], 6: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var vec2_1 = require("./vec2");
            /**
             * Class representing a string
             * They act like springs in real life
             * You can attach other objects to the ends of them
             * They do not collide with other object neither with each other
             */

            var Spring = function () {
                /**
                 * Creates a spring
                 * @param {number} length The unstreched length of the spring
                 * @param {number} springConstant Spring constant
                 */
                function Spring(length, springConstant) {
                    _classCallCheck(this, Spring);

                    this.length = length;
                    this.springConstant = springConstant;
                    this.pinned = false;
                    this.objects = [];
                    this.rotationLocked = false;
                }
                /**
                 * Pins one side of the the spring to a given coordinate in space
                 * @param {number} x x coordinate
                 * @param {number} y y coordinate
                 */


                _createClass(Spring, [{
                    key: "pinHere",
                    value: function pinHere(x, y) {
                        this.pinned = {
                            x: x,
                            y: y
                        };
                    }
                    /**
                     * Removes the pinned tag from the spring
                     * You can now attach it to another object
                     */

                }, {
                    key: "unpin",
                    value: function unpin() {
                        this.pinned = false;
                    }
                    /**
                     * Attaches one end of the spring to an object (eg. Ball)
                     * @param {any} object The object that the spring is getting attached to
                     */

                }, {
                    key: "attachObject",
                    value: function attachObject(object) {
                        var ob = this.objects;
                        ob.push(object);
                        if (ob.length === 2) {
                            this.pinned = false;
                        }
                        if (ob.length >= 3) {
                            ob = [ob[ob.length - 2], ob[ob.length - 1]];
                        }
                    }
                    /**
                     * Locks the objects attached to the ends of the spring
                     * to not rotate around the attach point
                     */

                }, {
                    key: "lockRotation",
                    value: function lockRotation() {
                        this.rotationLocked = true;
                    }
                    /**
                     * Releases the objects attached to the ends of the spring
                     * to rotate around the attach point
                     */

                }, {
                    key: "unlockRotation",
                    value: function unlockRotation() {
                        this.rotationLocked = false;
                    }
                    /**
                     * Updates the spring bay the elapsed time
                     * @param {number} t Elapsed time
                     */

                }, {
                    key: "update",
                    value: function update(t) {
                        var p1 = void 0;
                        var p2 = void 0;
                        if (this.pinned && this.objects[0]) {
                            p2 = this.pinned;
                            p1 = this.objects[0];
                            var dist = new vec2_1.default(p2.x - p1.pos.x, p2.y - p1.pos.y);
                            var dl = dist.length - this.length;
                            dist.setMag(1);
                            dist.mult(dl * this.springConstant * t / p1.m);
                            p1.vel.x += dist.x;
                            p1.vel.y += dist.y;
                            var v = p1.vel;
                            v.rotate(-dist.heading);
                            if (this.rotationLocked) {
                                var s = new vec2_1.default(p2.x, p2.y);
                                var r2 = vec2_1.default.sub(p1.pos, s);
                                var am = r2.length * r2.length * p1.m + p1.am;
                                var ang = (p1.am * p1.ang - r2.length * p1.m * v.y) / am;
                                v.y = -ang * r2.length;
                                p1.ang = ang;
                            }
                            v.rotate(dist.heading);
                        } else if (this.objects[0] && this.objects[1]) {
                            p1 = this.objects[0];
                            p2 = this.objects[1];
                            var _dist = vec2_1.default.sub(p1.pos, p2.pos);
                            var _dl = _dist.length - this.length;
                            _dist.setMag(1);
                            _dist.mult(_dl * this.springConstant * t);
                            p2.vel.add(vec2_1.default.div(_dist, p2.m));
                            p1.vel.add(vec2_1.default.div(_dist, -p1.m));
                            _dist = vec2_1.default.sub(p1.pos, p2.pos);
                            var v1 = p1.vel;
                            var v2 = p2.vel;
                            v1.rotate(-_dist.heading);
                            v2.rotate(-_dist.heading);
                            if (this.rotationLocked) {
                                var _s = new vec2_1.default(p1.pos.x * p1.m + p2.pos.x * p2.m, p1.pos.y * p1.m + p2.pos.y * p2.m);
                                _s.div(p1.m + p2.m);
                                var r1 = vec2_1.default.sub(p1.pos, _s);
                                var _r = vec2_1.default.sub(p2.pos, _s);
                                var _am = r1.length * r1.length * p1.m + p1.am + _r.length * _r.length * p2.m + p2.am;
                                var sv = (v1.y - v2.y) * _r.length / (r1.length + _r.length) + v2.y;
                                var _ang = (p1.am * p1.ang + p2.am * p2.ang - r1.length * p1.m * (v1.y - sv) + _r.length * p2.m * (v2.y - sv)) / _am;
                                v1.y = -_ang * r1.length + sv;
                                v2.y = +_ang * _r.length + sv;
                                p1.ang = _ang;
                                p2.ang = _ang;
                            }
                            v1.rotate(_dist.heading);
                            v2.rotate(_dist.heading);
                        }
                    }
                }]);

                return Spring;
            }();

            exports.default = Spring;
        }, { "./vec2": 8 }], 7: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var vec2_1 = require("./vec2");
            var spring_1 = require("./spring");
            /**
             * Stick class for the physics engine
             * Sticks are not strechable objects that do not collide
             * with other objects but they can hold other objects on their ends
             */

            var Stick = function (_spring_1$default) {
                _inherits(Stick, _spring_1$default);

                /**
                 * Creates a stick
                 * @param {nuber} length The length of the stick
                 */
                function Stick(length) {
                    _classCallCheck(this, Stick);

                    var _this5 = _possibleConstructorReturn(this, (Stick.__proto__ || Object.getPrototypeOf(Stick)).call(this, length, 0));

                    _this5.springConstant = 0;
                    return _this5;
                }
                /**
                 * Updates the stick trough an elapsed time
                 * @param {number} t Elapsed time
                 */


                _createClass(Stick, [{
                    key: "update",
                    value: function update(t) {
                        var p1 = void 0;
                        var p2 = void 0;
                        if (this.pinned && this.objects[0]) {
                            p2 = this.pinned;
                            p1 = this.objects[0];
                            var dist = new vec2_1.default(p2.x - p1.pos.x, p2.y - p1.pos.y);
                            dist.setMag(1);
                            dist.mult(-this.length);
                            p1.move(-p1.pos.x + p2.x + dist.x, -p1.pos.y + p2.y + dist.y);
                            var v = p1.vel;
                            v.rotate(-dist.heading);
                            v.x = 0;
                            if (this.rotationLocked) {
                                var s = new vec2_1.default(p2.x, p2.y);
                                var r2 = vec2_1.default.sub(p1.pos, s);
                                var am = r2.length * r2.length * p1.m + p1.am;
                                var ang = (p1.am * p1.ang - r2.length * p1.m * v.y) / am;
                                v.y = -ang * r2.length;
                                p1.ang = ang;
                            }
                            v.rotate(dist.heading);
                        } else if (this.objects[0] && this.objects[1]) {
                            p1 = this.objects[0];
                            p2 = this.objects[1];
                            var _dist2 = vec2_1.default.sub(p1.pos, p2.pos);
                            var dl = this.length - _dist2.length;
                            _dist2.setMag(1);
                            var move1 = vec2_1.default.mult(_dist2, dl * p2.m / (p1.m + p2.m));
                            var move2 = vec2_1.default.mult(_dist2, -dl * p1.m / (p1.m + p2.m));
                            p1.move(move1.x, move1.y);
                            p2.move(move2.x, move2.y);
                            var v1 = p1.vel;
                            var v2 = p2.vel;
                            v1.rotate(-_dist2.heading);
                            v2.rotate(-_dist2.heading);
                            v1.x = v2.x = (p1.m * v1.x + p2.m * v2.x) / (p1.m + p2.m);
                            if (this.rotationLocked) {
                                var _s2 = new vec2_1.default(p1.pos.x * p1.m + p2.pos.x * p2.m, p1.pos.y * p1.m + p2.pos.y * p2.m);
                                _s2.div(p1.m + p2.m);
                                var r1 = vec2_1.default.sub(p1.pos, _s2);
                                var _r2 = vec2_1.default.sub(p2.pos, _s2);
                                var _am2 = r1.length * r1.length * p1.m + p1.am + _r2.length * _r2.length * p2.m + p2.am;
                                var sv = (v1.y - v2.y) * _r2.length / (r1.length + _r2.length) + v2.y;
                                var _ang2 = (p1.am * p1.ang + p2.am * p2.ang - r1.length * p1.m * (v1.y - sv) + _r2.length * p2.m * (v2.y - sv)) / _am2;
                                v1.y = -_ang2 * r1.length + sv;
                                v2.y = +_ang2 * _r2.length + sv;
                                p1.ang = _ang2;
                                p2.ang = _ang2;
                            }
                            v1.rotate(_dist2.heading);
                            v2.rotate(_dist2.heading);
                        }
                    }
                }]);

                return Stick;
            }(spring_1.default);

            exports.default = Stick;
        }, { "./spring": 6, "./vec2": 8 }], 8: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            // every angle is counterclockwise (anticlockwise)
            /** Class representing a 2d vector. */

            var Vec2 = function () {
                /**
                 * Create a vector.
                 * @param {number} x - The x value.
                 * @param {number} y - The y value.
                 */
                function Vec2(x, y) {
                    _classCallCheck(this, Vec2);

                    this.x = x;
                    this.y = y;
                }
                /**
                 * Get a copy of the vector.
                 * @return {Vec2} The copy.
                 */


                _createClass(Vec2, [{
                    key: "add",

                    /**
                     * Adds another vector to the vector.
                     * @param {Vec2} a - The other vector.
                     */
                    value: function add(a) {
                        this.x += a.x;
                        this.y += a.y;
                    }
                    /**
                     * Subtracts another vector from the vector.
                     * @param {Vec2} a - The other vector.
                     */

                }, {
                    key: "sub",
                    value: function sub(a) {
                        this.x -= a.x;
                        this.y -= a.y;
                    }
                    /**
                     * Multiplies the vector by a scalar.
                     * @param {number} x - The scalar.
                     */

                }, {
                    key: "mult",
                    value: function mult(x) {
                        this.x *= x;
                        this.y *= x;
                    }
                    /**
                     * Divides the vector by a scalar.
                     * @param {number} x - The scalar.
                     */

                }, {
                    key: "div",
                    value: function div(x) {
                        this.x /= x;
                        this.y /= x;
                    }
                    /**
                     * Linearry interpolates the vector into the other vector by scalar x.
                     * @param {Vec2} other - The other vector.
                     * @param {number} x - The scalar.
                     */

                }, {
                    key: "lerp",
                    value: function lerp(other, x) {
                        this.x += (other.x - this.x) * x;
                        this.y += (other.y - this.y) * x;
                    }
                    /**
                     * Get the distance between the vector and the other vector.
                     * Vectors are representing points here.
                     * @param {Vec2} other - The other vector.
                     * @return {number} The distance between them.
                     */

                }, {
                    key: "dist",
                    value: function dist(other) {
                        return new Vec2(this.x - other.x, this.y - other.y).length;
                    }
                    /**
                     * Set the length of the vector.
                     * @param {number} l - The new length value.
                     */

                }, {
                    key: "setMag",
                    value: function setMag(l) {
                        if (this.length === 0) return;
                        this.mult(l / this.length);
                    }
                    /**
                     * Rotate the vector anticlockwise.
                     * @param {number} angle - Rotation angle.
                     */

                }, {
                    key: "rotate",
                    value: function rotate(angle) {
                        var h = this.heading;
                        var v = Vec2.fromAngle(angle + h);
                        v.mult(this.length);
                        this.x = v.x;
                        this.y = v.y;
                    }
                    // Static functions:
                    /**
                     * Add two vectors together.
                     * @param {Vec2} a - Vector.
                     * @param {Vec2} b - Other vector.
                     * @return {Vec2} The sum of the vectors.
                     */

                }, {
                    key: "copy",
                    get: function get() {
                        return new Vec2(this.x, this.y);
                    }
                    /**
                     * Get the length of the vector.
                     * @return {number} The length.
                     */

                }, {
                    key: "length",
                    get: function get() {
                        return Math.sqrt(this.x * this.x + this.y * this.y);
                    }
                    /**
                     * Get the length of the vector squared.
                     * @return {number} The length squared.
                     */

                }, {
                    key: "sqlength",
                    get: function get() {
                        return this.x * this.x + this.y * this.y;
                    }
                    /**
                     * Get the heading of the vector compared to (1, 0).
                     * @return {number} The angle between (1, 0)
                     * and the vector in anticlockwise direction.
                     */

                }, {
                    key: "heading",
                    get: function get() {
                        if (this.x === 0 && this.y === 0) return 0;
                        if (this.x === 0) return this.y > 0 ? Math.PI / 2 : 1.5 * Math.PI;
                        if (this.y === 0) return this.x > 0 ? 0 : Math.PI;
                        var v = Vec2.normalized(this);
                        if (this.x > 0 && this.y > 0) return Math.asin(v.y);
                        if (this.x < 0 && this.y > 0) return Math.asin(-v.x) + Math.PI / 2;
                        if (this.x < 0 && this.y < 0) return Math.asin(-v.y) + Math.PI;
                        if (this.x > 0 && this.y < 0) return Math.asin(v.x) + 1.5 * Math.PI;
                        return 0;
                    }
                }], [{
                    key: "add",
                    value: function add(a, b) {
                        return new Vec2(a.x + b.x, a.y + b.y);
                    }
                    /**
                     * Subtracts one vector from another.
                     * @param {Vec2} a - Vector.
                     * @param {Vec2} b - Other vector.
                     * @return {Vec2} The subtraction of the vectors.
                     */

                }, {
                    key: "sub",
                    value: function sub(a, b) {
                        return new Vec2(a.x - b.x, a.y - b.y);
                    }
                    /**
                     * Multiply the vector by a scalar.
                     * @param {Vec2} v - Vector.
                     * @param {number} x - Scalar.
                     * @return {Vec2} The multiplied vector.
                     */

                }, {
                    key: "mult",
                    value: function mult(v, x) {
                        return new Vec2(v.x * x, v.y * x);
                    }
                    /**
                     * Divide the vector by a scalar.
                     * @param {Vec2} v - Vector.
                     * @param {number} x - Scalar.
                     * @return {Vec2} The divided vector.
                     */

                }, {
                    key: "div",
                    value: function div(v, x) {
                        return new Vec2(v.x / x, v.y / x);
                    }
                    /**
                     * Create a unit vector from an angle.
                     * @param {number} a - The angle.
                     * @return {Vec2} The created vector.
                     */

                }, {
                    key: "fromAngle",
                    value: function fromAngle(a) {
                        return new Vec2(Math.cos(a), Math.sin(a));
                    }
                    /**
                     * Linearry interpolates a vector into another vector by scalar x.
                     * @param {Vec2} a - A vector.
                     * @param {Vec2} b - Other vector.
                     * @param {number} x - The scalar.
                     * @return {Vec2} The created vector.
                     */

                }, {
                    key: "lerp",
                    value: function lerp(a, b, x) {
                        return Vec2.add(a, Vec2.mult(Vec2.sub(b, a), x));
                    }
                    /**
                     * Get the distance between vectors.
                     * @param {Vec2} a - A vector.
                     * @param {Vec2} b - Other vector
                     * @return {number} The distance between them.
                     */

                }, {
                    key: "dist",
                    value: function dist(a, b) {
                        return Vec2.sub(a, b).length;
                    }
                    /**
                     * Get the dot product of two vectors.
                     * @param {Vec2} a - A vector.
                     * @param {Vec2} b - Other vector
                     * @return {number} The dot product of them.
                     */

                }, {
                    key: "dot",
                    value: function dot(a, b) {
                        return a.x * b.x + a.y * b.y;
                    }
                    /**
                     * Get the cross product of two vectors.
                     * @param {Vec2} a - A vector.
                     * @param {Vec2} b - Other vector
                     * @return {number} The cross product of them.
                     */

                }, {
                    key: "cross",
                    value: function cross(a, b) {
                        return a.x * b.y - a.y * b.x;
                    }
                    /**
                     * Get the angle between two vectors.
                     * @param {Vec2} a - A vector.
                     * @param {Vec2} b - Other vector
                     * @return {number} Angle between them.
                     */

                }, {
                    key: "angle",
                    value: function angle(a, b) {
                        return Math.acos(Vec2.dot(a, b) / Math.sqrt(a.sqlength * b.sqlength));
                    }
                    /**
                     * Get the angle between two vectors but in the anticlockwise direction.
                     * @param {Vec2} a - A vector.
                     * @param {Vec2} b - Other vector
                     * @return {number} Angle between them.
                     */

                }, {
                    key: "angleACW",
                    value: function angleACW(a, b) {
                        var ah = a.heading;
                        var bh = b.heading;
                        var angle = bh - ah;
                        return angle < 0 ? 2 * Math.PI + angle : angle;
                    }
                    /**
                     * Get a vector with the same heading with the input vector
                     * but with length = 1.
                     * @param {Vec2} v - A vector.
                     * @return {Vec2} Vector with length = 0.
                     */

                }, {
                    key: "normalized",
                    value: function normalized(v) {
                        var l = v.length;
                        return l === 0 ? v : new Vec2(v.x / l, v.y / l);
                    }
                }]);

                return Vec2;
            }();

            exports.default = Vec2;
        }, {}], 9: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var vec2_1 = require("./vec2");
            /** Class representing a wall
             * Walls are objects that are immovable  and they are rigid
             * It can be convex or concave
             */

            var Wall = function () {
                /**
                 * Create a wall
                 * @param {Array<Vec2>} points Array of points that make up the wall
                 */
                function Wall(points) {
                    _classCallCheck(this, Wall);

                    this.points = points;
                    var pol = this.points;
                    var sum1 = 0;
                    var sum2 = 0;
                    var angle = vec2_1.default.angleACW(vec2_1.default.sub(pol[1], pol[0]), vec2_1.default.sub(pol[pol.length - 1], pol[0]));
                    sum1 += angle;
                    sum2 += Math.PI * 2 - angle;
                    for (var i = 1; i < pol.length - 1; i++) {
                        angle = vec2_1.default.angleACW(vec2_1.default.sub(pol[(i + 1) % pol.length], pol[i]), vec2_1.default.sub(pol[i - 1], pol[i]));
                        sum1 += angle;
                        sum2 += Math.PI * 2 - angle;
                    }
                    angle = vec2_1.default.angleACW(vec2_1.default.sub(pol[0], pol[pol.length - 1]), vec2_1.default.sub(pol[pol.length - 2], pol[pol.length - 1]));
                    sum1 += angle;
                    sum2 += Math.PI * 2 - angle;
                    if (sum2 > sum1) return;else {
                        var temp = [];
                        for (var _i10 = pol.length - 1; _i10 >= 0; _i10--) {
                            temp.push(pol[_i10]);
                        }this.points = temp;
                    }
                }
                /**
                 * Function for collision detection and behavior between balls and walls
                 * @param {Ball} ball The ball that is checked if it collides with the wall
                 */


                _createClass(Wall, [{
                    key: "collideWithBall",
                    value: function collideWithBall(ball) {
                        var _this6 = this;

                        var heading = void 0;
                        var rel = void 0;
                        this.points.forEach(function (point, idx) {
                            var p = new vec2_1.default(point.x, point.y);
                            p.x -= ball.pos.x;
                            p.y -= ball.pos.y;
                            p.mult(-1);
                            if (p.length <= ball.r) {
                                heading = p.heading;
                                rel = p.length;
                            }
                            p = new vec2_1.default(point.x, point.y);
                            var np = new vec2_1.default(_this6.points[(idx + 1) % _this6.points.length].x, _this6.points[(idx + 1) % _this6.points.length].y);
                            var bp = new vec2_1.default(ball.pos.x, ball.pos.y);
                            var side = new vec2_1.default(np.x - p.x, np.y - p.y);
                            var h = side.heading;
                            p.rotate(-h + Math.PI);
                            np.rotate(-h + Math.PI);
                            bp.rotate(-h + Math.PI);
                            var d = bp.y - (p.y + np.y) / 2;
                            if (d >= -ball.r && d <= ball.r && bp.x >= np.x && bp.x <= p.x) {
                                heading = h - Math.PI / 2;
                                rel = d;
                            }
                        });
                        if (heading === 0 || heading) {
                            var pos = new vec2_1.default(ball.pos.x, ball.pos.y);
                            var vel = new vec2_1.default(ball.vel.x, ball.vel.y);
                            pos.rotate(-heading + Math.PI / 2);
                            vel.rotate(-heading + Math.PI / 2);
                            vel.y *= -ball.k;
                            pos.y += ball.r - rel;
                            var dvy = vel.y * (1 + 1 / ball.k);
                            var dvx = Math.abs(dvy) * ball.fc * Math.sign(vel.x - ball.ang * ball.r) * -1;
                            if (Math.abs(dvx) > Math.abs(vel.x - ball.ang * ball.r)) {
                                dvx = -vel.x + ball.ang * ball.r;
                            }
                            vel.x += dvx - ball.r * ball.r * ball.m * dvx / (ball.am + ball.r * ball.r * ball.m);
                            ball.ang -= ball.r * ball.r * ball.m * dvx / ((ball.am + ball.r * ball.r * ball.m) * ball.r);
                            pos.rotate(heading - Math.PI / 2);
                            vel.rotate(heading - Math.PI / 2);
                            ball.pos.x = pos.x;
                            ball.pos.y = pos.y;
                            ball.vel.x = vel.x;
                            ball.vel.y = vel.y;
                        }
                    }
                }]);

                return Wall;
            }();

            exports.default = Wall;
        }, { "./vec2": 8 }] }, {}, [4])(4);
});
