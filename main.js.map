{
  "version": 3,
  "sources": ["../src/vec2.js", "../src/collision.js", "../src/ball.js", "../src/linesegment.js", "../src/wall.js", "../src/body.js", "../src/spring.js", "../src/stick.js", "../src/softball.js", "../src/stickspringhelpers.js", "../src/physics.js", "../editor/src/startPauseControls.ts", "../editor/src/elementCreator.ts", "../editor/src/modes/ballcreator.ts", "../editor/src/modes/deletemode.ts", "../editor/src/modes/elasticballcreator.ts", "../editor/src/modes/movemode.ts", "../editor/src/modes/rectangle.ts", "../editor/src/modes/rectanglebodycreator.ts", "../editor/src/modes/softsquarecreator.ts", "../editor/src/modes/springcreator.ts", "../editor/src/modes/stickcreator.ts", "../editor/src/modes/walldrawer.ts", "../editor/src/modes/index.ts", "../editor/src/editor.ts", "../editor/src/index.ts"],
  "sourcesContent": ["// every angle is counterclockwise (anticlockwise)\n\n/**\n * An object representation of the Vec2 class for easy conversion to JSON.\n *\n * @typedef {object} Vec2AsObject\n * @property {number} x The x coordinate\n * @property {number} y The y coordinate\n */\n\n/** Class representing a 2d vector. */\nclass Vec2 {\n  /**\n   * Create a vector.\n   *\n   * @param {number} x - The x value.\n   * @param {number} y - The y value.\n   */\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Get a copy of the vector.\n   *\n   * @returns {Vec2} The copy.\n   */\n  get copy() {\n    return new Vec2(this.x, this.y);\n  }\n\n  /**\n   * Get the length of the vector.\n   *\n   * @returns {number} The length.\n   */\n  get length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  /**\n   * Get the length of the vector squared.\n   *\n   * @returns {number} The length squared.\n   */\n  get sqlength() {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  /**\n   * Get the heading of the vector compared to (1, 0).\n   *\n   * @returns {number} The angle between (1, 0)\n   * and the vector in anticlockwise direction.\n   */\n  get heading() {\n    if (this.x === 0 && this.y === 0) return 0;\n    if (this.x === 0) return this.y > 0 ? Math.PI / 2 : 1.5 * Math.PI;\n    if (this.y === 0) return this.x > 0 ? 0 : Math.PI;\n    const v = Vec2.normalized(this);\n    if (this.x > 0 && this.y > 0) return Math.asin(v.y);\n    if (this.x < 0 && this.y > 0) return Math.asin(-v.x) + Math.PI / 2;\n    if (this.x < 0 && this.y < 0) return Math.asin(-v.y) + Math.PI;\n    if (this.x > 0 && this.y < 0) return Math.asin(v.x) + 1.5 * Math.PI;\n    return 0;\n  }\n\n  /**\n   * Adds another vector to the vector.\n   *\n   * @param {Vec2 | Vec2AsObject} a - The other vector.\n   */\n  add(a) {\n    this.x += a.x;\n    this.y += a.y;\n  }\n\n  /**\n   * Subtracts another vector from the vector.\n   *\n   * @param {Vec2 | Vec2AsObject} a - The other vector.\n   */\n  sub(a) {\n    this.x -= a.x;\n    this.y -= a.y;\n  }\n\n  /**\n   * Multiplies the vector by a scalar.\n   *\n   * @param {number} x - The scalar.\n   */\n  mult(x) {\n    this.x *= x;\n    this.y *= x;\n  }\n\n  /**\n   * Divides the vector by a scalar.\n   *\n   * @param {number} x - The scalar.\n   */\n  div(x) {\n    this.x /= x;\n    this.y /= x;\n  }\n\n  /**\n   * Linearry interpolates the vector into the other vector by scalar x.\n   *\n   * @param {Vec2 | Vec2AsObject} other - The other vector.\n   * @param {number} x - The scalar.\n   */\n  lerp(other, x) {\n    this.x += (other.x - this.x) * x;\n    this.y += (other.y - this.y) * x;\n  }\n\n  /**\n   * Get the distance between the vector and the other vector.\n   * Vectors are representing points here.\n   *\n   * @param {Vec2 | Vec2AsObject} other - The other vector.\n   * @returns {number} The distance between them.\n   */\n  dist(other) {\n    return new Vec2(this.x - other.x, this.y - other.y).length;\n  }\n\n  /**\n   * Set the length of the vector.\n   *\n   * @param {number} l - The new length value.\n   */\n  setMag(l) {\n    if (this.length === 0) return;\n    this.mult(l / this.length);\n  }\n\n  /**\n   * Rotate the vector anticlockwise.\n   *\n   * @param {number} angle Rotation angle in radians\n   */\n  rotate(angle) {\n    const h = this.heading;\n    const v = Vec2.fromAngle(angle + h);\n    v.mult(this.length);\n    this.x = v.x;\n    this.y = v.y;\n  }\n\n  /**\n   * Rotates the vector by 90 degrees\n   */\n  rotate90() {\n    const { x } = this;\n    this.x = -this.y;\n    this.y = x;\n  }\n\n  /**\n   * Rotates the vector by 270 degrees\n   */\n  rotate270() {\n    const { x } = this;\n    this.x = this.y;\n    this.y = -x;\n  }\n\n  // Static functions:\n  /**\n   * Add two vectors together.\n   *\n   * @param {Vec2 | Vec2AsObject} a - Vector.\n   * @param {Vec2 | Vec2AsObject} b - Other vector.\n   * @returns {Vec2} The sum of the vectors.\n   */\n  static add(a, b) {\n    return new Vec2(a.x + b.x, a.y + b.y);\n  }\n\n  /**\n   * Subtracts one vector from another.\n   *\n   * @param {Vec2 | Vec2AsObject} a - Vector.\n   * @param {Vec2 | Vec2AsObject} b - Other vector.\n   * @returns {Vec2} The subtraction of the vectors.\n   */\n  static sub(a, b) {\n    return new Vec2(a.x - b.x, a.y - b.y);\n  }\n\n  /**\n   * Multiply the vector by a scalar.\n   *\n   * @param {Vec2 | Vec2AsObject} v - Vector.\n   * @param {number} x - Scalar.\n   * @returns {Vec2} The multiplied vector.\n   */\n  static mult(v, x) {\n    return new Vec2(v.x * x, v.y * x);\n  }\n\n  /**\n   * Divide the vector by a scalar.\n   *\n   * @param {Vec2 | Vec2AsObject} v - Vector.\n   * @param {number} x - Scalar.\n   * @returns {Vec2} The divided vector.\n   */\n  static div(v, x) {\n    return new Vec2(v.x / x, v.y / x);\n  }\n\n  /**\n   * Create a unit vector from an angle.\n   *\n   * @param {number} a - The angle.\n   * @returns {Vec2} The created vector.\n   */\n  static fromAngle(a) {\n    return new Vec2(Math.cos(a), Math.sin(a));\n  }\n\n  /**\n   * Linearry interpolates a vector into another vector by scalar x.\n   *\n   * @param {Vec2 | Vec2AsObject} a - A vector.\n   * @param {Vec2 | Vec2AsObject} b - Other vector.\n   * @param {number} x - The scalar.\n   * @returns {Vec2} The created vector.\n   */\n  static lerp(a, b, x) {\n    return Vec2.add(a, Vec2.mult(Vec2.sub(b, a), x));\n  }\n\n  /**\n   * Get the distance between vectors.\n   *\n   * @param {Vec2 | Vec2AsObject} a - A vector.\n   * @param {Vec2 | Vec2AsObject} b - Other vector\n   * @returns {number} The distance between them.\n   */\n  static dist(a, b) {\n    return Vec2.sub(a, b).length;\n  }\n\n  /**\n   * Get the dot product of two vectors.\n   *\n   * @param {Vec2 | Vec2AsObject} a - A vector.\n   * @param {Vec2 | Vec2AsObject} b - Other vector\n   * @returns {number} The dot product of them.\n   */\n  static dot(a, b) {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  /**\n   * Get the cross product of two vectors.\n   *\n   * @param {Vec2 | Vec2AsObject} a - A vector.\n   * @param {Vec2 | Vec2AsObject} b - Other vector\n   * @returns {number} The cross product of them.\n   */\n  static cross(a, b) {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  /**\n   * Returns the cross product of a scalar and a 2D vector\n   * when the scalar goes first\n   *\n   * @param {number} s The scalar\n   * @param {Vec2 | Vec2AsObject} v The vector\n   * @returns {Vec2} The cross product\n   */\n  static crossScalarFirst(s, v) {\n    return new Vec2(-v.y * s, v.x * s);\n  }\n\n  /**\n   * Returns the cross product of a scalar and a 2D vector\n   * when the scalar goes second\n   *\n   * @param {Vec2 | Vec2AsObject} v The vector\n   * @param {number} s The scalar\n   * @returns {Vec2} The cross product\n   */\n  static crossScalarSecond(v, s) {\n    return new Vec2(v.y * s, -v.x * s);\n  }\n\n  /**\n   * Get the angle between two vectors.\n   *\n   * @param {Vec2} a - A vector.\n   * @param {Vec2} b - Other vector\n   * @returns {number} Angle between them.\n   */\n  static angle(a, b) {\n    return Math.acos(\n      Math.min(\n        Math.max(\n          Vec2.dot(a, b) / Math.sqrt(a.sqlength * b.sqlength), 1,\n        ), -1,\n      ),\n    );\n  }\n\n  /**\n   * Get the angle between two vectors but in the anticlockwise direction.\n   *\n   * @param {Vec2} a - A vector.\n   * @param {Vec2} b - Other vector\n   * @returns {number} Angle between them.\n   */\n  static angleACW(a, b) {\n    const ah = a.heading;\n    const bh = b.heading;\n    const angle = bh - ah;\n    return angle < 0 ? 2 * Math.PI + angle : angle;\n  }\n\n  /**\n   * Get a vector with the same heading with the input vector\n   * but with length = 1.\n   *\n   * @param {Vec2} v A vector.\n   * @returns {Vec2} Vector with length = 1.\n   */\n  static normalized(v) {\n    const l = v.length;\n    return l === 0 ? v : new Vec2(v.x / l, v.y / l);\n  }\n\n  /**\n   * @returns {Vec2AsObject} The vector represented in a JS object,\n   * ready to be converted into JSON.\n   */\n  toJSObject() {\n    return { x: this.x, y: this.y };\n  }\n\n  /**\n   * Creates a Vec2 class from the given object.\n   *\n   * @param {Vec2AsObject} obj The object to create the class from\n   * @returns {Vec2} The Vec2 object\n   */\n  static fromObject(obj) {\n    return new Vec2(obj.x, obj.y);\n  }\n}\n\nexport default Vec2;\n", "import Vec2 from './vec2';\n\n/**\n * Calculates the collsion response when any two physical objects\n * collide with a given collision point and collision normal.\n *\n * @param {import('./physics').PhysicalObject} object1 The first object\n * @param {import('./physics').PhysicalObject} object2 The second object\n * @param {Vec2} contactPoint The collision point\n * @param {Vec2} normal The normal of the colliding surfaces\n */\nexport function collisionResponse(object1, object2, contactPoint, normal) {\n  const n = normal;\n  const cp = contactPoint;\n  const b1 = object1;\n  const b2 = object2;\n\n  const v1 = b1.vel;\n  const v2 = b2.vel;\n  const ang1 = b1.ang;\n  const ang2 = b2.ang;\n  const r1 = Vec2.sub(cp, b1.pos);\n  const r2 = Vec2.sub(cp, b2.pos);\n  const am1 = b1.am;\n  const am2 = b2.am;\n  const m1 = b1.m;\n  const m2 = b2.m;\n  const k = (b1.k + b2.k) / 2;\n  const fc = (b1.fc + b2.fc) / 2;\n\n  // Effective velocities in the collision point\n  const v1InCP = b1.velInPlace(cp);\n  const v2InCP = b2.velInPlace(cp);\n  // Relative velocity in collision point\n  const vRelInCP = Vec2.sub(v2InCP, v1InCP);\n\n  // Calculate impulse\n  let impulse = (1 / m1) + (1 / m2);\n  impulse += Vec2.dot(\n    Vec2.crossScalarFirst(Vec2.cross(r1, n) / am1, r1), n,\n  );\n  impulse += Vec2.dot(\n    Vec2.crossScalarFirst(Vec2.cross(r2, n) / am2, r2), n,\n  );\n  impulse = -((1 + k) * Vec2.dot(vRelInCP, n)) / impulse;\n\n  // Calculate post-collision velocities\n  let u1 = Vec2.sub(v1, Vec2.mult(n, impulse / m1));\n  let u2 = Vec2.add(v2, Vec2.mult(n, impulse / m2));\n\n  // Calculate post-collision angular velocities\n  let pAng1 = ang1 - (impulse * Vec2.cross(r1, n)) / am1;\n  let pAng2 = ang2 + (impulse * Vec2.cross(r2, n)) / am2;\n\n  /**\n   * Now calculate the friction reaction\n   */\n  // Tangential direction\n  const t = vRelInCP.copy;\n  t.sub(Vec2.mult(n, Vec2.dot(vRelInCP, n)));\n  t.setMag(1);\n\n  // Calculate max impulse\n  let maxImpulse = (1 / m1) + (1 / m2);\n  maxImpulse += Vec2.dot(\n    Vec2.crossScalarFirst(Vec2.cross(r1, t) / am1, r1), t,\n  );\n  maxImpulse += Vec2.dot(\n    Vec2.crossScalarFirst(Vec2.cross(r2, t) / am2, r2), t,\n  );\n  maxImpulse = -Vec2.dot(vRelInCP, t) / maxImpulse;\n\n  // Friction impulse\n  let frictionImpulse = impulse * fc;\n  if (frictionImpulse > maxImpulse) frictionImpulse = maxImpulse;\n\n  // Calculate post-friction velocities\n  u1 = Vec2.sub(u1, Vec2.mult(t, frictionImpulse / m1));\n  u2 = Vec2.add(u2, Vec2.mult(t, frictionImpulse / m2));\n\n  // Calculate post-friction angular velocities\n  pAng1 -= (frictionImpulse * Vec2.cross(r1, t)) / am1;\n  pAng2 += (frictionImpulse * Vec2.cross(r2, t)) / am2;\n\n  // Store the new values in the objects\n  b1.vel = u1;\n  b2.vel = u2;\n  b1.ang = pAng1;\n  b2.ang = pAng2;\n}\n\n/**\n * Calculates the collsion response when a physical object\n * collides with an immovable object, like a {@link Wall} or {@link FixedBall}.\n *\n * @param {import('./physics').PhysicalObject} object The phyisical object\n * @param {Vec2 | import('./vec2').Vec2AsObject} contactPoint The collision point\n * @param {Vec2} normal The surface normal\n */\nexport function collisionResponseWithWall(object, contactPoint, normal) {\n  const cp = contactPoint;\n  const n = normal;\n  const b = object;\n  const r = Vec2.sub(cp, b.pos);\n  const { am, m } = b;\n\n  // Relative velocity in collision point\n  const vRelInCP = Vec2.mult(b.velInPlace(cp), -1);\n\n  // Calculate impulse\n  let impulse = (1 / m);\n  impulse += Vec2.dot(\n    Vec2.crossScalarFirst(Vec2.cross(r, n) / am, r), n,\n  );\n  impulse = -((1 + b.k) * Vec2.dot(vRelInCP, n)) / impulse;\n\n  // Calculate post-collision velocity\n  let u = Vec2.sub(b.vel, Vec2.mult(n, impulse / m));\n\n  // Calculate post-collision angular velocity\n  let pAng = b.ang - (impulse * Vec2.cross(r, n)) / am;\n\n  /**\n   * Now calculate the friction reaction\n   */\n  // Tangential direction\n  const t = vRelInCP.copy;\n  t.sub(Vec2.mult(n, Vec2.dot(vRelInCP, n)));\n  t.setMag(1);\n\n  // Calculate max impulse\n  let maxImpulse = (1 / m);\n  maxImpulse += Vec2.dot(\n    Vec2.crossScalarFirst(Vec2.cross(r, t) / am, r), t,\n  );\n  maxImpulse = -Vec2.dot(vRelInCP, t) / maxImpulse;\n\n  // Friction impulse\n  let frictionImpulse = impulse * b.fc;\n  if (frictionImpulse > maxImpulse) frictionImpulse = maxImpulse;\n\n  // Calculate post-friction velocity\n  u = Vec2.sub(u, Vec2.mult(t, frictionImpulse / m));\n\n  // Calculate post-friction angular velocity\n  pAng -= (frictionImpulse * Vec2.cross(r, t)) / am;\n\n  // Store the new values in the body\n  b.vel = u;\n  b.ang = pAng;\n}\n", "import { collisionResponse } from './collision';\nimport Vec2 from './vec2';\n\n/**\n * An object representation of the Ball class for easy conversion to JSON.\n *\n * @typedef {object} BallAsObject\n * @property {import('./vec2').Vec2AsObject} pos The position\n * @property {import('./vec2').Vec2AsObject} lastPos The last position\n * @property {number} r The radius of the ball\n * @property {number} fc The coefficient of friction\n * @property {number} amc Coefficient for the angular mass\n * @property {number} rotation The rotation of the ball\n * @property {number} ang The angular velocity\n * @property {number} k The coefficient of restitution (bounciness)\n * @property {import('./vec2').Vec2AsObject} vel The velocity\n * @property {string} id The ID of the ball\n * @property {string | number | undefined} layer The collision layer of the ball\n */\n\n/**\n * A class representing a ball\n * A ball is an object in the physics engine that\n * has a shape of a circle and it is affected by gravity.\n */\nclass Ball {\n  /**\n   * Create a ball.\n   * The mass of the ball is calculated from its radius.\n   *\n   * @param {Vec2} pos The position of the center of the circle\n   * @param {Vec2} vel The velocity of the circle\n   * @param {number} r The radius of the circe\n   * @param {number} k Coefficient of restitution\n   * @param {number} ang The angular velocity of the ball (optional)\n   * @param {number} fc The friction coefficient (optional, defaults to 0.4)\n   */\n  constructor(pos, vel, r, k, ang, fc) {\n    this.pos = pos.copy;\n    this.lastPos = this.pos.copy;\n    this.r = r;\n    this.fc = 0.4;\n    this.amc = 2 / 5;\n    this.density = 1;\n\n    this.rotation = 0;\n\n    if (ang) this.ang = ang;\n    else this.ang = 0;\n\n    if (fc || fc === 0) this.fc = fc;\n\n    if (k) this.k = k;\n    else this.k = 0.8;\n\n    if (vel !== undefined) this.vel = vel.copy;\n    else this.vel = new Vec2(0, 0);\n\n    this.id = `_${Math.random()\n      .toString(36)\n      .substr(2, 9)}`;\n    /** @type {string | number | undefined} */\n    this.layer = undefined;\n  }\n\n  /**\n   * Get the mass of the ball\n   *\n   * @returns {number} The mass\n   */\n  get m() {\n    return this.density * this.r * this.r * Math.PI;\n  }\n\n  /**\n   * Get the moment of inertia of the ball\n   *\n   * @returns {number} The moment of inertia\n   */\n  get am() {\n    return this.amc * this.r * this.r * this.m;\n  }\n\n  /**\n   * Gives the angular mass of the ball measured in a given point\n   *\n   * @param {Vec2} point The point to measure the angular mass in\n   * @returns {number} The adjusted angular mass\n   */\n  getAmInPoint(point) {\n    let ret = this.am;\n\n    ret += Vec2.sub(this.pos, point).sqlength * this.m;\n\n    return ret;\n  }\n\n  /**\n   * Get a copy of the ball that is not a reference to it\n   *\n   * @returns {Ball} The copy of the ball\n   */\n  get copy() {\n    const ret = new Ball(\n      this.pos.copy,\n      this.vel.copy,\n      this.r,\n      this.k,\n      this.ang,\n      this.fc,\n    );\n    ret.lastPos = this.lastPos.copy;\n    ret.rotation = this.rotation;\n    return ret;\n  }\n\n  /**\n   * Moves the ball by the given coordinates\n   *\n   * @param {number} x x coordinate\n   * @param {number} y y coordinate\n   */\n  move(x, y) {\n    this.pos.x += x;\n    this.pos.y += y;\n  }\n\n  /**\n   * Rotates the ball with the given angle anticlockwise\n   *\n   * @param {number} angle The angle to rotate the ball in radians\n   */\n  rotate(angle) {\n    this.rotation += angle;\n  }\n\n  /**\n   * Checks if two balls are colliding or not\n   *\n   * @param {Ball} ball the other ball\n   * @returns {boolean} True if they colidre\n   */\n  collided(ball) {\n    if (this.pos.dist(ball.pos) < this.r + ball.r) return true;\n    return false;\n  }\n\n  /**\n   * Static function for collision between two balls\n   *\n   * @param {Ball} ball1 First ball\n   * @param {Ball} ball2 Second ball\n   */\n  static collide(ball1, ball2) {\n    if (!ball1.collided(ball2)) return;\n\n    // Completely necessary quantities\n    const dist = Vec2.dist(ball1.pos, ball2.pos);\n    const m1 = ball1.m;\n    const m2 = ball2.m;\n\n    // Separate the balls\n    const cp1 = ball1.pos.copy;\n    const cp2 = ball2.pos.copy;\n    const b1 = ball1;\n    const b2 = ball2;\n    const too = ball1.r + ball2.r - dist;\n    const d = Vec2.sub(ball1.pos, ball2.pos);\n    d.setMag(1);\n    d.mult((too * m2) / (m1 + m2));\n    cp1.add(d);\n    d.setMag(1);\n    d.mult((-too * m1) / (m1 + m2));\n    cp2.add(d);\n    b1.pos = cp1;\n    b2.pos = cp2;\n\n    // Stop if they move in opposite directions\n    if (Vec2.dot(d, Vec2.sub(ball1.vel, ball2.vel)) < 0) return;\n    d.setMag(1);\n    // Collision point\n    const cp = Vec2.add(ball1.pos, Vec2.mult(d, ball1.r));\n    collisionResponse(ball1, ball2, cp, d);\n  }\n\n  /**\n   * Returns true if the point is inside the ball\n   *\n   * @param {Vec2} p The point\n   * @returns {boolean} The boolean value\n   */\n  containsPoint(p) {\n    return Vec2.dist(this.pos, p) <= this.r;\n  }\n\n  /**\n   * Calculates the effective velocity of the ball in a\n   * given point from it's velocity and angular velocity\n   *\n   * @param {Vec2 | import('./vec2').Vec2AsObject} point The point to be taken a look at\n   * @returns {Vec2} The velocity of the Ball in the given point\n   */\n  velInPlace(point) {\n    const vp = Vec2.sub(point, this.pos);\n    vp.rotate(Math.PI / 2);\n    vp.mult(this.ang);\n    vp.add(this.vel);\n    return vp;\n  }\n\n  /**\n   * Calculates the effective mass of the ball in\n   * a given point when pulled/pushed in a given direction\n   * by a hypothetical force\n   *\n   * @param {Vec2} point The given point\n   * @param {Vec2} direction The direction of the force\n   * @returns {number} The effective mass of the ball in the given\n   * point when acting on it in the direction\n   */\n  effectiveMass(point, direction) {\n    const r = Vec2.sub(point, this.pos);// Vector to the collision point\n    if (r.length === 0) return this.m;\n    const angle = Vec2.angle(direction, r);\n    const rotationalMass = ((Math.sin(angle) ** 2) * (r.length ** 2)) / this.am;\n    return 1 / (rotationalMass + (1 / this.m));\n  }\n\n  /**\n   * Realistically applies a change of velocity (momentum)\n   * on the ball\n   *\n   * @param {Vec2} dvel The change in velocity\n   * @param {Vec2} point The point of pushing\n   */\n  applyDeltaVelInPoint(dvel, point) {\n    const r = Vec2.sub(point, this.pos);\n    if (r.length === 0) {\n      this.vel.add(dvel);\n      return;\n    }\n    const angle = Vec2.angle(r, dvel);\n    // Change vel in line with the center of mass\n    const deltaVlined = Vec2.mult(r, Vec2.dot(dvel, r) / (r.length ** 2));\n    this.vel.add(deltaVlined);\n\n    // Change it perpendicular to the line\n    const d = r.copy;\n    d.rotate(Math.PI / 2);\n    d.setMag(1);\n    const rotateDirection = Math.sign(Vec2.dot(dvel, d));\n    const dvelAng = dvel.length * Math.cos(angle);\n    const mEff = 1 / ((1 / this.m) + ((r.length ** 2) / this.am));\n    const dvm = (dvelAng * mEff) / this.m;\n    this.vel.add(Vec2.mult(d, dvm * rotateDirection));\n\n    const dAng = (rotateDirection * dvelAng * mEff * r.length) / this.am;\n    this.ang -= dAng;\n  }\n\n  /**\n   * @returns {BallAsObject} The ball represented in a JS object\n   * Ready to be converted into JSON\n   */\n  toJSObject() {\n    const ret = {};\n\n    ret.pos = this.pos.toJSObject();\n    ret.lastPos = this.lastPos.toJSObject();\n    ret.r = this.r;\n    ret.fc = this.fc;\n    ret.amc = this.amc;\n    ret.rotation = this.rotation;\n    ret.ang = this.ang;\n    ret.fc = this.fc;\n    ret.k = this.k;\n    ret.vel = this.vel.toJSObject();\n    ret.id = this.id;\n    if (typeof this.layer !== 'undefined') {\n      ret.layer = this.layer;\n    }\n\n    return ret;\n  }\n\n  /**\n   * Creates a Ball class from the given object\n   *\n   * @param {BallAsObject} obj The object to create the class from\n   * @returns {Ball} The Ball object\n   */\n  static fromObject(obj) {\n    const ret = new Ball(\n      Vec2.fromObject(obj.pos),\n      Vec2.fromObject(obj.vel),\n      obj.r,\n      obj.k,\n      obj.ang,\n      obj.fc,\n    );\n\n    ret.lastPos = Vec2.fromObject(obj.lastPos);\n    ret.amc = obj.amc;\n    ret.rotation = obj.rotation;\n    ret.vel = Vec2.fromObject(obj.vel);\n    ret.id = obj.id;\n    if (typeof obj.layer !== 'undefined') {\n      ret.layer = obj.layer;\n    }\n\n    return ret;\n  }\n}\n\nexport default Ball;\n", "import Vec2 from './vec2';\n\n/**\n * Class representing a segment of a line\n */\nclass LineSegment {\n  /**\n   * Create a segment\n   *\n   * @param {Vec2|import('./vec2').Vec2AsObject} a_ Starting point\n   * @param {Vec2|import('./vec2').Vec2AsObject} b_ Ending point\n   */\n  constructor(a_, b_) {\n    this.a = a_;\n    this.b = b_;\n  }\n\n  /**\n   * Get the length of the segment\n   *\n   * @returns {number} The length\n   */\n  get length() {\n    return Vec2.dist(this.a, this.b);\n  }\n\n  /**\n   * Get the distance between a point and the line segment\n   *\n   * @param {Vec2|import('./vec2').Vec2AsObject} p The point as a vector\n   * @returns {number} The distance\n   */\n  distFromPoint(p) {\n    const e = Vec2.sub(this.a, this.b);\n    const A = Vec2.sub(p, this.b);\n    const B = Vec2.sub(p, this.a);\n    const a = A.length;\n    const b = B.length;\n    const c = e.length;\n    if (c === 0) return a;\n    const gamma = Vec2.angle(A, B);\n    const betha = Vec2.angle(A, e);\n    const alpha = Math.PI - gamma - betha;\n    const area = (Math.sin(alpha) * b * c) / 2;\n    const m = (2 * area) / c;\n    if (alpha > Math.PI / 2) return b;\n    if (betha > Math.PI / 2) return a;\n    return m;\n  }\n\n  /**\n   * Get if they intersect or not.\n   * If they intersect it returns the intersection point.\n   * If they do not it returns false.\n   *\n   * @param {LineSegment} segment1 A segment\n   * @param {LineSegment} segment2 Other segment\n   * @returns {Vec2 | boolean} Intersetion point\n   */\n  static intersect(segment1, segment2) {\n    const v1 = Vec2.sub(segment1.b, segment1.a);\n    const a1 = v1.y / v1.x;\n    const c1 = segment1.b.y - segment1.b.x * a1;\n\n    const v2 = Vec2.sub(segment2.b, segment2.a);\n    const a2 = v2.y / v2.x;\n    const c2 = segment2.b.y - segment2.b.x * a2;\n\n    if (v1.x === 0 && v2.x !== 0) {\n      if (\n        (segment1.a.x >= segment2.a.x && segment1.a.x <= segment2.b.x)\n        || (segment1.a.x <= segment2.a.x && segment1.a.x >= segment2.b.x)\n      ) {\n        const h = a2 * segment1.a.x + c2;\n        if (\n          (h > segment1.a.y && h < segment1.b.y)\n          || (h < segment1.a.y && h > segment1.b.y)\n        ) {\n          return new Vec2(segment1.a.x, h);\n        }\n      }\n      return false;\n    }\n    if (v2.x === 0 && v1.x !== 0) {\n      if (\n        (segment2.a.x >= segment1.a.x && segment2.a.x <= segment1.b.x)\n        || (segment2.a.x <= segment1.a.x && segment2.a.x >= segment1.b.x)\n      ) {\n        const h = a1 * segment2.a.x + c1;\n        if (\n          (h > segment2.a.y && h < segment2.b.y)\n          || (h < segment2.a.y && h > segment2.b.y)\n        ) {\n          return new Vec2(segment2.a.x, h);\n        }\n      }\n      return false;\n    }\n    if (v1.x === 0 && v2.x === 0) {\n      if (segment1.a.x === segment2.a.x) {\n        let interval1;\n        if (segment1.a.y < segment1.b.y) {\n          interval1 = [segment1.a.y, segment1.b.y];\n        } else {\n          interval1 = [segment1.b.y, segment1.a.y];\n        }\n        let interval2;\n        if (segment2.a.y < segment2.b.y) {\n          interval2 = [segment2.a.y, segment2.b.y];\n        } else {\n          interval2 = [segment2.b.y, segment2.a.y];\n        }\n        const interval = [\n          interval1[0] > interval2[0] ? interval1[0] : interval2[0],\n          interval1[1] < interval2[1] ? interval1[1] : interval2[1],\n        ];\n        if (interval[0] <= interval[1]) {\n          return new Vec2(segment1.a.x, (interval[0] + interval[1]) / 2);\n        }\n      }\n      return false;\n    }\n\n    let interval1;\n    if (segment1.a.x < segment1.b.x) {\n      interval1 = [segment1.a.x, segment1.b.x];\n    } else {\n      interval1 = [segment1.b.x, segment1.a.x];\n    }\n    let interval2;\n    if (segment2.a.x < segment2.b.x) {\n      interval2 = [segment2.a.x, segment2.b.x];\n    } else {\n      interval2 = [segment2.b.x, segment2.a.x];\n    }\n    const interval = [\n      interval1[0] > interval2[0] ? interval1[0] : interval2[0],\n      interval1[1] < interval2[1] ? interval1[1] : interval2[1],\n    ];\n    // If they are parralel the only time they intersect is when c1 == c2.\n    if (a1 === a2 && c1 === c2 && interval[0] <= interval[1]) {\n      return new Vec2(\n        (interval[0] + interval[1]) / 2,\n        ((interval[0] + interval[1]) / 2) * a1 + c1,\n      );\n    }\n    const x = (c2 - c1) / (a1 - a2);\n    if (x >= interval[0] && x <= interval[1]) {\n      return new Vec2(x, x * a1 + c1);\n    } return false;\n  }\n}\n\nexport default LineSegment;\n", "import Vec2 from './vec2';\nimport LineSegment from './linesegment';\nimport Ball from './ball';\nimport { collisionResponseWithWall } from './collision';\n\n/**\n * An object representation of the Wall class for easy conversion to JSON.\n *\n * @typedef {object} WallAsObject\n * @property {import('./vec2').Vec2AsObject[]} points Object prepresentation\n * of the points of the wall\n */\n\n/**\n * Class representing a wall.\n * Walls are objects that are immovable and they are rigid.\n * It can be convex or concave.\n */\nclass Wall {\n  /**\n   * Create a wall\n   *\n   * @param {Vec2[]} _points Array of points that make up the wall\n   */\n  constructor(_points) {\n    this.points = _points;\n    const pol = this.points;\n    let sum1 = 0;\n    let sum2 = 0;\n    let angle = Vec2.angleACW(\n      Vec2.sub(pol[1], pol[0]),\n      Vec2.sub(pol[pol.length - 1], pol[0]),\n    );\n    if (this.points.length > 0) {\n      /** @type {Vec2} The \"center\" of the wall */\n      [this.center] = [this.points[0]];\n    } else {\n      this.center = new Vec2(0, 0);\n    }\n    this.boundRadius = 1;\n    this.calculateCenterAndRadius();\n\n    sum1 += angle;\n    sum2 += Math.PI * 2 - angle;\n    for (let i = 1; i < pol.length - 1; i += 1) {\n      angle = Vec2.angleACW(\n        Vec2.sub(pol[(i + 1) % pol.length], pol[i]),\n        Vec2.sub(pol[i - 1], pol[i]),\n      );\n      sum1 += angle;\n      sum2 += Math.PI * 2 - angle;\n    }\n    angle = Vec2.angleACW(\n      Vec2.sub(pol[0], pol[pol.length - 1]),\n      Vec2.sub(pol[pol.length - 2], pol[pol.length - 1]),\n    );\n    sum1 += angle;\n    sum2 += Math.PI * 2 - angle;\n    if (sum2 > sum1) return;\n\n    const temp = [];\n    for (let i = pol.length - 1; i >= 0; i -= 1) temp.push(pol[i]);\n    this.points = temp;\n  }\n\n  /**\n   * Function for collision detection and behavior between balls and walls\n   *\n   * @param {Ball} ball The ball that is checked if it collides with the wall\n   */\n  collideWithBall(ball) {\n    /** @type {Vec2 | undefined} */\n    let cp;\n    /** @type {Vec2 | undefined} */\n    let n;\n    const b = ball;\n\n    const onSide = this.points.some((point, idx) => {\n      const bp = Vec2.sub(b.pos, point);\n      if (bp.sqlength <= ball.r * ball.r) {\n        cp = point;\n        n = bp;\n      }\n      const np = this.points[(idx + 1) % this.points.length].copy;\n      const side = new Vec2(np.x - point.x, np.y - point.y);\n      const sideLenSq = side.sqlength;\n      side.setMag(1);\n      const normal = side.copy;\n      normal.rotate270();\n      const posOnLine = Vec2.dot(bp, side);\n      const d = Vec2.dot(bp, normal);\n      if (d >= -ball.r && d < ball.r && posOnLine >= 0\n        && posOnLine * posOnLine <= sideLenSq) {\n        cp = Vec2.add(point, Vec2.mult(side, posOnLine));\n        n = normal;\n        return true;\n      }\n      return false;\n    });\n    if (typeof n !== 'undefined') {\n      if (!onSide) n.setMag(1);\n      if (typeof cp !== 'undefined') {\n        n.mult(-1);\n        b.pos = Vec2.add(cp, Vec2.mult(n, -ball.r));\n        collisionResponseWithWall(b, cp, n);\n      }\n    }\n  }\n\n  /**\n   *Returns true if the point is inside the body\n   *\n   * @param {Vec2} p The point\n   * @returns {boolean} The boolean value\n   */\n  containsPoint(p) {\n    const { sides } = this;\n    const r = Math.max(\n      ...this.points.map((point) => Vec2.dist(point, p)),\n    ) + 1;\n\n    const v = Vec2.fromAngle(0);\n    v.setMag(r);\n\n    const testerSegment = new LineSegment(p, Vec2.add(v, p));\n\n    const filtered = sides.filter(\n      (side) => LineSegment.intersect(side, testerSegment) !== undefined,\n    );\n    return filtered.length % 2 === 1;\n  }\n\n  /**\n   * Calculates the center and the bound radius of the wall\n   */\n  calculateCenterAndRadius() {\n    this.center = this.points.reduce((prev, curr) => Vec2.add(prev, curr));\n    this.center.div(this.points.length);\n\n    this.boundRadius = Math.max(\n      ...this.points.map((p) => Vec2.dist(p, this.center)),\n    );\n  }\n\n  /**\n   * Returns an array containing all the sides of the body\n   *\n   * @returns {Array<LineSegment>} The array of sides\n   */\n  get sides() {\n    return this.points.map((element, index) => new LineSegment(\n      element,\n      this.points[(index + 1) % this.points.length],\n    ));\n  }\n\n  /**\n   * @returns {WallAsObject} The Wall represented in a JS object\n   * Ready to be converted into JSON\n   */\n  toJSObject() {\n    const ret = {};\n\n    ret.points = this.points.map((p) => ({\n      x: p.x,\n      y: p.y,\n    }));\n\n    return ret;\n  }\n\n  /**\n   * Creates a Wall class from the given object\n   *\n   * @param {WallAsObject} obj The object to create the class from\n   * @returns {Wall} The Wall object\n   */\n  static fromObject(obj) {\n    const ret = new Wall(\n      obj.points.map((p) => new Vec2(p.x, p.y)),\n    );\n\n    return ret;\n  }\n}\n\nexport default Wall;\n", "import Vec2 from './vec2';\nimport LineSegment from './linesegment';\nimport Ball from './ball';\nimport Wall from './wall';\nimport { collisionResponse, collisionResponseWithWall } from './collision';\n\n/**\n * An object representation of the Body class for easy conversion to JSON.\n *\n * @typedef {object} BodyAsObject\n * @property {import('./vec2').Vec2AsObject} pos The position\n * @property {import('./vec2').Vec2AsObject} lastPos The last position\n * @property {import('./vec2').Vec2AsObject[]} points The points of the body\n * @property {number} fc The coefficient of friction\n * @property {number} rotation The rotation of the body\n * @property {number} ang The angular velocity\n * @property {number} k The coefficient of restitution (bounciness)\n * @property {import('./vec2').Vec2AsObject} vel The velocity\n * @property {string} id The ID of the body\n */\n\n/**\n * Class representing a body\n * Bodies are movable objects\n * and they collide with other objects (balls)\n */\nclass Body {\n  /**\n   * Creates a body and calculates it's centre of mass (position)\n   *\n   * @param {Vec2[]} points The points that make up the body\n   * @param {Vec2} vel The velocity of the body\n   * @param {number} k Coefficient of restitution\n   * @param {number} ang Angular velocity\n   * @param {number} fc Friction coefficient\n   */\n  constructor(points, vel, k, ang, fc) {\n    this.points = points;\n    this.pos = new Vec2(points[0].x, points[0].y);\n\n    const pol = this.points;\n    let sum1 = 0;\n    let sum2 = 0;\n    let angle = Vec2.angleACW(\n      Vec2.sub(pol[1], pol[0]),\n      Vec2.sub(pol[pol.length - 1], pol[0]),\n    );\n    sum1 += angle;\n    sum2 += Math.PI * 2 - angle;\n    for (let i = 1; i < pol.length - 1; i += 1) {\n      angle = Vec2.angleACW(\n        Vec2.sub(pol[(i + 1) % pol.length], pol[i]),\n        Vec2.sub(pol[i - 1], pol[i]),\n      );\n      sum1 += angle;\n      sum2 += Math.PI * 2 - angle;\n    }\n    angle = Vec2.angleACW(\n      Vec2.sub(pol[0], pol[pol.length - 1]),\n      Vec2.sub(pol[pol.length - 2], pol[pol.length - 1]),\n    );\n    sum1 += angle;\n    sum2 += Math.PI * 2 - angle;\n    if (sum2 < sum1) {\n      const temp = [];\n      for (let i = pol.length - 1; i >= 0; i -= 1) temp.push(pol[i]);\n      this.points = temp;\n    }\n\n    this.m = 1;\n    this.am = 1;\n    this.boundRadius = 1;\n    this.calculatePosAndMass();\n    this.lastPos = this.pos.copy;\n    this.fc = 0.4;\n\n    this.rotation = 0;\n\n    if (ang) this.ang = ang;\n    else this.ang = 0;\n\n    if (fc || fc === 0) this.fc = fc;\n\n    if (k) this.k = k;\n    else this.k = 0.8;\n\n    if (vel !== undefined) this.vel = vel.copy;\n    else this.vel = new Vec2(0, 0);\n\n    this.id = `_${Math.random()\n      .toString(36)\n      .substr(2, 9)}`;\n  }\n\n  /**\n   * Gives the angular mass of the body measured in a given point\n   *\n   * @param {Vec2} point The point to measure the angular mass ins\n   * @returns {number} The adjusted angular mass\n   */\n  getAmInPoint(point) {\n    let ret = this.am;\n\n    ret += Vec2.sub(this.pos, point).sqlength * this.m;\n\n    return ret;\n  }\n\n  /**\n   * Get a copy of the body that is not a reference to it\n   *\n   * @returns {Body} The copy of the body\n   */\n  get copy() {\n    const pointsCopy = this.points.map((p) => new Vec2(p.x, p.y));\n\n    const ret = new Body(pointsCopy, this.vel.copy, this.k, this.ang, this.fc);\n    ret.rotation = this.rotation;\n    ret.lastPos = this.lastPos.copy;\n    ret.pos = this.pos.copy;\n\n    return ret;\n  }\n\n  /**\n   * Moves the body by the given coordinates\n   * It has to move all the points of the body and\n   * also the centre of mass (pos) of the body\n   *\n   * @param {number} x x coordinate\n   * @param {number} y y coordinate\n   */\n  move(x, y) {\n    this.pos.x += x;\n    this.pos.y += y;\n    this.points.forEach((point) => {\n      const p = point;\n      p.x += x;\n      p.y += y;\n    });\n  }\n\n  /**\n   * Function that does the collision detection and\n   * collision behavior between the body and ball\n   *\n   * @param {Ball} ball The ball to collide with the body\n   */\n  collideWithBall(ball) {\n    let heading;\n    let rel;\n    let cp;\n\n    if (Vec2.dist(ball.pos, this.pos) > ball.r + this.boundRadius) return;\n\n    this.points.forEach((point, idx) => {\n      let p = new Vec2(point.x, point.y);\n      p.x -= ball.pos.x;\n      p.y -= ball.pos.y;\n      if (p.length <= ball.r) {\n        heading = p.heading + Math.PI;\n        rel = p.length;\n\n        const move = Vec2.fromAngle(heading);\n        move.mult(ball.r - rel);\n        this.move(\n          (move.x * -1 * ball.m) / (this.m + ball.m),\n          (move.y * -1 * ball.m) / (this.m + ball.m),\n        );\n        ball.move(\n          (move.x * 1 * this.m) / (this.m + ball.m),\n          (move.y * 1 * this.m) / (this.m + ball.m),\n        );\n\n        cp = new Vec2(point.x, point.y);\n\n        const a = Vec2.fromAngle(heading);\n        a.mult(-30);\n      }\n      p = new Vec2(point.x, point.y);\n      const np = new Vec2(\n        this.points[(idx + 1) % this.points.length].x,\n        this.points[(idx + 1) % this.points.length].y,\n      );\n      const bp = new Vec2(ball.pos.x, ball.pos.y);\n      const side = new Vec2(np.x - p.x, np.y - p.y);\n      const h = side.heading;\n      p.rotate(-h + Math.PI);\n      np.rotate(-h + Math.PI);\n      bp.rotate(-h + Math.PI);\n      const d = bp.y - (p.y + np.y) / 2;\n      if (d >= -ball.r && d <= ball.r && bp.x >= np.x && bp.x <= p.x) {\n        heading = h - Math.PI / 2;\n        rel = d;\n\n        const move = Vec2.fromAngle(heading);\n        move.mult(ball.r - rel);\n        this.move(\n          (move.x * -1 * ball.m) / (this.m + ball.m),\n          (move.y * -1 * ball.m) / (this.m + ball.m),\n        );\n        ball.move(\n          (move.x * 1 * this.m) / (this.m + ball.m),\n          (move.y * 1 * this.m) / (this.m + ball.m),\n        );\n\n        cp = ball.pos.copy;\n        cp.add(Vec2.mult(Vec2.fromAngle(heading + Math.PI), d));\n\n        const a = Vec2.fromAngle(heading);\n        a.mult(-30);\n      }\n    });\n\n    if (Number.isFinite(heading) && cp) {\n      // Create collision space basis\n      const n = Vec2.sub(cp, ball.pos);// normal/perpendicular\n      n.setMag(-1);\n      // Calculate collsion response\n      collisionResponse(this, ball, cp, n);\n    }\n  }\n\n  /**\n   * Calculates the mass, moment od intertia and\n   * the centre of mass of the body\n   */\n  calculatePosAndMass() {\n    /** @type {Vec2[][]} */\n    const poligons = [];\n    poligons.push([]);\n    this.points.forEach((p) => {\n      poligons[0].push(new Vec2(p.x, p.y));\n    });\n\n    if (this.isConcave) {\n      /**\n       * @param {number[]} arr Numbers\n       * @param {number} item Number to find\n       * @returns {boolean} Whether the number is in the array\n       */\n      const includes = (arr, item) => {\n        for (let i = 0; i < arr.length; i += 1) {\n          if (arr[i] === item) return true;\n        }\n        return false;\n      };\n      /**\n       * @param {LineSegment} segment Line segment to intersect with\n       * @param {Vec2[]} pol Polygon to intersect with\n       * @param {number[]} exceptions Exceptions\n       * @returns {boolean} Whether intersection is detected\n       */\n      const intersectWithPoligon = (segment, pol, exceptions) => {\n        for (let i = 0; i < pol.length; i += 1) {\n          if (!includes(exceptions, i)) {\n            const side = new LineSegment(\n              new Vec2(pol[i].x, pol[i].y),\n              new Vec2(pol[(i + 1) % pol.length].x, pol[(i + 1) % pol.length].y),\n            );\n            if (LineSegment.intersect(segment, side)) return true;\n          }\n        }\n        return false;\n      };\n      let found = true;\n\n      const loopFunc = () => {\n        found = false;\n        for (let i = 0; i < poligons.length; i += 1) {\n          const pol = poligons[i];\n          let a = Vec2.sub(pol[1], pol[0]);\n          let b = Vec2.sub(pol[pol.length - 1], pol[0]);\n          let angle = Vec2.angleACW(a, b);\n          if (angle > Math.PI) {\n            found = true;\n            const j = 0;\n            let k = j + 2;\n            let newSide = new LineSegment(\n              new Vec2(pol[j].x, pol[j].y),\n              new Vec2(pol[k % pol.length].x, pol[k % pol.length].y),\n            );\n            let newSideHeading = new Vec2(\n              newSide.b.x - newSide.a.x,\n              newSide.b.y - newSide.a.y,\n            ).heading;\n            while (\n              !(a.heading > b.heading\n                ? (newSideHeading > a.heading\n                  && newSideHeading < 2 * Math.PI)\n                || (newSideHeading > 0 && newSideHeading < b.heading)\n                : newSideHeading > a.heading && newSideHeading < b.heading)\n              || intersectWithPoligon(\n                new LineSegment(\n                  new Vec2(pol[j % pol.length].x, pol[j % pol.length].y),\n                  new Vec2(pol[k % pol.length].x, pol[k % pol.length].y),\n                ),\n                pol,\n                [\n                  (pol.length - 1) % pol.length,\n                  j % pol.length,\n                  (k - 1) % pol.length,\n                  k % pol.length,\n                ],\n              )\n            ) {\n              k += 1;\n              newSide = new LineSegment(\n                new Vec2(pol[j].x, pol[j].y),\n                new Vec2(pol[k % pol.length].x, pol[k % pol.length].y),\n              );\n              newSideHeading = new Vec2(\n                newSide.b.x - newSide.a.x,\n                newSide.b.y - newSide.a.y,\n              ).heading;\n            }\n            const pol1 = [];\n            const pol2 = [];\n            for (let l = j; l <= k; l += 1) {\n              pol1.push(pol[l % pol.length]);\n            }\n            for (let l = k; l <= j + pol.length; l += 1) {\n              pol2.push(pol[l % pol.length]);\n            }\n            poligons[i] = pol1;\n            poligons.push(pol2);\n            return;\n          }\n          for (let j = 1; j < pol.length; j += 1) {\n            a = Vec2.sub(pol[(j + 1) % pol.length], pol[j]);\n            b = Vec2.sub(pol[j - 1], pol[j]);\n            angle = Vec2.angleACW(a, b);\n            if (angle > Math.PI) {\n              found = true;\n              let k = j + 2;\n              let newSide = new LineSegment(\n                new Vec2(pol[j].x, pol[j].y),\n                new Vec2(pol[k % pol.length].x, pol[k % pol.length].y),\n              );\n              let newSideHeading = new Vec2(\n                newSide.b.x - newSide.a.x,\n                newSide.b.y - newSide.a.y,\n              ).heading;\n              while (\n                !(a.heading > b.heading\n                  ? (newSideHeading > a.heading\n                    && newSideHeading < 2 * Math.PI)\n                  || (newSideHeading > 0 && newSideHeading < b.heading)\n                  : newSideHeading > a.heading && newSideHeading < b.heading)\n                || intersectWithPoligon(newSide, pol, [\n                  (j - 1) % pol.length,\n                  j % pol.length,\n                  (k - 1) % pol.length,\n                  k % pol.length,\n                ])\n              ) {\n                k += 1;\n                newSide = new LineSegment(\n                  new Vec2(pol[j].x, pol[j].y),\n                  new Vec2(pol[k % pol.length].x, pol[k % pol.length].y),\n                );\n                newSideHeading = new Vec2(\n                  newSide.b.x - newSide.a.x,\n                  newSide.b.y - newSide.a.y,\n                ).heading;\n              }\n              const pol1 = [];\n              const pol2 = [];\n              for (let l = j; l <= k; l += 1) {\n                pol1.push(pol[l % pol.length]);\n              }\n              for (let l = k; l <= j + pol.length; l += 1) {\n                pol2.push(pol[l % pol.length]);\n              }\n              poligons[i] = pol1;\n              poligons.push(pol2);\n              return;\n            }\n          }\n        }\n      };\n      while (found) {\n        loopFunc();\n      }\n    }\n\n    for (let i = poligons.length - 1; i >= 0; i -= 1) {\n      const pol = poligons[i];\n      while (pol.length > 3) {\n        poligons.push([pol[0], pol[1], pol[2]]);\n        pol.splice(1, 1);\n      }\n    }\n\n    let mSum = 0;\n    let amSum = 0;\n    const pSum = new Vec2(0, 0);\n    poligons.forEach((pol) => {\n      const a = Math.sqrt(\n        ((pol[0].x - pol[1].x) ** 2) + ((pol[0].y - pol[1].y) ** 2),\n      );\n      const b = Math.sqrt(\n        ((pol[1].x - pol[2].x) ** 2) + ((pol[1].y - pol[2].y) ** 2),\n      );\n      const c = Math.sqrt(\n        ((pol[2].x - pol[0].x) ** 2) + ((pol[2].y - pol[0].y) ** 2),\n      );\n      const s = (a + b + c) / 2;\n      const m = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n      mSum += m;\n      pSum.x += (m * (pol[0].x + pol[1].x + pol[2].x)) / 3;\n      pSum.y += (m * (pol[0].y + pol[1].y + pol[2].y)) / 3;\n    });\n    pSum.div(mSum);\n    /** @type {Vec2} */\n    this.pos = pSum;\n    /** @type {number} */\n    this.m = mSum;\n\n    // calculating the moment of inertia finally\n    poligons.forEach((pol) => {\n      const a = Math.sqrt(\n        ((pol[0].x - pol[1].x) ** 2) + ((pol[0].y - pol[1].y) ** 2),\n      );\n      const b = Math.sqrt(\n        ((pol[1].x - pol[2].x) ** 2) + ((pol[1].y - pol[2].y) ** 2),\n      );\n      const c = Math.sqrt(\n        ((pol[2].x - pol[0].x) ** 2) + ((pol[2].y - pol[0].y) ** 2),\n      );\n      const w = Math.max(a, b, c);\n      const s = (a + b + c) / 2;\n      const m = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n      const h = (2 * m) / w;\n      const wpartial = Math.sqrt(Math.min(a, c, b) ** 2 - h * h);\n      let am = (h * w * (h * h + w * w)) / 24;\n      const d = Math.sqrt((h * h) / 36 + (Math.abs(wpartial - w / 2) / 3) ** 2);\n      am -= d * d * m;\n      am\n        += new Vec2(\n          (pol[0].x + pol[1].x + pol[2].x) / 3,\n          (pol[0].y + pol[1].y + pol[2].y) / 3,\n        ).dist(this.pos)\n        ** 2\n        * m;\n      amSum += am;\n    });\n    this.am = amSum;\n\n    this.boundRadius = Math.max(\n      ...this.points.map((p) => Vec2.dist(p, this.pos)),\n    );\n  }\n\n  /**\n   * Rotates the body around it's centre of mass by a given ange\n   * Has to do the transformation for all the points\n   *\n   * @param {number} angle Rotation angle\n   */\n  rotate(angle) {\n    this.points.forEach((p) => {\n      const point = p;\n      point.sub(this.pos);\n      point.rotate(angle);\n      point.add(this.pos);\n    });\n    this.rotation += angle;\n  }\n\n  /**\n   * Finds out if the body is concave or not\n   *\n   * @returns {boolean} True if the body is concave\n   */\n  get isConcave() {\n    const pol = this.points;\n    let angle = Vec2.angleACW(\n      Vec2.sub(pol[1], pol[0]),\n      Vec2.sub(pol[pol.length - 1], pol[0]),\n    );\n    if (angle > Math.PI) return true;\n    for (let i = 1; i < pol.length - 1; i += 1) {\n      angle = Vec2.angleACW(\n        Vec2.sub(pol[(i + 1) % pol.length], pol[i]),\n        Vec2.sub(pol[i - 1], pol[i]),\n      );\n      if (angle > Math.PI) return true;\n    }\n    angle = Vec2.angleACW(\n      Vec2.sub(pol[0], pol[pol.length - 1]),\n      Vec2.sub(pol[pol.length - 2], pol[pol.length - 1]),\n    );\n    if (angle > Math.PI) return true;\n    return false;\n  }\n\n  /**\n   * Does the collision algorithm between two bodies\n   *\n   * @param {Body} b1 First body\n   * @param {Body} b2 Second body\n   */\n  static collide(b1, b2) {\n    let matches = 0;\n    let heading = 0;\n    const cp = new Vec2(0, 0);\n    /** @type {Vec2[]} */\n    const cps = [];\n    let intersect = false;\n    const body1 = b1;\n    const body2 = b2;\n    b1.points.forEach((p, idx) => {\n      const side1 = new LineSegment(\n        new Vec2(p.x, p.y),\n        new Vec2(\n          b1.points[(idx + 1) % b1.points.length].x,\n          b1.points[(idx + 1) % b1.points.length].y,\n        ),\n      );\n      b2.points.forEach((pp, idxx) => {\n        const side2 = new LineSegment(\n          new Vec2(pp.x, pp.y),\n          new Vec2(\n            b2.points[(idxx + 1) % b2.points.length].x,\n            b2.points[(idxx + 1) % b2.points.length].y,\n          ),\n        );\n        const sect = LineSegment.intersect(side1, side2);\n        if (sect instanceof Vec2) {\n          matches += 1;\n          cp.add(sect);\n          cps.push(sect);\n          intersect = true;\n        }\n      });\n    });\n\n    if (!intersect) return;\n    cp.div(matches);\n\n    for (let i = 0; i < Math.floor(matches / 2); i += 1) {\n      heading += Vec2.sub(cps[2 * i + 1], cps[2 * i]).heading;\n    }\n    heading /= matches / 2;\n    heading += Math.PI / 2;\n\n    const a = Vec2.fromAngle(heading);\n\n    const startAng1 = b1.ang;\n    const startVel1 = b1.vel.copy;\n    const startAng2 = b2.ang;\n    const startVel2 = b2.vel.copy;\n\n    let move1Min = 0;\n    let move1Max = 0;\n    let move2Min = 0;\n    let move2Max = 0;\n    b1.points.forEach((point) => {\n      move1Min = Math.min(\n        Vec2.dot(a, Vec2.sub(point, cp)),\n        move1Min,\n      );\n      move1Max = Math.max(\n        Vec2.dot(a, Vec2.sub(point, cp)),\n        move1Max,\n      );\n    });\n    b2.points.forEach((point) => {\n      move2Min = Math.min(\n        Vec2.dot(a, Vec2.sub(point, cp)),\n        move2Min,\n      );\n      move2Max = Math.max(\n        Vec2.dot(a, Vec2.sub(point, cp)),\n        move2Max,\n      );\n    });\n    if (Math.abs(move1Min - move2Max) < Math.abs(move2Min - move1Max)) {\n      b1.move(-a.x * move1Min, -a.y * move1Min);\n      b2.move(-a.x * move2Max, -a.y * move2Max);\n    } else {\n      b1.move(-a.x * move1Max, -a.y * move1Max);\n      b2.move(-a.x * move2Min, -a.y * move2Min);\n    }\n\n    const collisionPoints = cps;\n\n    /** @type {number[]} */\n    const endAngs1 = [];\n    /** @type {number[]} */\n    const endAngs2 = [];\n    /** @type {Vec2[]} */\n    const endVels1 = [];\n    /** @type {Vec2[]} */\n    const endVels2 = [];\n\n    collisionPoints.forEach((collisionPoint) => {\n      // Calculate collision response\n      collisionResponse(b1, b2, collisionPoint, Vec2.fromAngle(heading));\n\n      // Store calculated values and revert\n      endAngs1.push(b1.ang);\n      endVels1.push(b1.vel);\n      endAngs2.push(b2.ang);\n      endVels2.push(b2.vel);\n\n      body1.ang = startAng1;\n      body1.vel = startVel1;\n      body2.ang = startAng2;\n      body2.vel = startVel2;\n    });\n\n    if (endAngs1.length !== endVels1.length) return;\n    if (endAngs1.length === 0) return;\n    if (endVels1.length === 0) return;\n    if (endAngs2.length !== endVels2.length) return;\n    if (endAngs2.length === 0) return;\n    if (endVels2.length === 0) return;\n\n    body1.vel = endVels1.reduce((prev, curr) => Vec2.add(prev, curr));\n    body1.vel.div(endVels1.length);\n    body1.ang = endAngs1.reduce((prev, curr) => prev + curr);\n    body1.ang /= endAngs1.length;\n    body2.vel = endVels2.reduce((prev, curr) => Vec2.add(prev, curr));\n    body2.vel.div(endVels2.length);\n    body2.ang = endAngs2.reduce((prev, curr) => prev + curr);\n    body2.ang /= endAngs2.length;\n  }\n\n  /**\n   * Detects and reacts to collision with a fixedBall\n   *\n   * @param {import('./physics').FixedBall} fixedBall The fixedBall to take the collision with\n   */\n  collideWithFixedBall(fixedBall) {\n    const fbPos = new Vec2(fixedBall.x, fixedBall.y);\n    let collisionPoint;\n\n    if (Vec2.dist(fbPos, this.pos) > this.boundRadius + fixedBall.r) return;\n\n    // Detect collision with sides\n    this.sides.forEach((side) => {\n      const angle1 = Vec2.angle(Vec2.sub(side.a, side.b), Vec2.sub(fbPos, side.b));\n      const angle2 = Vec2.angle(Vec2.sub(side.b, side.a), Vec2.sub(fbPos, side.a));\n\n      if (angle1 < Math.PI / 2 && angle2 < Math.PI / 2) {\n        const d = side.distFromPoint(fbPos);\n        if (d <= fixedBall.r) {\n          let perp = Vec2.sub(side.a, side.b);\n          perp.rotate(Math.PI / 2);\n          perp.setMag(fixedBall.r * 2);\n          const negPerp = Vec2.mult(perp, -1);\n          const detectorSegment = new LineSegment(\n            Vec2.add(perp, fbPos),\n            Vec2.add(negPerp, fbPos),\n          );\n          collisionPoint = LineSegment.intersect(detectorSegment, side);\n          if (collisionPoint instanceof Vec2) {\n            perp = Vec2.sub(collisionPoint, fbPos);\n            perp.setMag(fixedBall.r - perp.length);\n            this.move(perp.x, perp.y);\n          }\n        }\n      }\n    });\n\n    // Detect collison with points\n    if (!collisionPoint || collisionPoint === undefined) {\n      this.points.forEach((point) => {\n        if (Vec2.dist(point, fbPos) < fixedBall.r) {\n          const d = Vec2.sub(point, fbPos);\n          d.setMag(fixedBall.r - d.length);\n          this.move(d.x, d.y);\n          d.setMag(fixedBall.r);\n          collisionPoint = Vec2.add(fbPos, d);\n        }\n      });\n    }\n\n    if (!collisionPoint || collisionPoint === undefined) return;\n\n    // Deal with the change in velocity by the collision\n    const n = Vec2.sub(collisionPoint, fbPos);\n    n.setMag(1);\n    collisionResponseWithWall(this, collisionPoint, n);\n  }\n\n  /**\n   * Does a collision with a wall\n   *\n   * @param {Wall} wall The wall to collide with\n   */\n  collideWithWall(wall) {\n    if (\n      this.boundRadius + wall.boundRadius\n      < Vec2.dist(this.pos, wall.center)\n    ) {\n      return;\n    }\n\n    const { sides } = this;\n\n    /** @type {Vec2[]} */\n    const collisionPoints = [];\n    sides.forEach((bodySide) => {\n      wall.sides.forEach((wallSide) => {\n        const collisionPoint = LineSegment.intersect(bodySide, wallSide);\n        if (collisionPoint instanceof Vec2) {\n          collisionPoints.push(collisionPoint);\n        }\n      });\n    });\n\n    const startingVel = this.vel.copy;\n    const startingAng = this.ang;\n\n    /** @type {Vec2[]} */\n    const endVels = [];\n    /** @type {number[]} */\n    const endAngs = [];\n\n    // Need to adjust the position of the Body\n    if (collisionPoints.length >= 2) {\n      const normal = Vec2.sub(collisionPoints[0], collisionPoints[1]);\n      normal.rotate(Math.PI / 2);\n\n      const r = Vec2.sub(collisionPoints[0], this.pos);\n      if (Vec2.dot(normal, r) > 0) normal.mult(-1);\n      normal.setMag(1);\n      if (Vec2.dot(normal, Vec2.sub(this.pos, wall.center)) < 0) {\n        normal.mult(-1);\n      }\n\n      /** @type {number[]} */\n      let moveAmounts = [];\n\n      const cp = collisionPoints[0];\n      wall.points.forEach((p) => {\n        const pointVec = Vec2.sub(p, cp);\n        const dist = Vec2.dot(pointVec, normal);\n        if (dist > 0) {\n          moveAmounts.push(dist);\n        }\n      });\n\n      if (moveAmounts.length > 0) {\n        const moveVector = normal.copy;\n        moveVector.mult(Math.max(...moveAmounts));\n        this.move(moveVector.x, moveVector.y);\n      }\n\n      moveAmounts = [];\n      const midCp = Vec2.add(collisionPoints[0], collisionPoints[1]);\n      midCp.div(2);\n      if (this.containsPoint(midCp)) {\n        sides.forEach((side) => {\n          moveAmounts.push(side.distFromPoint(midCp));\n        });\n      }\n\n      if (moveAmounts.length > 0) {\n        const moveVector = normal.copy;\n        moveVector.mult(Math.min(...moveAmounts));\n        if (moveVector.length < this.boundRadius / 2) {\n          this.move(moveVector.x, moveVector.y);\n        }\n      }\n\n      collisionPoints.forEach((collisionPoint) => {\n        // Calculate post-collision velocities\n        collisionResponseWithWall(this, collisionPoint, normal);\n\n        endVels.push(this.vel);\n        this.vel = startingVel.copy;\n        endAngs.push(this.ang);\n        this.ang = startingAng;\n      });\n\n      if (endAngs.length !== endVels.length) return;\n      if (endAngs.length === 0) return;\n      if (endVels.length === 0) return;\n\n      this.vel = endVels.reduce((prev, curr) => Vec2.add(prev, curr));\n      this.vel.div(endVels.length);\n      this.ang = endAngs.reduce((prev, curr) => prev + curr);\n      this.ang /= endAngs.length;\n\n      if (!Number.isFinite(this.vel.x)\n        || !Number.isFinite(this.vel.y)\n        || !Number.isFinite(this.ang)) {\n        this.vel = startingVel;\n        this.ang = startingAng;\n      }\n    }\n  }\n\n  /**\n   *Returns true if the point is inside the body\n   *\n   * @param {Vec2} p The point\n   * @returns {boolean} The boolean value\n   */\n  containsPoint(p) {\n    const { sides } = this;\n    const r = Math.max(\n      ...this.points.map((point) => Vec2.dist(point, p)),\n    ) + 1;\n\n    const v = Vec2.fromAngle(0);\n    v.setMag(r);\n\n    const testerSegment = new LineSegment(p, Vec2.add(v, p));\n\n    const filtered = sides\n      .filter((side) => LineSegment.intersect(side, testerSegment) !== undefined);\n    return filtered.length % 2 === 1;\n  }\n\n  /**\n   * Returns an array containing all the sides of the body\n   *\n   * @returns {LineSegment[]} All the sides of the body\n   */\n  get sides() {\n    return this.points.map((element, index) => new LineSegment(\n      element,\n      this.points[(index + 1) % this.points.length],\n    ));\n  }\n\n  /**\n   * Calculates the effective velocity of the body object in a\n   * given point from it's velocity and angular velocity\n   *\n   * @param {Vec2 | import('./vec2').Vec2AsObject} point The point to be taken a look at\n   * @returns {Vec2} The velocity of the Body in the given point\n   */\n  velInPlace(point) {\n    const vp = Vec2.sub(point, this.pos);\n    vp.rotate(Math.PI / 2);\n    vp.mult(this.ang);\n    vp.add(this.vel);\n    return vp;\n  }\n\n  /**\n   * Calculates the effective mass of the body in\n   * a given point when pulled/pushed in a given direction\n   * by a hypothetical force\n   *\n   * @param {Vec2} point The given point\n   * @param {Vec2} direction The direction of the force\n   * @returns {number} The effective mass of the body in the given point\n   */\n  effectiveMass(point, direction) {\n    const r = Vec2.sub(point, this.pos);// Vector to the collision point\n    const angle = Vec2.angle(direction, r);\n    const rotationalMass = ((Math.sin(angle) ** 2) * (r.length ** 2)) / this.am;\n    return 1 / (rotationalMass + (1 / this.m));\n  }\n\n  /**\n   * Realistically applies a change of velocity (momentum)\n   * on the body\n   *\n   * @param {Vec2} dvel The change in velocity\n   * @param {Vec2} point The point of pushing\n   */\n  applyDeltaVelInPoint(dvel, point) {\n    const r = Vec2.sub(point, this.pos);\n    if (r.length === 0) {\n      this.vel.add(dvel);\n      return;\n    }\n    const angle = Vec2.angle(r, dvel);\n    // Change vel in line with the center of mass\n    const deltaVlined = Vec2.mult(r, Vec2.dot(dvel, r) / (r.length ** 2));\n    this.vel.add(deltaVlined);\n\n    // Change it perpendicular to the line\n    const d = r.copy;\n    d.rotate(Math.PI / 2);\n    d.setMag(1);\n    const rotateDirection = Math.sign(Vec2.dot(dvel, d));\n    const dvelAng = dvel.length * Math.cos(angle);\n    const mEff = 1 / ((1 / this.m) + ((r.length ** 2) / this.am));\n    const dvm = (dvelAng * mEff) / this.m;\n    this.vel.add(Vec2.mult(d, dvm * rotateDirection));\n\n    const dAng = (rotateDirection * dvelAng * mEff * r.length) / this.am;\n    this.ang -= dAng;\n  }\n\n  /**\n   * @returns {BodyAsObject} The Body represented in a JS object\n   * Ready to be converted into JSON\n   */\n  toJSObject() {\n    const ret = {};\n\n    ret.points = this.points.map((p) => ({\n      x: p.x,\n      y: p.y,\n    }));\n    ret.vel = this.vel.toJSObject();\n    ret.k = this.k;\n    ret.ang = this.ang;\n    ret.fc = this.fc;\n    ret.pos = this.pos.toJSObject();\n    ret.lastPos = this.lastPos.toJSObject();\n    ret.rotation = this.rotation;\n    ret.id = this.id;\n\n    return ret;\n  }\n\n  /**\n   * Creates a Body class from the given object\n   *\n   * @param {BodyAsObject} obj The object to create the class from\n   * @returns {Body} The Body object\n   */\n  static fromObject(obj) {\n    const ret = new Body(\n      obj.points.map((p) => (new Vec2(p.x, p.y))),\n      Vec2.fromObject(obj.vel),\n      obj.k,\n      obj.ang,\n      obj.fc,\n    );\n\n    ret.id = obj.id;\n    ret.pos = Vec2.fromObject(obj.pos);\n    ret.lastPos = Vec2.fromObject(obj.lastPos);\n    ret.rotation = obj.rotation;\n\n    return ret;\n  }\n}\n\nexport default Body;\n", "import Ball from './ball';\nimport Body from './body';\nimport Vec2 from './vec2';\n\n/**\n * An object representation of the Spring class for easy conversion to JSON.\n *\n * @typedef {object} SpringAsObject\n * @property {number} length The length of the spring\n * @property {number} springConstant The stiffness of the spring\n * @property {boolean | {x:number, y:number}} pinned This property indicates whether\n * the spring is pinned or not\n * @property {string[]} objects The IDs of the attached objects\n * @property {boolean} rotationLocked The variable inticating whether or not\n * the attached objects are allowed to rotate freely\n * @property {string} id The ID of the Spring\n * @property {\"spring\"} type Indicates that the object is a spring\n */\n\n/**\n * Class representing a string\n * They act like springs in real life\n * You can attach other objects to the ends of them\n * They do not collide with other object neither with each other\n */\nclass Spring {\n  /**\n   * Creates a spring\n   *\n   * @param {number} length The unstreched length of the spring\n   * @param {number} springConstant Spring constant\n   */\n  constructor(length, springConstant) {\n    this.length = length;\n    this.springConstant = springConstant;\n    /** @type {boolean | {x:number, y:number}} */\n    this.pinned = false;\n    /** @type {import('./physics').PhysicalObject[]} */\n    this.objects = [];\n    this.rotationLocked = false;\n    this.id = `_${Math.random()\n      .toString(36)\n      .substr(2, 9)}`;\n  }\n\n  /**\n   * Pins one side of the the spring to a given coordinate in space\n   *\n   * @param {number} x x coordinate\n   * @param {number} y y coordinate\n   */\n  pinHere(x, y) {\n    this.pinned = {\n      x,\n      y,\n    };\n  }\n\n  /**\n   * Removes the pinned tag from the spring\n   * You can now attach it to another object\n   */\n  unpin() {\n    this.pinned = false;\n  }\n\n  /**\n   * Attaches one end of the spring to an object (eg. Ball)\n   *\n   * @param {Body | Ball} object The object that the spring is getting attached to\n   */\n  attachObject(object) {\n    let ob = this.objects;\n    ob.push(object);\n    if (ob.length === 2) {\n      this.pinned = false;\n    }\n    if (ob.length >= 3) {\n      ob = [ob[ob.length - 2], ob[ob.length - 1]];\n    }\n  }\n\n  /**\n   * Locks the objects attached to the ends of the spring\n   * to not rotate around the attach point\n   */\n  lockRotation() {\n    this.rotationLocked = true;\n  }\n\n  /**\n   * Releases the objects attached to the ends of the spring\n   * to rotate around the attach point\n   */\n  unlockRotation() {\n    this.rotationLocked = false;\n  }\n\n  /**\n   * Updates the spring bay the elapsed time\n   *\n   * @param {number} t Elapsed time\n   */\n  update(t) {\n    let p1;\n    let p2;\n    if (this.pinned instanceof Object && this.objects[0]) {\n      [p2, p1] = [this.pinned, this.objects[0]];\n      const dist = new Vec2(p2.x - p1.pos.x, p2.y - p1.pos.y);\n      const dl = dist.length - this.length;\n      dist.setMag(1);\n      dist.mult((dl * this.springConstant * t) / p1.m);\n      p1.vel.x += dist.x;\n      p1.vel.y += dist.y;\n\n      const v = p1.vel;\n      v.rotate(-dist.heading);\n      if (this.rotationLocked) {\n        const s = new Vec2(p2.x, p2.y);\n        const r2 = Vec2.sub(p1.pos, s);\n        const len = r2.length;\n        const am = len * len * p1.m + p1.am;\n        const ang = (p1.am * p1.ang - len * p1.m * v.y) / am;\n\n        v.y = -ang * len;\n\n        p1.ang = ang;\n      }\n      v.rotate(dist.heading);\n    } else if (this.objects[0] && this.objects[1]) {\n      [p1, p2] = [this.objects[0], this.objects[1]];\n      let dist = Vec2.sub(p1.pos, p2.pos);\n      const dl = dist.length - this.length;\n      dist.setMag(1);\n      dist.mult(dl * this.springConstant * t);\n      p2.vel.add(Vec2.div(dist, p2.m));\n      p1.vel.add(Vec2.div(dist, -p1.m));\n\n      dist = Vec2.sub(p1.pos, p2.pos);\n      const v1 = p1.vel;\n      const v2 = p2.vel;\n      v1.rotate(-dist.heading);\n      v2.rotate(-dist.heading);\n\n      if (this.rotationLocked) {\n        const s = new Vec2(\n          p1.pos.x * p1.m + p2.pos.x * p2.m,\n          p1.pos.y * p1.m + p2.pos.y * p2.m,\n        );\n        s.div(p1.m + p2.m);\n        const r1 = Vec2.sub(p1.pos, s);\n        const r2 = Vec2.sub(p2.pos, s);\n        const len1 = r1.length;\n        const len2 = r2.length;\n        const am = len1 * len1 * p1.m\n          + p1.am\n          + len2 * len2 * p2.m\n          + p2.am;\n        const sv = ((v1.y - v2.y) * len2) / (len1 + len2) + v2.y;\n        const ang = (p1.am * p1.ang\n          + p2.am * p2.ang\n          + len1 * p1.m * (v1.y - sv)\n          - len2 * p2.m * (v2.y - sv))\n          / am;\n\n        v1.y = ang * len1 + sv;\n        v2.y = -ang * len2 + sv;\n\n        p1.ang = ang;\n        p2.ang = ang;\n      }\n\n      v1.rotate(dist.heading);\n      v2.rotate(dist.heading);\n    }\n  }\n}\n\nexport default Spring;\n", "import Vec2 from './vec2';\nimport Spring from './spring';\n\n/**\n * An object representation of the Spring class for easy conversion to JSON.\n *\n * @typedef {object} StickAsObject\n * @property {number} length The length of the stick\n * @property {number} springConstant Always 0 for sticks\n * @property {boolean | {x:number, y:number}} pinned This property indicates whether\n * the stick is pinned or not\n * @property {string[]} objects The IDs of the attached objects\n * @property {boolean} rotationLocked The variable inticating whether or not\n * the attached objects are allowed to rotate freely\n * @property {string} id The ID of the Stick\n * @property {\"stick\"} type Indicates that the object is a stick\n */\n\n/**\n * Stick class for the physics engine\n * Sticks are not strechable objects that do not collide\n * with other objects but they can hold other objects on their ends\n *\n * @implements {Spring}\n */\nclass Stick extends Spring {\n  /**\n   * Creates a stick\n   *\n   * @param {number} length The length of the stick\n   */\n  constructor(length) {\n    super(length, 0);\n    this.springConstant = 0;\n  }\n\n  /**\n   * Updates the stick trough an elapsed time\n   */\n  update() {\n    let p1;\n    let p2;\n    if (this.pinned instanceof Object && 'x' in this.pinned && this.objects[0]) {\n      [p2, p1] = [this.pinned, this.objects[0]];\n      const dist = new Vec2(p2.x - p1.pos.x, p2.y - p1.pos.y);\n      dist.setMag(1);\n      dist.mult(-this.length);\n      p1.move(-p1.pos.x + p2.x + dist.x, -p1.pos.y + p2.y + dist.y);\n\n      const v = p1.vel;\n      v.rotate(-dist.heading);\n      v.x = 0;\n      if (this.rotationLocked) {\n        const s = new Vec2(p2.x, p2.y);\n        const r2 = Vec2.sub(p1.pos, s);\n        const len = r2.length;\n        const am = len * len * p1.m + p1.am;\n        const ang = (p1.am * p1.ang + len * p1.m * v.y) / am;\n\n        v.y = ang * len;\n\n        p1.ang = ang;\n      }\n\n      v.rotate(dist.heading);\n    } else if (this.objects[0] && this.objects[1]) {\n      [p1, p2] = [this.objects[0], this.objects[1]];\n      const dist = Vec2.sub(p1.pos, p2.pos);\n      const dl = this.length - dist.length;\n      dist.setMag(1);\n      const move1 = Vec2.mult(dist, (dl * p2.m) / (p1.m + p2.m));\n      const move2 = Vec2.mult(dist, (-dl * p1.m) / (p1.m + p2.m));\n      p1.move(move1.x, move1.y);\n      p2.move(move2.x, move2.y);\n\n      const v1 = p1.vel;\n      const v2 = p2.vel;\n      v1.rotate(-dist.heading);\n      v2.rotate(-dist.heading);\n      v1.x = (p1.m * v1.x + p2.m * v2.x) / (p1.m + p2.m);\n      v2.x = v1.x;\n\n      if (this.rotationLocked) {\n        const s = new Vec2(\n          p1.pos.x * p1.m + p2.pos.x * p2.m,\n          p1.pos.y * p1.m + p2.pos.y * p2.m,\n        );\n        s.div(p1.m + p2.m);\n        const r1 = Vec2.sub(p1.pos, s);\n        const r2 = Vec2.sub(p2.pos, s);\n        const len1 = r1.length;\n        const len2 = r2.length;\n        const am = len1 * len1 * p1.m\n          + p1.am\n          + len2 * len2 * p2.m\n          + p2.am;\n        const sv = ((v1.y - v2.y) * len2) / (len1 + len2) + v2.y;\n        const ang = (p1.am * p1.ang\n          + p2.am * p2.ang\n          + len1 * p1.m * (v1.y - sv)\n          - len2 * p2.m * (v2.y - sv))\n          / am;\n\n        v1.y = ang * len1 + sv;\n        v2.y = -ang * len2 + sv;\n\n        p1.ang = ang;\n        p2.ang = ang;\n      }\n\n      v1.rotate(dist.heading);\n      v2.rotate(dist.heading);\n    }\n  }\n}\n\nexport default Stick;\n", "/* eslint-disable no-continue */\n/* eslint-disable no-labels */\nimport Vec2 from './vec2';\nimport Ball from './ball';\nimport Stick from './stick';\nimport LineSegment from './linesegment';\nimport Spring from './spring';\n\n/**\n * An object representation of the SoftBall class for easy conversion to JSON.\n *\n * @typedef {object} SoftBallAsObject\n * @property {number} pressure The pressure inside the softball\n * @property {number} fc The friction coefficient\n * @property {number} r The original radius of the softball\n * @property {number} resolution The number of Balls used to construct the SoftBall\n * @property {string[]} points The IDs Balls' that make up the SoftBall\n * @property {string[]} sides The IDs of the sticks' holding the softball together\n */\n\n/**\n * Class representing a softbody object\n * They work like a ball, with pressure inside\n */\nclass SoftBall {\n  /**\n   * Creates a SoftBall\n   *\n   * @param {Vec2} pos The starting position of the soft ball\n   * @param {number} r The radius of the soft ball\n   * @param {number} pressure The \"hardness\" of the soft ball\n   * @param {number} fc Friction coefficient\n   * @param {number} resolution The number of points that make up the ball\n   */\n  constructor(pos, r, pressure, fc, resolution) {\n    /** @type {Ball[]} */\n    this.points = [];\n\n    if (fc || fc === 0) this.fc = fc;\n    else this.fc = 0.4;\n\n    this.pressure = pressure;\n\n    if (!resolution) this.resolution = 30;\n    else this.resolution = resolution;\n\n    this.r = Math.abs(r);\n\n    const layerNumber = Math.random() * 1000000;\n\n    for (let i = 0; i < this.resolution; i += 1) {\n      const newPos = new Vec2(pos.x, pos.y);\n      newPos.add(\n        Vec2.mult(Vec2.fromAngle((i / this.resolution) * Math.PI * 2), this.r),\n      );\n      this.points.push(\n        new Ball(\n          newPos,\n          new Vec2(0, 0),\n          this.r * Math.sin(Math.PI / this.resolution),\n          0,\n          0,\n          this.fc,\n        ),\n      );\n      this.points[this.points.length - 1].layer = layerNumber;\n    }\n\n    this.sides = [];\n    for (let i = 0; i < this.resolution; i += 1) {\n      const side = new Stick(2 * this.r * Math.sin(Math.PI / this.resolution));\n      side.attachObject(this.points[i]);\n      side.attachObject(this.points[(i + 1) % this.resolution]);\n      if (i % 2 === 0) side.lockRotation();\n      this.sides.push(side);\n    }\n  }\n\n  /**\n   * Updates the pressure-based forces in the soft ball\n   *\n   * @param {SoftBall} softBall The soft ball to update\n   * @param {number} t Elapsed time\n   */\n  static updatePressureBasedForces(softBall, t) {\n    /** @type {Vec2[][]} */\n    const poligons = [];\n    poligons.push([]);\n    softBall.points.forEach((p) => {\n      poligons[0].push(new Vec2(p.pos.x, p.pos.y));\n    });\n\n    if (\n      ((pol) => {\n        let angle = Vec2.angleACW(\n          Vec2.sub(pol[1], pol[0]),\n          Vec2.sub(pol[pol.length - 1], pol[0]),\n        );\n        if (angle > Math.PI) return true;\n        for (let i = 1; i < pol.length - 1; i += 1) {\n          angle = Vec2.angleACW(\n            Vec2.sub(pol[(i + 1) % pol.length], pol[i]),\n            Vec2.sub(pol[i - 1], pol[i]),\n          );\n          if (angle > Math.PI) return true;\n        }\n        angle = Vec2.angleACW(\n          Vec2.sub(pol[0], pol[pol.length - 1]),\n          Vec2.sub(pol[pol.length - 2], pol[pol.length - 1]),\n        );\n        if (angle > Math.PI) return true;\n        return false;\n      })(poligons[0])\n    ) {\n      /**\n       * @param {number[]} arr Numbers\n       * @param {number} item Number to find\n       * @returns {boolean} Whether the number is in the array\n       */ const includes = (arr, item) => {\n        for (let i = 0; i < arr.length; i += 1) {\n          if (arr[i] === item) return true;\n        }\n        return false;\n      };\n      /**\n       * @param {LineSegment} segment Line segment to intersect with\n       * @param {Vec2[]} pol Polygon to intersect with\n       * @param {number[]} exc Exceptions\n       * @returns {boolean} Whether intersection is detected\n       */ const intersectWithPoligon = (segment, pol, exc) => {\n        for (let i = 0; i < pol.length; i += 1) {\n          if (!includes(exc, i)) {\n            const side = new LineSegment(\n              new Vec2(pol[i].x, pol[i].y),\n              new Vec2(pol[(i + 1) % pol.length].x, pol[(i + 1) % pol.length].y),\n            );\n            if (LineSegment.intersect(segment, side)) return true;\n          }\n        }\n        return false;\n      };\n      let found = true;\n\n      // eslint-disable-next-line no-restricted-syntax\n      checkAllPoligons: while (found) {\n        found = false;\n        for (let i = 0; i < poligons.length; i += 1) {\n          const pol = poligons[i];\n          let a = Vec2.sub(pol[1], pol[0]);\n          let b = Vec2.sub(pol[pol.length - 1], pol[0]);\n          let angle = Vec2.angleACW(a, b);\n          if (angle > Math.PI) {\n            found = true;\n            const j = 0;\n            let k = j + 2;\n            let newSide = new LineSegment(\n              new Vec2(pol[j].x, pol[j].y),\n              new Vec2(pol[k % pol.length].x, pol[k % pol.length].y),\n            );\n            let newSideHeading = new Vec2(\n              newSide.b.x - newSide.a.x,\n              newSide.b.y - newSide.a.y,\n            ).heading;\n            while (\n              !(a.heading > b.heading\n                ? (newSideHeading > a.heading\n                    && newSideHeading < 2 * Math.PI)\n                  || (newSideHeading > 0 && newSideHeading < b.heading)\n                : newSideHeading > a.heading && newSideHeading < b.heading)\n              || intersectWithPoligon(\n                new LineSegment(\n                  new Vec2(pol[j % pol.length].x, pol[j % pol.length].y),\n                  new Vec2(pol[k % pol.length].x, pol[k % pol.length].y),\n                ),\n                pol,\n                [\n                  (pol.length - 1) % pol.length,\n                  j % pol.length,\n                  (k - 1) % pol.length,\n                  k % pol.length,\n                ],\n              )\n            ) {\n              k += 1;\n              newSide = new LineSegment(\n                new Vec2(pol[j].x, pol[j].y),\n                new Vec2(pol[k % pol.length].x, pol[k % pol.length].y),\n              );\n              newSideHeading = new Vec2(\n                newSide.b.x - newSide.a.x,\n                newSide.b.y - newSide.a.y,\n              ).heading;\n            }\n            const pol1 = [];\n            const pol2 = [];\n            for (let l = j; l <= k; l += 1) {\n              pol1.push(pol[l % pol.length]);\n            }\n            for (let l = k; l <= j + pol.length; l += 1) {\n              pol2.push(pol[l % pol.length]);\n            }\n            poligons[i] = pol1;\n            poligons.push(pol2);\n            continue checkAllPoligons;\n          }\n          for (let j = 1; j < pol.length; j += 1) {\n            a = Vec2.sub(pol[(j + 1) % pol.length], pol[j]);\n            b = Vec2.sub(pol[j - 1], pol[j]);\n            angle = Vec2.angleACW(a, b);\n            if (angle > Math.PI) {\n              found = true;\n              let k = j + 2;\n              let newSide = new LineSegment(\n                new Vec2(pol[j].x, pol[j].y),\n                new Vec2(pol[k % pol.length].x, pol[k % pol.length].y),\n              );\n              let newSideHeading = new Vec2(\n                newSide.b.x - newSide.a.x,\n                newSide.b.y - newSide.a.y,\n              ).heading;\n              while (\n                !(a.heading > b.heading\n                  ? (newSideHeading > a.heading\n                      && newSideHeading < 2 * Math.PI)\n                    || (newSideHeading > 0 && newSideHeading < b.heading)\n                  : newSideHeading > a.heading && newSideHeading < b.heading)\n                || intersectWithPoligon(newSide, pol, [\n                  (j - 1) % pol.length,\n                  j % pol.length,\n                  (k - 1) % pol.length,\n                  k % pol.length,\n                ])\n              ) {\n                k += 1;\n                newSide = new LineSegment(\n                  new Vec2(pol[j].x, pol[j].y),\n                  new Vec2(pol[k % pol.length].x, pol[k % pol.length].y),\n                );\n                newSideHeading = new Vec2(\n                  newSide.b.x - newSide.a.x,\n                  newSide.b.y - newSide.a.y,\n                ).heading;\n              }\n              const pol1 = [];\n              const pol2 = [];\n              for (let l = j; l <= k; l += 1) {\n                pol1.push(pol[l % pol.length]);\n              }\n              for (let l = k; l <= j + pol.length; l += 1) {\n                pol2.push(pol[l % pol.length]);\n              }\n              poligons[i] = pol1;\n              poligons.push(pol2);\n              continue checkAllPoligons;\n            }\n          }\n        }\n      }\n    }\n\n    for (let i = poligons.length - 1; i >= 0; i -= 1) {\n      const pol = poligons[i];\n      while (pol.length > 3) {\n        poligons.push([pol[0], pol[1], pol[2]]);\n        pol.splice(1, 1);\n      }\n    }\n\n    let mSum = 0;\n    poligons.forEach((pol) => {\n      const a = Math.sqrt(\n        ((pol[0].x - pol[1].x) ** 2) + ((pol[0].y - pol[1].y) ** 2),\n      );\n      const b = Math.sqrt(\n        ((pol[1].x - pol[2].x) ** 2) + ((pol[1].y - pol[2].y) ** 2),\n      );\n      const c = Math.sqrt(\n        ((pol[2].x - pol[0].x) ** 2) + ((pol[2].y - pol[0].y) ** 2),\n      );\n      const s = (a + b + c) / 2;\n      const m = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n      mSum += m;\n    });\n\n    const overPressure = softBall.pressure * ((softBall.r * softBall.r * Math.PI) / mSum)\n      - softBall.pressure;\n    softBall.sides.forEach((side) => {\n      const force = Vec2.sub(side.objects[0].pos, side.objects[1].pos);\n      force.mult(overPressure);\n      force.rotate(Math.PI / 2);\n      force.mult(t);\n      side.objects[0].vel.add(Vec2.div(force, side.objects[0].m));\n      side.objects[1].vel.add(Vec2.div(force, side.objects[1].m));\n    });\n  }\n\n  /**\n   * Returns an array containing all the sides of the body\n   *\n   * @returns {Array<LineSegment>} The array of sides\n   */\n  get sideSegments() {\n    return this.points.map((element, index) => new LineSegment(\n      element.pos,\n      this.points[(index + 1) % this.points.length].pos,\n    ));\n  }\n\n  /**\n   *Returns true if the point is inside the body\n   *\n   * @param {Vec2} p The point\n   * @returns {boolean} The boolean value\n   */\n  containsPoint(p) {\n    const sides = this.sideSegments;\n    const r = Math.max(\n      ...this.points.map((point) => Vec2.dist(point.pos, p)),\n    ) + 1;\n\n    const v = Vec2.fromAngle(0);\n    v.setMag(r);\n\n    const testerSegment = new LineSegment(p, Vec2.add(v, p));\n\n    const filt = sides.filter((side) => LineSegment.intersect(side, testerSegment) !== undefined);\n    return filt.length % 2 === 1;\n  }\n\n  /**\n   * @returns {SoftBallAsObject} The SoftBall represented in a JS object\n   * Ready to be converted into JSON\n   */\n  toJSObject() {\n    const ret = {};\n\n    ret.pressure = this.pressure;\n    ret.fc = this.fc;\n    ret.r = this.r;\n    ret.resolution = this.resolution;\n    ret.points = this.points.map((p) => p.id);\n    ret.sides = this.sides.map((s) => s.id);\n\n    return ret;\n  }\n\n  /**\n   * Creates a SoftBall class from the given object\n   *\n   * @param {SoftBallAsObject} obj The object to create the class from\n   * @param {Ball[]} ballList An array of all the balls in the system\n   * @param {Spring[]} springList An array of all the springs in the system\n   * @returns {SoftBall} The SoftBall object\n   */\n  static fromObject(obj, ballList, springList) {\n    const ret = Object.create(SoftBall.prototype);\n\n    ret.pressure = obj.pressure;\n    ret.fc = obj.fc;\n    ret.resolution = obj.resolution;\n    ret.r = obj.r;\n    ret.points = obj.points.map((e) => {\n      const arr = ballList.filter((p) => e === p.id);\n      return arr[0];\n    });\n    ret.sides = obj.sides.map((e) => {\n      const arr = springList.filter((p) => e === p.id);\n      return arr[0];\n    });\n\n    return ret;\n  }\n}\n\nexport default SoftBall;\n", "import Ball from './ball';\nimport Spring from './spring';\nimport Stick from './stick';\n\n/**\n * Creates either a spring or a stick\n *\n * @param {\"spring\"|\"stick\"} type Specifies the type of the new item\n * @param {number} length The length of the item\n * @param {number} springConstant The spring constant\n * @returns {Spring | Stick} Returns the item\n */\nfunction createStickOrSpring(type, length, springConstant) {\n  if (type === 'spring') {\n    return new Spring(length, springConstant);\n  }\n  if (type === 'stick') {\n    return new Stick(length);\n  }\n  return new Spring(0, 0);\n}\n\n/**\n * Creates a Spring class from the given object\n *\n * @param {import('./spring').SpringAsObject | import('./stick').StickAsObject} obj The\n * object to create the class from\n * @param {Ball[]} ballList An array of all the balls in the system\n * @returns {Spring | Stick} The Spring object\n */\nexport function stickOrSpringFromObject(obj, ballList) {\n  const ret = createStickOrSpring(obj.type,\n    obj.length, obj.springConstant);\n\n  ret.pinned = obj.pinned;\n  ret.rotationLocked = obj.rotationLocked;\n  ret.id = obj.id;\n\n  ret.objects = obj.objects.map((e) => {\n    const arr = ballList.filter((p) => e === p.id);\n    return arr[0];\n  });\n\n  return ret;\n}\n\n/**\n * @param {Stick | Spring} s The spring or the stick\n * @returns {import('./spring').SpringAsObject | import('./stick').StickAsObject} The\n * spring represented in a JS object.\n * Ready to be converted into JSON\n */\nexport function stickOrSpringToJSObject(s) {\n  /** @type {import('./spring').SpringAsObject | import('./stick').StickAsObject} */\n  const ret = {};\n\n  ret.length = s.length;\n  ret.springConstant = s.springConstant;\n  ret.pinned = s.pinned;\n  ret.rotationLocked = s.rotationLocked;\n  ret.id = s.id;\n  ret.objects = s.objects.map((o) => o.id);\n  if (s instanceof Spring) {\n    ret.type = 'spring';\n  }\n  if (s instanceof Stick) {\n    ret.type = 'stick';\n  }\n\n  return ret;\n}\n", "import Ball from './ball';\nimport LineSegment from './linesegment';\nimport Body from './body';\nimport Line from './line';\nimport Wall from './wall';\nimport Stick from './stick';\nimport Polygon from './polygon';\nimport Vec2 from './vec2';\nimport Spring from './spring';\nimport SoftBall from './softball';\nimport { stickOrSpringFromObject, stickOrSpringToJSObject } from './stickspringhelpers';\nimport { collisionResponseWithWall } from './collision';\n\n/**\n * @typedef {{x:number, y:number, r:number}} FixedBall\n */\n/**\n * @typedef {{x: number, y: number, pinPoint: boolean}} PinPoint\n */\n/**\n * @typedef {Ball | Body | Wall | FixedBall | SoftBall\n * | PinPoint | Spring | Stick} AnyPhysicsObject\n */\n/**\n * Any object that has mass and can be moved freely in the world,\n * aka a {@link Body} or a {@link Ball}.\n *\n * @typedef {Ball | Body} PhysicalObject\n */\n\n/**\n * A union type representing either a Stick or a Spring object.\n *\n * @typedef {(Spring|Stick)} StickOrSpring\n */\n/**\n * A union type representing either a StickAsObject or a SpringAsObject type.\n *\n * @typedef {import('./spring').SpringAsObject|import('./stick').StickAsObject}StickOrSpringAsObject\n */\n\n/**\n * An object representation of the Phyisics class\n * to easily convert it to JSON.\n *\n * @typedef PhysicsAsObject\n * @property {import('./ball').BallAsObject[]} balls The balls in the world\n * @property {import('./wall').WallAsObject[]} bounds The world border walls\n * @property {import('./wall').WallAsObject[]} walls The walls in the world\n * @property {import('./body').BodyAsObject[]} bodies The bodies in the world\n * @property {StickOrSpringAsObject[]} springs The\n * springs and sticks in the world\n * @property {import('./softball').SoftBallAsObject[]} softBalls The softballs in the world\n * @property {FixedBall[]} fixedBalls The fixedballs in the world\n * @property {number} airFriction The air friction in the world\n * @property {import('./vec2').Vec2AsObject} gravity The gravity vector as an object in the world\n */\n\n/**\n * Class that creates a new world with the physics engine.\n */\nclass Physics {\n  /**\n   * Create and initalize a new world.\n   */\n  constructor() {\n    /** @type {Ball[]} */\n    this.balls = [];\n    /** @type {Body[]} */\n    this.bodies = [];\n    /** @type {FixedBall[]} */\n    this.fixedBalls = [];\n    /** @type {SoftBall[]} */\n    this.softBalls = [];\n\n    /** @type {Wall[]} */\n    this.walls = [];\n    /** @type {Wall[]} */\n    this.bounds = [];\n\n    /** @type {StickOrSpring[]} */\n    this.springs = [];\n\n    // Air friction has to be between 0 and 1\n    // 0 - no movement\n    // 1 - no friction\n    this.airFriction = 1;\n\n    this.gravity = new Vec2(0, 0);\n\n    /** @type {boolean} */\n    this.addBodyNotBall = false;\n  }\n\n  /**\n   * Updates the world by a given amount of time\n   *\n   * @param {number} t Elapsed time\n   * @param {boolean} precise If this is true,\n   * then the simulation is going to be more precise\n   */\n  update(t, precise) {\n    // Do the simulation on the reversed system\n    // if the simulation is in precise mode\n    const clonedSystem = precise ? this.copy : new Physics();\n    if (precise) {\n      clonedSystem.bodies.reverse();\n      clonedSystem.balls.reverse();\n      clonedSystem.update(t, false);\n    }\n\n    // At first move objets\n    for (let i = 0; i < this.balls.length; i += 1) {\n      // Move\n      this.balls[i].lastPos = this.balls[i].pos.copy;\n      this.balls[i].pos.add(Vec2.mult(this.balls[i].vel, t));\n\n      // Angular velocity\n      this.balls[i].rotation += this.balls[i].ang * t;\n      this.balls[i].rotation %= Math.PI * 2;\n    }\n    for (let i = 0; i < this.bodies.length; i += 1) {\n      this.bodies[i].lastPos = this.bodies[i].pos.copy;\n      this.bodies[i].move(this.bodies[i].vel.x * t, this.bodies[i].vel.y * t);\n      this.bodies[i].rotate(this.bodies[i].ang * t);\n    }\n\n    // Update springs multiple times\n    for (let i = 0; i < 3; i += 1) {\n      this.springs.forEach((element) => {\n        element.update(t / 3 / 2);\n      });\n    }\n\n    for (let i = 0; i < this.balls.length; i += 1) {\n      // Apply gravity\n      if (this.gravity) {\n        this.balls[i].vel.add(new Vec2(this.gravity.x * t, this.gravity.y * t));\n      }\n\n      // Collision\n      for (let j = i + 1; j < this.balls.length; j += 1) {\n        if (\n          this.balls[i].layer !== this.balls[j].layer\n          || (!this.balls[i].layer && !this.balls[j].layer)\n        ) {\n          Ball.collide(this.balls[i], this.balls[j]);\n        }\n      }\n\n      // Collision with walls\n      this.walls.forEach((wall) => {\n        wall.collideWithBall(this.balls[i]);\n      });\n\n      // Collision with fixed balls\n      this.fixedBalls.forEach((b) => {\n        const ball = this.balls[i];\n\n        const p = Vec2.sub(ball.pos, b);\n        if (p.sqlength <= (ball.r + b.r) ** 2) {\n          // const cp = Vec2.fromObject(b);\n          const n = p;\n          n.setMag(1);\n          ball.pos = Vec2.add(b, Vec2.mult(n, ball.r + b.r));\n          n.mult(-1);\n          collisionResponseWithWall(ball, b, n);\n        }\n      });\n\n      // Bounce off the edges\n      this.bounds.forEach((bound) => {\n        bound.collideWithBall(this.balls[i]);\n      });\n    }\n\n    for (let i = 0; i < this.bodies.length; i += 1) {\n      this.balls.forEach((ball) => {\n        this.bodies[i].collideWithBall(ball);\n      });\n\n      for (let j = i + 1; j < this.bodies.length; j += 1) {\n        Body.collide(this.bodies[i], this.bodies[j]);\n      }\n\n      // Body vs fixedBall collisions\n      this.bodies.forEach((body) => {\n        this.fixedBalls.forEach((fixedBall) => {\n          body.collideWithFixedBall(fixedBall);\n        });\n      });\n\n      // Body vs wall collisions\n      this.bodies.forEach((body) => {\n        this.walls.forEach((wall) => {\n          body.collideWithWall(wall);\n        });\n      });\n\n      // Body vs world boundary collision\n      this.bodies.forEach((body) => {\n        this.bounds.forEach((bound) => {\n          body.collideWithWall(bound);\n        });\n      });\n\n      // Apply gravity\n      if (this.gravity) {\n        this.bodies[i].vel.add(\n          new Vec2(this.gravity.x * t, this.gravity.y * t),\n        );\n      }\n    }\n\n    // Update soft balls\n    this.softBalls.forEach((sb) => {\n      SoftBall.updatePressureBasedForces(sb, t);\n    });\n\n    // Update springs again multiple times\n    for (let i = 0; i < 3; i += 1) {\n      this.springs.forEach((spring) => {\n        spring.update(t / 3 / 2);\n      });\n    }\n\n    // Apply air friction\n    this.balls.forEach((b) => {\n      const ball = b;\n      ball.vel.mult((this.airFriction ** t));\n      ball.ang *= (this.airFriction ** t);\n    });\n    this.bodies.forEach((b) => {\n      const ball = b;\n      ball.vel.mult((this.airFriction ** t));\n      ball.ang *= (this.airFriction ** t);\n    });\n\n    // Then take the average of this system and the other system\n    // if in precise mode\n    if (precise) {\n      clonedSystem.bodies.reverse();\n      clonedSystem.balls.reverse();\n\n      // Take the average of the balls\n      this.balls.forEach((ball, i) => {\n        ball.move(\n          (clonedSystem.balls[i].pos.x - ball.pos.x) * 0.5,\n          (clonedSystem.balls[i].pos.y - ball.pos.y) * 0.5,\n        );\n        ball.vel.add(\n          new Vec2(\n            (clonedSystem.balls[i].vel.x - ball.vel.x) * 0.5,\n            (clonedSystem.balls[i].vel.y - ball.vel.y) * 0.5,\n          ),\n        );\n        const b = ball;\n        b.rotation = (ball.rotation + clonedSystem.balls[i].rotation) / 2;\n        b.ang = (ball.ang + clonedSystem.balls[i].ang) / 2;\n      });\n\n      // Take the average of the bodies\n      this.bodies.forEach((body, i) => {\n        const other = clonedSystem.bodies[i];\n        body.move(\n          (other.pos.x - body.pos.x) * 0.5,\n          (other.pos.y - body.pos.y) * 0.5,\n        );\n        body.vel.add(\n          new Vec2(\n            (other.vel.x - body.vel.x) * 0.5,\n            (other.vel.y - body.vel.y) * 0.5,\n          ),\n        );\n        body.rotate((other.rotation - body.rotation) / 2);\n        const b = body;\n        b.ang = (body.ang + other.ang) / 2;\n      });\n    }\n  }\n\n  /**\n   * Returns a copy of this system\n   *\n   * @returns {Physics} The copy of this system\n   */\n  get copy() {\n    const ret = new Physics();\n    ret.balls = this.getCopyOfBalls();\n    ret.bodies = this.getCopyOfBodies();\n    ret.fixedBalls = this.fixedBalls;\n    ret.walls = this.walls;\n    ret.bounds = this.bounds;\n    ret.gravity = this.gravity;\n\n    this.springs.forEach((spring) => {\n      const TypeOfSpring = spring instanceof Spring ? Spring : Stick;\n      /** @type {Spring | Stick} */\n      const copiedSpring = new TypeOfSpring(spring.length, spring.springConstant);\n      copiedSpring.rotationLocked = spring.rotationLocked;\n      copiedSpring.pinned = spring.pinned;\n\n      spring.objects.forEach((obj) => {\n        let idx = -1;\n        if (obj instanceof Ball) idx = this.balls.indexOf(obj);\n        if (idx !== -1) copiedSpring.attachObject(ret.balls[idx]);\n        else {\n          idx = -1;\n          if (obj instanceof Body) idx = this.bodies.indexOf(obj);\n          if (idx !== -1) copiedSpring.attachObject(ret.bodies[idx]);\n        }\n      });\n\n      ret.springs.push(copiedSpring);\n    });\n\n    return ret;\n  }\n\n  /**\n   * Air friction. has to be between 0 and 1\n   * 0 - no movement\n   * 1 - no friction\n   *\n   * @param {number} airFriction Has to be between 0 and 1\n   */\n  setAirFriction(airFriction) {\n    if (!Number.isFinite(airFriction)) return;\n    this.airFriction = airFriction;\n    if (this.airFriction < 0) this.airFriction = 0;\n    if (this.airFriction > 1) this.airFriction = 1;\n  }\n\n  /**\n   * Sets the gravity in the world\n   *\n   * @param {Vec2} dir The acceleration vector of the gravity\n   */\n  setGravity(dir) {\n    this.gravity = dir.copy;\n  }\n\n  /**\n   * Appends a new ball to the world\n   *\n   * @param {Ball} ball Ball to add to the world\n   */\n  addBall(ball) {\n    if (this.addBodyNotBall) {\n      /**\n       * Creates a ball shape from a polygon\n       *\n       * @param {Vec2} pos Position\n       * @param {number} r Radius\n       * @param {number} resolution Resolution\n       * @returns {Vec2[]} Points\n       */\n      const getPointsForBall = (pos, r, resolution) => {\n        const points = [];\n\n        for (let i = 0; i < resolution; i += 1) {\n          const newPoint = Vec2.fromAngle((i / resolution) * 2 * Math.PI);\n          newPoint.mult(r);\n          newPoint.add(pos);\n          points.push(newPoint);\n        }\n\n        return points;\n      };\n\n      this.bodies.push(\n        new Body(\n          getPointsForBall(ball.pos, ball.r, 24),\n          ball.vel,\n          ball.k,\n          ball.ang,\n          ball.fc,\n        ),\n      );\n    } else {\n      this.balls.push(ball);\n    }\n  }\n\n  /**\n   * Appends a new body to the world\n   *\n   * @param {Body} body Body to add to the world\n   */\n  addBody(body) {\n    this.bodies.push(body);\n  }\n\n  /**\n   * Appends a new soft ball to the world\n   *\n   * @param {SoftBall} softBall SoftBall to be added to the world\n   */\n  addSoftBall(softBall) {\n    this.balls.push(...softBall.points);\n    this.springs.push(...softBall.sides);\n\n    this.softBalls.push(softBall);\n  }\n\n  /**\n   * Appends a new soft square to the world\n   *\n   * @param {Vec2} pos The position of the soft square\n   * @param {number} sideSize The size of the square\n   * @param {number} fc Friction coefficient\n   * @param {Vec2} vel The initial velocity of the soft square\n   * @param {number} resolution The resolution of the soft square\n   * @param {number} pressure The 'pressure' of the soft square\n   */\n  addSoftSquare(pos, sideSize, fc, vel, resolution = 24, pressure = 1) {\n    const softSquare = new SoftBall(\n      pos,\n      Math.sqrt((sideSize * sideSize) / Math.PI),\n      pressure,\n      fc,\n      resolution,\n    );\n    softSquare.sides.forEach((side) => {\n      const s = side;\n      s.length = (0.96 * 4 * sideSize) / softSquare.resolution;\n    });\n    softSquare.points.forEach((ball) => {\n      const b = ball;\n      b.vel = vel.copy;\n    });\n\n    this.balls.push(...softSquare.points);\n    this.springs.push(...softSquare.sides);\n\n    const springStrength = sideSize * sideSize * 200 * pressure;\n\n    let bigStick = new Spring(\n      Math.sqrt(softSquare.r * softSquare.r * Math.PI),\n      springStrength / 2,\n    );\n    bigStick.attachObject(softSquare.points[0]);\n    bigStick.attachObject(softSquare.points[softSquare.resolution / 2]);\n    this.springs.push(bigStick);\n\n    bigStick = new Spring(\n      Math.sqrt(softSquare.r * softSquare.r * Math.PI),\n      springStrength / 2,\n    );\n    bigStick.attachObject(softSquare.points[softSquare.resolution / 4]);\n    bigStick.attachObject(softSquare.points[(3 * softSquare.resolution) / 4]);\n    this.springs.push(bigStick);\n\n    bigStick = new Spring(\n      Math.sqrt(2 * softSquare.r * softSquare.r * Math.PI),\n      springStrength,\n    );\n    bigStick.attachObject(softSquare.points[softSquare.resolution / 8]);\n    bigStick.attachObject(softSquare.points[(5 * softSquare.resolution) / 8]);\n    this.springs.push(bigStick);\n\n    bigStick = new Spring(\n      Math.sqrt(2 * softSquare.r * softSquare.r * Math.PI),\n      springStrength,\n    );\n    bigStick.attachObject(softSquare.points[(3 * softSquare.resolution) / 8]);\n    bigStick.attachObject(softSquare.points[(7 * softSquare.resolution) / 8]);\n    this.springs.push(bigStick);\n  }\n\n  /**\n   * Appends a rectangular wall to the world\n   *\n   * @param {number} x x coordinate of the rectangular wall\n   * @param {number} y y coordinate of the rectangular wall\n   * @param {number} w width of the rectangular wall\n   * @param {number} h height of the rectangular wall\n   */\n  addRectWall(x, y, w, h) {\n    const points = [];\n    points.push(new Vec2(x - w / 2, y - h / 2));\n    points.push(new Vec2(x + w / 2, y - h / 2));\n    points.push(new Vec2(x + w / 2, y + h / 2));\n    points.push(new Vec2(x - w / 2, y + h / 2));\n    this.walls.push(new Wall(points));\n  }\n\n  /**\n   * Appends a rectangular body to the world\n   *\n   * @param {number} x x coordinate of the rectangular body\n   * @param {number} y y coordinate of the rectangular body\n   * @param {number} w width of the rectangular body\n   * @param {number} h height of the rectangular body\n   * @param {number} fc friction coefficient of the body\n   * @param {number} k coefficient of restitution of the body\n   */\n  addRectBody(x, y, w, h, fc, k) {\n    const points = [];\n    points.push(new Vec2(x - w / 2, y - h / 2));\n    points.push(new Vec2(x + w / 2, y - h / 2));\n    points.push(new Vec2(x + w / 2, y + h / 2));\n    points.push(new Vec2(x - w / 2, y + h / 2));\n    this.bodies.push(new Body(points, new Vec2(0, 0), k, 0, fc));\n  }\n\n  /**\n   * Append a new wall to the world\n   *\n   * @param {Wall} wall Wall to append to the world\n   */\n  addWall(wall) {\n    this.walls.push(wall);\n  }\n\n  /**\n   * Appends a fixed ball to the world\n   * A fixed ball is immovable and other objects collide with it\n   *\n   * @param {number} x x coordinate of the fixed ball\n   * @param {number} y y coordinate of the fixed ball\n   * @param {number} r radius of the fixed ball\n   */\n  addFixedBall(x, y, r) {\n    this.fixedBalls.push({\n      x,\n      y,\n      r,\n    });\n  }\n\n  /**\n   * Appends a new spring to the world\n   *\n   * @param {Spring} spring Spring to add to the world\n   */\n  addSpring(spring) {\n    this.springs.push(spring);\n  }\n\n  /**\n   * Sets the size of the world (without this the world\n   * does not have bounds)\n   *\n   * @param {number} x x coordinate of the centre of the world\n   * @param {number} y y coordinate of the centre of the world\n   * @param {number} w Width of the world\n   * @param {number} h Height of the world\n   */\n  setBounds(x, y, w, h) {\n    this.bounds = [];\n\n    /**\n     * Creates a rectangle wall.\n     *\n     * @param {number} x_ The x coordinate\n     * @param {number} y_ The y coordinate\n     * @param {number} w_ The width\n     * @param {number} h_ The height\n     * @returns {Wall} The wall\n     */\n    const getRectBody = (x_, y_, w_, h_) => {\n      const points = [];\n      points.push(new Vec2(x_ - w_ / 2, y_ - h_ / 2));\n      points.push(new Vec2(x_ + w_ / 2, y_ - h_ / 2));\n      points.push(new Vec2(x_ + w_ / 2, y_ + h_ / 2));\n      points.push(new Vec2(x_ - w_ / 2, y_ + h_ / 2));\n      return new Wall(points);\n    };\n\n    this.bounds.push(getRectBody(x - w, y, 2 * w, 4 * h));\n    this.bounds.push(getRectBody(x + 2 * w, y, 2 * w, 4 * h));\n    this.bounds.push(getRectBody(x, y - h, 4 * w, h * 2));\n    this.bounds.push(getRectBody(x, y + 2 * h, 4 * w, 2 * h));\n  }\n\n  /**\n   * Search for any object at the given coordinate then returns it\n   * Return false if nothing is found\n   *\n   * @param {number} x x coordinate\n   * @param {number} y y coordinate\n   * @returns {AnyPhysicsObject} The found object\n   */\n  getObjectAtCoordinates(x, y) {\n    /** @type {AnyPhysicsObject} */\n    let ret = {\n      x, y, pinPoint: true,\n    };\n    const v = new Vec2(x, y);\n    this.balls.forEach((ball) => {\n      if (ball.containsPoint(v)) ret = ball;\n    });\n    this.bodies.forEach((body) => {\n      if (body.containsPoint(v)) ret = body;\n    });\n    this.walls.forEach((wall) => {\n      if (wall.containsPoint(v)) ret = wall;\n    });\n    this.fixedBalls.forEach((e) => {\n      if (Vec2.dist(new Vec2(e.x, e.y), new Vec2(x, y)) <= e.r) ret = e;\n    });\n    this.softBalls.forEach((softBall) => {\n      if (softBall.containsPoint(v)) ret = softBall;\n    });\n    return ret;\n  }\n\n  /**\n   * Returns an array of copies of all balls in the system\n   *\n   * @returns {Ball[]} The array of the copied balls\n   */\n  getCopyOfBalls() {\n    return this.balls.map((b) => b.copy);\n  }\n\n  /**\n   * Returns an array of copies of all bodies in the system\n   *\n   * @returns {Body[]} The array of the copied bodies\n   */\n  getCopyOfBodies() {\n    return this.bodies.map((b) => b.copy);\n  }\n\n  /**\n   * Removes the given object from the system\n   *\n   * @param {AnyPhysicsObject} obj The object to remove\n   */\n  removeObjFromSystem(obj) {\n    let idx = -1;\n    if (obj instanceof Ball) idx = this.balls.indexOf(obj);\n    if (idx !== -1) {\n      let toReturn = false;\n      this.softBalls.forEach((s) => {\n        if (s.points.includes(this.balls[idx])) {\n          this.removeObjFromSystem(s);\n          toReturn = true;\n        }\n      });\n      if (toReturn) return;\n      this.springs.forEach((s) => {\n        if (s.objects.includes(this.balls[idx])) this.removeObjFromSystem(s);\n      });\n      this.balls.splice(idx, 1);\n      return;\n    }\n    if (obj instanceof Body) idx = this.bodies.indexOf(obj);\n    if (idx !== -1) {\n      this.bodies.splice(idx, 1);\n      return;\n    }\n    if (obj instanceof Wall) idx = this.walls.indexOf(obj);\n    if (idx !== -1) {\n      this.walls.splice(idx, 1);\n      return;\n    }\n    if (obj instanceof Object && 'r' in obj && 'x' in obj) { idx = this.fixedBalls.indexOf(obj); }\n    if (idx !== -1) {\n      this.fixedBalls.splice(idx, 1);\n      return;\n    }\n    if (obj instanceof Stick || obj instanceof Spring) idx = this.springs.indexOf(obj);\n    if (idx !== -1) {\n      this.springs.splice(idx, 1);\n      const invesigated = this.springs[idx];\n      this.softBalls.forEach((s) => {\n        if (invesigated instanceof Stick && s.sides.includes(invesigated)) {\n          this.removeObjFromSystem(s);\n        }\n      });\n      return;\n    }\n    if (obj instanceof SoftBall) idx = this.softBalls.indexOf(obj);\n    if (idx !== -1) {\n      const sf = this.softBalls[idx];\n      this.softBalls.splice(idx, 1);\n      sf.points.forEach((p) => {\n        this.removeObjFromSystem(p);\n      });\n    }\n  }\n\n  /**\n   * Finds the ball or body with the given id\n   *\n   * @param {string} id The id of the object to find\n   * @returns {{type:(\"ball\"|\"body\"|\"spring\"|\"\"), num:number}} The data of the object\n   */\n  getItemDataFromId(id) {\n    /**\n     * Checks the ID of an element.\n     *\n     * @param {Ball|Body|Spring|Stick} b Entity with ID\n     * @returns {boolean} Tells if it checks.\n     */\n    const filter = (b) => b.id === id;\n\n    const balls = this.balls.filter(filter);\n    if (balls.length >= 1) {\n      return { type: 'ball', num: this.balls.indexOf(balls[0]) };\n    }\n\n    const bodies = this.bodies.filter(filter);\n    if (bodies.length >= 1) {\n      return { type: 'body', num: this.bodies.indexOf(bodies[0]) };\n    }\n\n    const springs = this.springs.filter(filter);\n    if (springs.length >= 1) {\n      return { type: 'spring', num: this.springs.indexOf(springs[0]) };\n    }\n\n    return { type: '', num: -1 };\n  }\n\n  /**\n   * @returns {PhysicsAsObject} The physics world represented in a JS object\n   * Ready to be converted into JSON\n   */\n  toJSObject() {\n    const ret = {};\n\n    ret.balls = this.balls.map((b) => b.toJSObject());\n    ret.bounds = this.bounds.map((w) => w.toJSObject());\n    ret.walls = this.walls.map((w) => w.toJSObject());\n    ret.bodies = this.bodies.map((b) => b.toJSObject());\n    ret.springs = this.springs.map((s) => stickOrSpringToJSObject(s));\n    ret.softBalls = this.softBalls.map((s) => s.toJSObject());\n\n    ret.fixedBalls = this.fixedBalls;\n    ret.airFriction = this.airFriction;\n    ret.gravity = this.gravity.toJSObject();\n\n    return ret;\n  }\n\n  /**\n   * Creates a Physics class from the given object\n   *\n   * @param {PhysicsAsObject} obj The object to create the class from\n   * @returns {Physics} The Physics object\n   */\n  static fromObject(obj) {\n    const newWorld = new Physics();\n\n    newWorld.balls = obj.balls.map((b) => Ball.fromObject(b));\n    newWorld.bounds = obj.bounds.map((b) => Wall.fromObject(b));\n    newWorld.walls = obj.walls.map((w) => Wall.fromObject(w));\n    newWorld.bodies = obj.bodies.map((b) => Body.fromObject(b));\n    newWorld.springs = obj.springs.map((s) => stickOrSpringFromObject(s, newWorld.balls));\n    newWorld.softBalls = obj.softBalls.map((s) => SoftBall.fromObject(s,\n      newWorld.balls, newWorld.springs));\n\n    newWorld.fixedBalls = obj.fixedBalls;\n    newWorld.airFriction = obj.airFriction;\n    newWorld.gravity = Vec2.fromObject(obj.gravity);\n\n    return newWorld;\n  }\n\n  /**\n   * @returns {string} The physics object in JSON format in a string\n   */\n  toJSON() {\n    return JSON.stringify(this.toJSObject());\n  }\n\n  /**\n   * Recreates the phyisics object from JSON\n   *\n   * @param {string} jsonString The JSON containing the physics object\n   * @returns {Physics} The created Physics object\n   */\n  static fromJSON(jsonString) {\n    return Physics.fromObject(JSON.parse(jsonString));\n  }\n}\n\nexport {\n  Ball, Body, Vec2, LineSegment, Spring, Stick, SoftBall, Line, Polygon, Wall,\n};\nexport default Physics;\n", "import Physics, { PhysicsAsObject } from '../../src/physics';\n\nlet startingState: PhysicsAsObject;\nlet inStartingState: boolean;\n\ninterface HasPhysicsAndTime {\n  getPhysics(): Physics,\n  setPhysics(physics: Physics): void,\n  getTimeMultiplier(): number,\n  setTimeMultiplier(m: number): void\n}\n\n/**\n * Sets event listeners for controlling the time in the Physics object of the editor\n *\n * @see Physics\n *\n * @param {HasPhysicsAndTime} editorApp The editor app to control\n */\nexport default function timeController(editorApp: HasPhysicsAndTime): void {\n  startingState = editorApp.getPhysics().toJSObject();\n  inStartingState = true;\n\n  const pauseBtn = document.getElementById('pause');\n  if (pauseBtn) {\n    pauseBtn.onclick = () => {\n      if (editorApp.getTimeMultiplier() !== 0) editorApp.setTimeMultiplier(0);\n      else {\n        editorApp.setTimeMultiplier(1);\n        if (inStartingState === true) {\n          startingState = editorApp.getPhysics().toJSObject();\n        }\n        inStartingState = false;\n      }\n    };\n  }\n\n  const revertBtn = document.getElementById('revert');\n  if (revertBtn) {\n    revertBtn.onclick = () => {\n      editorApp.setTimeMultiplier(0);\n      editorApp.setPhysics(Physics.fromObject(startingState));\n      inStartingState = true;\n    };\n  }\n\n  const clearBtn = document.getElementById('clear all');\n  if (clearBtn) {\n    clearBtn.onclick = () => {\n      inStartingState = true;\n\n      const physics = editorApp.getPhysics();\n      physics.balls = [];\n      physics.walls = [];\n      physics.softBalls = [];\n      physics.springs = [];\n      physics.bodies = [];\n    };\n  }\n\n  const startBtn = document.getElementById('set start');\n  if (startBtn) {\n    startBtn.onclick = () => {\n      startingState = editorApp.getPhysics().toJSObject();\n      inStartingState = true;\n      editorApp.setTimeMultiplier(0);\n    };\n  }\n}\n", "type EventHandlerFunction = (event: Event) => void;\n\n/**\n * Returns an HTML element with the title in it for putting it on top of the sidebar\n *\n * @param {string} title The text of the title\n * @returns {HTMLDivElement} The created element\n */\nexport function createModeTitle(title: string): HTMLDivElement {\n  const el = document.createElement('div');\n  const h = document.createElement('h3');\n  h.innerText = title;\n  h.classList.add('modetitlemargin');\n  el.appendChild(h);\n  el.classList.add('mode-title');\n  el.classList.add('bg-blue');\n  return el;\n}\n\n/**\n * Returns an HTML element with the label in with a slider\n * The given function gets called when the slider changes by the user\n *\n * @param {string} label The label over the slider\n * @param {number} min The minimum value of the slider input\n * @param {number} max The maximum value of the slider input\n * @param {number} defaultVal The initial value of the slider\n * @param {EventHandlerFunction} onchange The event handler function\n * @param {number} step The stepping size of the slider (optional)\n * @returns {HTMLDivElement} The div containing the slider and the label\n */\nexport function createSlider(\n  label: string, min: number, max: number, defaultVal: number,\n  onchange: EventHandlerFunction, step = 1,\n): HTMLDivElement {\n  // Create label\n  const sizeSliderLabel = document.createElement('p');\n  sizeSliderLabel.innerText = label;\n\n  // Create slider element\n  const sizeSlider = document.createElement('input');\n  sizeSlider.type = 'range';\n  sizeSlider.min = min.toString();\n  sizeSlider.max = max.toString();\n  sizeSlider.step = step.toString();\n  sizeSlider.value = defaultVal.toString();\n  sizeSlider.classList.add('slider');\n  sizeSlider.classList.add('fix-width');\n  sizeSlider.onchange = onchange;\n\n  // Add them both to the container\n  const container = document.createElement('div');\n  container.appendChild(sizeSliderLabel);\n  container.appendChild(sizeSlider);\n  return container;\n}\n\n/**\n * Returns an HTML element with a label in with a checkbox\n * The given function gets called when the checkox gets checked or unchecked\n *\n * @param {string} label The label next to the checkbox\n * @param {boolean} defaultVal The initial state of the checkbox\n * @param {EventHandlerFunction} onchange The event handler function\n * @returns {HTMLDivElement} The div containing the checkbox and the label\n */\nexport function createCheckbox(\n  label: string, defaultVal: boolean, onchange: (event: Event) => void,\n): HTMLDivElement {\n  // Create label\n  const name = label + Math.random().toString();\n  const checkboxLabel = document.createElement('label');\n  checkboxLabel.innerText = label;\n  checkboxLabel.htmlFor = name;\n  checkboxLabel.classList.add('checkbox-label');\n\n  // Create slider element\n  const checkbox = document.createElement('input');\n  checkbox.type = 'checkbox';\n  checkbox.name = name;\n  checkbox.value = defaultVal.toString();\n  checkbox.classList.add('ch-box');\n  checkbox.onchange = onchange;\n\n  // Add them both to the container\n  const container = document.createElement('div');\n  container.appendChild(checkbox);\n  container.appendChild(checkboxLabel);\n  return container;\n}\n", "/* eslint-disable @typescript-eslint/no-empty-function */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport Mode from '../modeInterface';\nimport { Ball, Vec2 } from '../../../src/physics';\nimport * as Creator from '../elementCreator';\nimport EditorInterface from '../editorInterface';\n\nlet size = 35;\nlet k = 0.5;\nlet fc = 1.5;\nconst element = document.createElement('div');\n\n/**\n * This mode is for placing down balls in the world\n */\nconst BallCreatorMode: Mode = {\n  name: 'Ball creator',\n  description: '',\n  element,\n  drawFunc(editorApp: EditorInterface, _dt: number) {\n    const ctx = <CanvasRenderingContext2D>editorApp.cnv.getContext('2d');\n    ctx.strokeStyle = 'black';\n\n    ctx.beginPath();\n    ctx.arc(editorApp.mouseX, editorApp.mouseY,\n      size, 0, 2 * Math.PI);\n    ctx.stroke();\n\n    if (editorApp.lastX !== 0 && editorApp.lastY !== 0) {\n      ctx.beginPath();\n      ctx.moveTo(editorApp.mouseX, editorApp.mouseY);\n      ctx.lineTo(editorApp.lastX, editorApp.lastY);\n      ctx.stroke();\n    }\n  },\n  startInteractionFunc(editorApp) { },\n  endInteractionFunc(editorApp) {\n    if (editorApp.lastX !== 0 && editorApp.lastY !== 0) {\n      const newBall = new Ball(\n        new Vec2(editorApp.lastX, editorApp.lastY),\n        new Vec2(editorApp.lastX - editorApp.mouseX,\n          editorApp.lastY - editorApp.mouseY),\n        size, k, 0, fc,\n      );\n      if (\n        Number.isFinite(newBall.pos.x)\n        && Number.isFinite(newBall.pos.y)\n        && Number.isFinite(newBall.vel.x)\n        && Number.isFinite(newBall.vel.y)\n      ) {\n        editorApp.physics.addBall(newBall);\n      } else {\n        newBall.vel.x = 0;\n        newBall.vel.y = 0;\n        editorApp.physics.addBall(newBall);\n      }\n    }\n  },\n  keyGotUpFunc(editorApp) { },\n  keyGotDownFunc(editorApp) { },\n};\n\n[\n  Creator.createModeTitle(BallCreatorMode.name),\n  Creator.createSlider('Size', 5, 120, size, (event) => {\n    size = (<HTMLInputElement>event.target).valueAsNumber;\n  }),\n  Creator.createSlider('Bounciness', 0, 1, k, (event) => {\n    k = (<HTMLInputElement>event.target).valueAsNumber;\n  }, 0.02),\n  Creator.createSlider('Coefficient of friction', 0, 2, fc, (event) => {\n    fc = (<HTMLInputElement>event.target).valueAsNumber;\n  }, 0.1),\n].forEach(element.appendChild.bind(element));\n\nexport default BallCreatorMode;\n", "/* eslint-disable @typescript-eslint/no-empty-function */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport Mode from '../modeInterface';\nimport * as Creator from '../elementCreator';\n\nconst element = document.createElement('div');\n\nconst DeleteMode: Mode = {\n  name: 'Delete',\n  description: '',\n  element,\n  drawFunc(editorApp, dt) { },\n  startInteractionFunc(editorApp) {\n    if (editorApp.choosed) {\n      editorApp.physics.removeObjFromSystem(editorApp.choosed);\n    }\n  },\n  endInteractionFunc(editorApp) { },\n  keyGotUpFunc(editorApp) { },\n  keyGotDownFunc(editorApp) { },\n};\n\n[\n  Creator.createModeTitle(DeleteMode.name),\n].forEach(element.appendChild.bind(element));\n\nexport default DeleteMode;", "/* eslint-disable @typescript-eslint/no-empty-function */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport Mode from '../modeInterface';\nimport { Ball, SoftBall, Vec2 } from '../../../src/physics';\nimport * as Creator from '../elementCreator';\nimport EditorInterface from '../editorInterface';\n\nlet size = 35;\nconst k = 0.5;\nlet fc = 1.5;\nlet resolution = 24;\nlet pressure = 1000000;\nconst element = document.createElement('div');\n\nconst ElasticBallCreatorMode: Mode = {\n  name: 'Elastic ball creator',\n  description: '',\n  element,\n  drawFunc(editorApp: EditorInterface, dt: number): void {\n    const ctx = <CanvasRenderingContext2D>editorApp.cnv.getContext('2d');\n    ctx.strokeStyle = 'black';\n\n    ctx.beginPath();\n    ctx.arc(editorApp.mouseX, editorApp.mouseY, size, 0, 2 * Math.PI);\n    ctx.stroke();\n\n    if (editorApp.lastX !== 0 && editorApp.lastY !== 0) {\n      ctx.beginPath();\n      ctx.moveTo(editorApp.mouseX, editorApp.mouseY);\n      ctx.lineTo(editorApp.lastX, editorApp.lastY);\n      ctx.stroke();\n    }\n  },\n  startInteractionFunc(editorApp) { },\n  endInteractionFunc(editorApp) {\n    if (editorApp.lastX !== 0 && editorApp.lastY !== 0) {\n      const newBall = new Ball(\n        new Vec2(editorApp.lastX, editorApp.lastY),\n        new Vec2(editorApp.lastX - editorApp.mouseX,\n          editorApp.lastY - editorApp.mouseY), size, k, 0, fc,\n      );\n      if (\n        Number.isFinite(newBall.pos.x)\n        && Number.isFinite(newBall.pos.y)\n        && Number.isFinite(newBall.vel.x)\n        && Number.isFinite(newBall.vel.y)\n      ) {\n        const sb = new SoftBall(\n          newBall.pos, size, pressure, fc, resolution,\n        );\n        sb.points.forEach((p) => {\n          const point = p;\n          point.vel = newBall.vel.copy;\n        });\n        editorApp.physics.addSoftBall(sb);\n      }\n    }\n  },\n  keyGotUpFunc(editorApp) { },\n  keyGotDownFunc(editorApp) { },\n};\n\n[\n  Creator.createModeTitle(ElasticBallCreatorMode.name),\n  Creator.createSlider('Size', 5, 60, size, (event) => {\n    size = (<HTMLInputElement>event.target).valueAsNumber;\n  }),\n  Creator.createSlider('Pressure', 500000, 3000000, pressure, (event) => {\n    pressure = (<HTMLInputElement>event.target).valueAsNumber;\n  }, 4000),\n  Creator.createSlider('Coefficient of friction', 0, 2, fc, (event) => {\n    fc = (<HTMLInputElement>event.target).valueAsNumber;\n  }, 0.1),\n  Creator.createSlider('Resolution', 6, 24, resolution, (event) => {\n    resolution = (<HTMLInputElement>event.target).valueAsNumber;\n  }, 1),\n].forEach(element.appendChild.bind(element));\n\nexport default ElasticBallCreatorMode;\n", "/* eslint-disable @typescript-eslint/no-empty-function */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport Mode from '../modeInterface';\nimport * as Creator from '../elementCreator';\n\nlet pmouseX = 0;\nlet pmouseY = 0;\n\nconst element = document.createElement('div');\n\nconst MoveMode: Mode = {\n  name: 'Move',\n  description: '',\n  element,\n  drawFunc(editorApp, dt) {\n    const { choosed } = editorApp;\n    if (choosed instanceof Object && 'move' in choosed) {\n      choosed.move(\n        editorApp.mouseX - choosed.pos.x,\n        editorApp.mouseY - choosed.pos.y,\n      );\n      if (dt === 0) {\n        choosed.vel.x = 0;\n        choosed.vel.y = 0;\n      } else {\n        choosed.vel.x = (editorApp.mouseX - pmouseX) / dt;\n        choosed.vel.y = (editorApp.mouseY - pmouseY) / dt;\n      }\n      choosed.ang = 0;\n    }\n    pmouseX = editorApp.mouseX;\n    pmouseY = editorApp.mouseY;\n  },\n  startInteractionFunc(editorApp) { },\n  endInteractionFunc(editorApp) { },\n  keyGotUpFunc(editorApp) { },\n  keyGotDownFunc(editorApp) { },\n};\n\n[\n  Creator.createModeTitle(MoveMode.name),\n].forEach(element.appendChild.bind(element));\n\nexport default MoveMode;\n", "/* eslint-disable @typescript-eslint/no-empty-function */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport Mode from '../modeInterface';\nimport * as Creator from '../elementCreator';\n\nconst element = document.createElement('div');\n\nconst RectangleMode: Mode = {\n  name: 'Rectangle wall',\n  description: '',\n  element,\n  drawFunc(editorApp, dt) {\n    if (editorApp.lastX !== 0 && editorApp.lastY !== 0) {\n      const ctx = <CanvasRenderingContext2D>editorApp.cnv.getContext('2d');\n      ctx.strokeStyle = 'black';\n      ctx.strokeRect(editorApp.mouseX, editorApp.mouseY,\n        editorApp.lastX - editorApp.mouseX, editorApp.lastY - editorApp.mouseY);\n    }\n  },\n  startInteractionFunc(editorApp) { },\n  endInteractionFunc(editorApp) {\n    if (editorApp.lastX !== 0 && editorApp.lastY !== 0) {\n      editorApp.physics.addRectWall(\n        editorApp.lastX / 2 + editorApp.mouseX / 2,\n        editorApp.lastY / 2 + editorApp.mouseY / 2,\n        2 * Math.abs(editorApp.lastX / 2 - editorApp.mouseX / 2),\n        2 * Math.abs(editorApp.lastY / 2 - editorApp.mouseY / 2),\n      );\n    }\n  },\n  keyGotUpFunc(editorApp) { },\n  keyGotDownFunc(editorApp) { },\n};\n\n[\n  Creator.createModeTitle(RectangleMode.name),\n].forEach(element.appendChild.bind(element));\n\nexport default RectangleMode;\n", "/* eslint-disable @typescript-eslint/no-empty-function */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport Mode from '../modeInterface';\nimport * as Creator from '../elementCreator';\n\nlet k = 0.2;\nlet fc = 0.5;\nconst element = document.createElement('div');\n\nconst RectangleBodyMode: Mode = {\n  name: 'Rectangle body (experimental)',\n  description: '',\n  element,\n  drawFunc(editorApp, dt) {\n    const ctx = <CanvasRenderingContext2D>editorApp.cnv.getContext('2d');\n\n    if (editorApp.lastX !== 0 && editorApp.lastY !== 0) {\n      ctx.strokeStyle = 'black';\n      ctx.strokeRect(editorApp.mouseX, editorApp.mouseY,\n        editorApp.lastX - editorApp.mouseX, editorApp.lastY - editorApp.mouseY);\n    }\n  },\n  startInteractionFunc(editorApp) { },\n  endInteractionFunc(editorApp) {\n    if (editorApp.lastX !== 0 && editorApp.lastY !== 0) {\n      editorApp.physics.addRectBody(\n        editorApp.lastX / 2 + editorApp.mouseX / 2,\n        editorApp.lastY / 2 + editorApp.mouseY / 2,\n        2 * Math.abs(editorApp.lastX / 2 - editorApp.mouseX / 2),\n        2 * Math.abs(editorApp.lastY / 2 - editorApp.mouseY / 2),\n        fc, k,\n      );\n    }\n  },\n  keyGotUpFunc(editorApp) { },\n  keyGotDownFunc(editorApp) { },\n};\n\n[\n  Creator.createModeTitle(RectangleBodyMode.name),\n  Creator.createSlider('Bounciness', 0.07, 0.3, k, (event) => {\n    k = (<HTMLInputElement>event.target).valueAsNumber;\n  }, 0.02),\n  Creator.createSlider('Coefficient of friction', 0, 0.6, fc, (event) => {\n    fc = (<HTMLInputElement>event.target).valueAsNumber;\n  }, 0.1),\n].forEach(element.appendChild.bind(element));\n\nexport default RectangleBodyMode;\n", "/* eslint-disable @typescript-eslint/no-empty-function */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport Mode from '../modeInterface';\nimport { Ball, Vec2 } from '../../../src/physics';\nimport * as Creator from '../elementCreator';\n\nlet size = 35;\nconst k = 0.5;\nlet fc = 1.5;\nlet resolution = 24;\nlet pressure = 1;\nconst element = document.createElement('div');\n\nconst SoftSquareCreatorMode: Mode = {\n  name: 'Soft square creator',\n  description: '',\n  element,\n  drawFunc(editorApp, dt: number): void {\n    const ctx = <CanvasRenderingContext2D>editorApp.cnv.getContext('2d');\n    ctx.strokeStyle = 'black';\n\n    ctx.beginPath();\n    ctx.moveTo(editorApp.mouseX - size,\n      editorApp.mouseY - size);\n    ctx.lineTo(editorApp.mouseX + size,\n      editorApp.mouseY - size);\n    ctx.lineTo(editorApp.mouseX + size,\n      editorApp.mouseY + size);\n    ctx.lineTo(editorApp.mouseX - size,\n      editorApp.mouseY + size);\n    ctx.lineTo(editorApp.mouseX - size,\n      editorApp.mouseY - size);\n    ctx.stroke();\n\n    if (editorApp.lastX !== 0 && editorApp.lastY !== 0) {\n      ctx.beginPath();\n      ctx.moveTo(editorApp.mouseX, editorApp.mouseY);\n      ctx.lineTo(editorApp.lastX, editorApp.lastY);\n      ctx.stroke();\n    }\n  },\n  startInteractionFunc(editorApp): void { },\n  endInteractionFunc(editorApp): void {\n    if (editorApp.lastX !== 0 && editorApp.lastY !== 0) {\n      const newBall = new Ball(\n        new Vec2(editorApp.lastX, editorApp.lastY),\n        new Vec2(editorApp.lastX - editorApp.mouseX,\n          editorApp.lastY - editorApp.mouseY), size, k, 0, fc,\n      );\n      if (\n        Number.isFinite(newBall.pos.x)\n        && Number.isFinite(newBall.pos.y)\n        && Number.isFinite(newBall.vel.x)\n        && Number.isFinite(newBall.vel.y)\n      ) {\n        editorApp.physics.addSoftSquare(newBall.pos,\n          size * 2, fc, newBall.vel, resolution, pressure);\n      }\n    }\n  },\n  keyGotUpFunc(editorApp): void { },\n  keyGotDownFunc(editorApp): void { },\n};\n\n[\n  Creator.createModeTitle(SoftSquareCreatorMode.name),\n  Creator.createSlider('Size', 5, 100, size, (event) => {\n    size = (<HTMLInputElement>event.target).valueAsNumber;\n  }),\n  Creator.createSlider('Pressure', 0.4, 7, pressure, (event) => {\n    pressure = (<HTMLInputElement>event.target).valueAsNumber;\n  }, 0.1),\n  Creator.createSlider('Coefficient of friction', 0, 2, fc, (event) => {\n    fc = (<HTMLInputElement>event.target).valueAsNumber;\n  }, 0.1),\n  Creator.createSlider('Resolution', 16, 48, resolution, (event) => {\n    resolution = (<HTMLInputElement>event.target).valueAsNumber;\n  }, 8),\n].forEach(element.appendChild.bind(element));\n\nexport default SoftSquareCreatorMode;\n", "/* eslint-disable @typescript-eslint/no-empty-function */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport Mode from '../modeInterface';\nimport { Spring } from '../../../src/physics';\nimport * as Creator from '../elementCreator';\n\nlet lockRotation = false;\nlet springConstant = 10000;\nconst element = document.createElement('div');\n\nconst SpringCreatorMode: Mode = {\n  name: 'Spring creator',\n  description: '',\n  element,\n  drawFunc(editorApp, dt) {\n    const ctx = <CanvasRenderingContext2D>editorApp.cnv.getContext('2d');\n\n    if (editorApp.lastX !== 0 && editorApp.lastY !== 0) {\n      ctx.strokeStyle = 'black';\n      ctx.beginPath();\n      ctx.moveTo(editorApp.mouseX, editorApp.mouseY);\n      ctx.lineTo(editorApp.lastX, editorApp.lastY);\n      ctx.stroke();\n    }\n  },\n  startInteractionFunc(editorApp) { },\n  endInteractionFunc(editorApp) {\n    if (editorApp.lastX !== 0 && editorApp.lastY !== 0) {\n      let newChoosed = editorApp.physics.getObjectAtCoordinates(editorApp.mouseX, editorApp.mouseY);\n      let stick;\n      const Thing = Spring;\n      if (!newChoosed) {\n        newChoosed = {\n          x: editorApp.mouseX,\n          y: editorApp.mouseY,\n          pinPoint: true,\n        };\n      }\n\n      if (\n        editorApp.choosed === newChoosed\n        || (editorApp.choosed === undefined && newChoosed === undefined)\n      ) {\n        return;\n      } if (editorApp.choosed instanceof Object && newChoosed instanceof Object\n        && 'pinPoint' in editorApp.choosed && 'pinPoint' in newChoosed) return;\n      if (editorApp.choosed instanceof Object && newChoosed instanceof Object\n        && 'pinPoint' in editorApp.choosed && 'pos' in newChoosed) {\n        stick = new Thing(\n          Math.sqrt(\n            ((editorApp.choosed.x - newChoosed.pos.x) ** 2)\n            + ((editorApp.choosed.y - newChoosed.pos.y) ** 2),\n          ),\n          springConstant,\n        );\n        stick.attachObject(newChoosed);\n        stick.pinHere(editorApp.choosed.x, editorApp.choosed.y);\n      } else if (newChoosed instanceof Object && editorApp.choosed instanceof Object\n         && 'pos' in editorApp.choosed && 'pinPoint' in newChoosed) {\n        stick = new Thing(\n          Math.sqrt(\n            ((editorApp.choosed.pos.x - newChoosed.x) ** 2)\n            + ((editorApp.choosed.pos.y - newChoosed.y) ** 2),\n          ),\n          springConstant,\n        );\n        stick.attachObject(editorApp.choosed);\n        stick.pinHere(newChoosed.x, newChoosed.y);\n      } else if (editorApp.choosed instanceof Object && newChoosed instanceof Object\n        && 'pos' in editorApp.choosed && 'pos' in newChoosed) {\n        stick = new Thing(\n          Math.sqrt(\n            ((editorApp.choosed.pos.x - newChoosed.pos.x) ** 2)\n            + ((editorApp.choosed.pos.y - newChoosed.pos.y) ** 2),\n          ),\n          springConstant,\n        );\n        stick.attachObject(editorApp.choosed);\n        stick.attachObject(newChoosed);\n      }\n      if (typeof stick === 'undefined') return;\n      editorApp.physics.addSpring(stick);\n      if (lockRotation) {\n        stick.lockRotation();\n      }\n    }\n  },\n  keyGotUpFunc(editorApp) { },\n  keyGotDownFunc(editorApp) { },\n};\n\n[\n  Creator.createModeTitle(SpringCreatorMode.name),\n  Creator.createCheckbox('Rotation locked', lockRotation, (event) => {\n    lockRotation = (<HTMLInputElement>event.target).checked;\n  }),\n  Creator.createSlider('Spring stiffness', 2000, 100000, springConstant, (event) => {\n    springConstant = (<HTMLInputElement>event.target).valueAsNumber;\n  }, 50),\n].forEach(element.appendChild.bind(element));\n\nexport default SpringCreatorMode;\n", "/* eslint-disable @typescript-eslint/no-empty-function */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport Mode from '../modeInterface';\nimport { Stick } from '../../../src/physics';\nimport * as Creator from '../elementCreator';\n\nlet lockRotation = false;\n\nconst element = document.createElement('div');\n\nconst StickCreatorMode: Mode = {\n  name: 'Stick creator',\n  description: '',\n  element,\n  drawFunc(editorApp, dt) {\n    const ctx = <CanvasRenderingContext2D>editorApp.cnv.getContext('2d');\n\n    if (editorApp.lastX !== 0 && editorApp.lastY !== 0) {\n      ctx.strokeStyle = 'black';\n      ctx.beginPath();\n      ctx.moveTo(editorApp.mouseX, editorApp.mouseY);\n      ctx.lineTo(editorApp.lastX, editorApp.lastY);\n      ctx.stroke();\n    }\n  },\n  startInteractionFunc(editorApp) { },\n  endInteractionFunc(editorApp) {\n    if (editorApp.lastX !== 0 && editorApp.lastY !== 0) {\n      let newChoosed = editorApp.physics.getObjectAtCoordinates(editorApp.mouseX, editorApp.mouseY);\n      let stick;\n      const Thing = Stick;\n      if (!newChoosed) {\n        newChoosed = {\n          x: editorApp.mouseX,\n          y: editorApp.mouseY,\n          pinPoint: true,\n        };\n      }\n\n      if (\n        editorApp.choosed === newChoosed\n        || (editorApp.choosed === undefined && newChoosed === undefined)\n      ) {\n        return;\n      } if ('pinPoint' in editorApp.choosed && 'pinPoint' in newChoosed) return;\n      if ('pinPoint' in editorApp.choosed && 'pos' in newChoosed) {\n        stick = new Thing(\n          Math.sqrt(\n            ((editorApp.choosed.x - newChoosed.pos.x) ** 2)\n            + ((editorApp.choosed.y - newChoosed.pos.y) ** 2),\n          ),\n        );\n        stick.attachObject(newChoosed);\n        stick.pinHere(editorApp.choosed.x, editorApp.choosed.y);\n      } else if ('pinPoint' in newChoosed && 'pos' in editorApp.choosed) {\n        stick = new Thing(\n          Math.sqrt(\n            ((editorApp.choosed.pos.x - newChoosed.x) ** 2)\n            + ((editorApp.choosed.pos.y - newChoosed.y) ** 2),\n          ),\n        );\n        stick.attachObject(editorApp.choosed);\n        stick.pinHere(newChoosed.x, newChoosed.y);\n      } else if ('pos' in editorApp.choosed && 'pos' in newChoosed) {\n        stick = new Thing(\n          Math.sqrt(\n            ((editorApp.choosed.pos.x - newChoosed.pos.x) ** 2)\n            + ((editorApp.choosed.pos.y - newChoosed.pos.y) ** 2),\n          ),\n        );\n        stick.attachObject(editorApp.choosed);\n        stick.attachObject(newChoosed);\n      }\n      if (typeof stick === 'undefined') return;\n      editorApp.physics.addSpring(stick);\n      if (lockRotation) {\n        stick.lockRotation();\n      }\n    }\n  },\n  keyGotUpFunc(editorApp) { },\n  keyGotDownFunc(editorApp) { },\n};\n\n[\n  Creator.createModeTitle(StickCreatorMode.name),\n  Creator.createCheckbox('Rotation locked', lockRotation, (event) => {\n    lockRotation = (<HTMLInputElement>event.target).checked;\n  }),\n].forEach(element.appendChild.bind(element));\n\nexport default StickCreatorMode;\n", "/* eslint-disable @typescript-eslint/no-empty-function */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport Mode from '../modeInterface';\nimport * as Creator from '../elementCreator';\n\nlet size = 20;\nconst element = document.createElement('div');\n\nconst WallDrawerMode: Mode = {\n  name: 'Wall drawer',\n  description: '',\n  element,\n  drawFunc(editorApp, dt) {\n    const ctx = <CanvasRenderingContext2D>editorApp.cnv.getContext('2d');\n\n    ctx.strokeStyle = 'black';\n    ctx.beginPath();\n    ctx.arc(editorApp.mouseX, editorApp.mouseY,\n      size, 0, 2 * Math.PI);\n    ctx.stroke();\n    if (editorApp.lastX !== 0 && editorApp.lastY !== 0) {\n      editorApp.physics.addFixedBall(editorApp.mouseX,\n        editorApp.mouseY,\n        size);\n    }\n  },\n  startInteractionFunc(editorApp) {\n  },\n  endInteractionFunc(editorApp) {\n  },\n  keyGotUpFunc(editorApp) { },\n  keyGotDownFunc(editorApp) { },\n};\n\n[\n  Creator.createModeTitle(WallDrawerMode.name),\n  Creator.createSlider('Size', 5, 70, size, (event) => {\n    size = (<HTMLInputElement>event.target).valueAsNumber;\n  }),\n].forEach(element.appendChild.bind(element));\n\nexport default WallDrawerMode;\n", "import BallCreatorMode from './ballcreator';\nimport DeleteMode from './deletemode';\nimport ElasticBallCreatorMode from './elasticballcreator';\nimport MoveMode from './movemode';\nimport RectangleMode from './rectangle';\nimport RectangleBodyMode from './rectanglebodycreator';\nimport SoftSquareCreatorMode from './softsquarecreator';\nimport SpringCreatorMode from './springcreator';\nimport StickCreatorMode from './stickcreator';\nimport WallDrawerMode from './walldrawer';\n\nexport default [BallCreatorMode, RectangleMode, WallDrawerMode,\n  StickCreatorMode, SpringCreatorMode, MoveMode, ElasticBallCreatorMode,\n  SoftSquareCreatorMode, DeleteMode, RectangleBodyMode,\n];\n", "import Physics, {\n  Ball, Vec2, Spring, Stick, Wall, AnyPhysicsObject,\n} from '../../src/physics';\nimport EditorInterface from './editorInterface';\n\nimport startPauseControlsFunction from './startPauseControls';\nimport Modes from './modes/index';\n\n// Import css\nimport '../css/style.css';\n\nconst modes = Modes;\nconst modeNames = modes.map((mode) => mode.name);\n\nconst palette = {\n  white: '#faf3dd',\n  green: '#02c39a',\n  pink: '#e58c8a',\n  blue: '#77b6ea',\n  black: '#363732',\n};\n\n/**\n * The main Object handling the whole app\n */\nclass Editor implements EditorInterface {\n  physics: Physics;\n\n  mouseX: number;\n\n  mouseY: number;\n\n  mouseDown: boolean;\n\n  defaultSize: number;\n\n  k: number;\n\n  fc: number;\n\n  springConstant: number;\n\n  scaling: number;\n\n  viewOffsetX: number;\n\n  viewOffsetY: number;\n\n  mode: number;\n\n  lastX: number;\n\n  lastY: number;\n\n  timeMultiplier: number;\n\n  lastFrameTime: number;\n\n  choosed: (AnyPhysicsObject | boolean);\n\n  left: boolean;\n\n  right: boolean;\n\n  cnv: HTMLCanvasElement;\n\n  canvasHolder: HTMLElement;\n\n  sidebar: HTMLElement;\n\n  constructor() {\n    this.physics = new Physics();\n    this.mouseX = 0;\n    this.mouseY = 0;\n    this.mouseDown = false;\n    this.defaultSize = 30;\n    this.k = 0.5;\n    this.fc = 2;\n    this.springConstant = 2000;\n    this.scaling = 1;\n    this.viewOffsetX = 0;\n    this.viewOffsetY = 0;\n    this.mode = 0;\n    this.lastX = 0;\n    this.lastY = 0;\n    this.timeMultiplier = 1;\n    this.lastFrameTime = performance.now();\n    this.choosed = false;\n\n    this.left = false;\n    this.right = false;\n\n    // A fully loaded window is provided\n    this.cnv = <HTMLCanvasElement>document.getElementById('defaulCanvas0');\n    this.canvasHolder = <HTMLElement>document.getElementById('canvas-holder');\n    this.sidebar = <HTMLElement>document.getElementById('sidebar');\n\n    this.physics.setBounds(0, 0, this.cnv.width, this.cnv.height);\n    this.physics.setGravity(new Vec2(0, 1000));\n    this.physics.setAirFriction(0.9);\n\n    this.cnv.addEventListener('touchstart', this.startTouch, false);\n    this.cnv.addEventListener('touchend', this.endTouch, false);\n    this.cnv.addEventListener('touchmove', this.moveTouch, false);\n    this.cnv.addEventListener('mousedown', this.startMouse, false);\n    this.cnv.addEventListener('mouseup', this.endMouse, false);\n    this.cnv.addEventListener('mousemove', this.handleMouseMovement, false);\n    document.addEventListener('keydown', this.keyGotDown, false);\n    document.addEventListener('keyup', this.keyGotUp, false);\n    window.addEventListener('resize', this.resizeCanvas, false);\n    this.cnv.addEventListener(\n      'mousedown',\n      () => {\n        this.mouseDown = true;\n      },\n      false,\n    );\n    this.cnv.addEventListener(\n      'mouseup',\n      () => {\n        this.mouseDown = false;\n      },\n      false,\n    );\n\n    this.resizeCanvas();\n\n    // Set up modes and link them to the buttons\n    this.setupModes();\n\n    startPauseControlsFunction(this);\n\n    requestAnimationFrame(this.drawFunction);\n  }\n\n  /**\n   * Function that is called when the window gest resized\n   */\n  resizeCanvas = (): void => {\n    // Fit canvas inside the holder\n    const canvasRect = this.canvasHolder.getBoundingClientRect();\n    this.cnv.width = canvasRect.width;\n    this.cnv.height = window.innerHeight - canvasRect.top;\n\n    // Code for making the image sharp on high DPI displays\n    // Scale according to the pixel ratio of the display\n    const dpr = window.devicePixelRatio || 1;\n    const rect = canvasRect;\n    this.cnv.width = rect.width * dpr;\n    this.cnv.height = rect.height * dpr;\n    this.cnv.style.width = `${rect.width}px`;\n    this.cnv.style.height = `${rect.height}px`;\n    this.scaling = 1 / dpr;\n    this.physics.setBounds(0, 0, this.cnv.width, this.cnv.height);\n    const ctx = this.cnv.getContext('2d');\n    if (ctx) {\n      ctx.scale(dpr, dpr);\n      ctx.lineWidth = dpr;\n    }\n\n    // Set the size of the balls\n    this.defaultSize = (this.cnv.width + this.cnv.height) / 80;\n  };\n\n  /**\n   * My draw function\n   */\n  drawFunction = (): void => {\n    if (!Number.isFinite(this.lastFrameTime)) this.lastFrameTime = performance.now();\n    let elapsedTime = performance.now() - this.lastFrameTime;\n    if (!Number.isFinite(elapsedTime)) {\n      elapsedTime = 0;\n    }\n    elapsedTime /= 1000;\n\n    const ctx = <CanvasRenderingContext2D> this.cnv.getContext('2d');\n\n    // paint the background\n    ctx.fillStyle = palette.black;\n    ctx.fillRect(0, 0, this.cnv.width, this.cnv.height);\n\n    ctx.save();\n    ctx.translate(this.viewOffsetX, this.viewOffsetY);\n    ctx.scale(this.scaling, this.scaling);\n\n    modes[this.mode].drawFunc?.(this, elapsedTime * this.timeMultiplier);\n    this.physicsDraw();\n\n    ctx.restore();\n\n    if (this.physics.balls[0]) {\n      if (this.right) this.physics.balls[0].ang -= Math.PI * 100 * elapsedTime;\n      if (this.left) this.physics.balls[0].ang += Math.PI * 100 * elapsedTime;\n    }\n\n    elapsedTime *= this.timeMultiplier;\n    this.physics.update(elapsedTime / 5, false);\n    this.physics.update(elapsedTime / 5, false);\n    this.physics.update(elapsedTime / 5, false);\n    this.physics.update(elapsedTime / 5, false);\n    this.physics.update(elapsedTime / 5, false);\n\n    this.lastFrameTime = performance.now();\n    requestAnimationFrame(this.drawFunction);\n  };\n\n  /**\n   * Gets called on the start of an interaction with the canvas\n   *\n   * @param {number} x The x position of the mouse or the finger on the canvas\n   * @param {number} y The y position of the mouse or the finger on the canvas\n   */\n  startInteraction = (x: number, y: number): void => {\n    this.mouseX = x / this.scaling - this.viewOffsetX / this.scaling;\n    this.mouseY = y / this.scaling - this.viewOffsetY / this.scaling;\n    this.choosed = this.physics.getObjectAtCoordinates(this.mouseX, this.mouseY);\n    if (!this.choosed) {\n      this.choosed = {\n        x: this.mouseX,\n        y: this.mouseY,\n        pinPoint: true,\n      };\n    }\n    this.lastX = this.mouseX;\n    this.lastY = this.mouseY;\n\n    modes[this.mode].startInteractionFunc?.(this);\n  };\n\n  /**\n   * Gets called on the end of an interaction with the canvas\n   *\n   * @param {number} x The x position of the mouse of the finger on the canvas\n   * @param {number} y The y position of the mouse of the finger on the canvas\n   */\n  endInteraction = (x: number, y: number): void => {\n    this.mouseX = x / this.scaling - this.viewOffsetX / this.scaling;\n    this.mouseY = y / this.scaling - this.viewOffsetY / this.scaling;\n\n    modes[this.mode].endInteractionFunc?.(this);\n\n    if (this.lastX === 0 && this.lastY === 0) return;\n\n    this.lastX = 0;\n    this.lastY = 0;\n    this.choosed = false;\n  };\n\n  /**\n   * My keyboard event function for pressing down a key\n   *\n   * @param {KeyboardEvent} event The event containing data\n   */\n  keyGotDown = (event: KeyboardEvent): void => {\n    const keyCode = event.key;\n    if (keyCode === 's') {\n      this.spawnNewtonsCradle(this.cnv.width / 2, this.cnv.height / 2, 0.5, this.physics);\n    }\n    if (keyCode === 'a') {\n      this.scaling += 0.01;\n    }\n    if (keyCode === 'd') {\n      this.scaling -= 0.01;\n    }\n    if (keyCode === 'j') {\n      this.viewOffsetX -= 10;\n    }\n    if (keyCode === 'l') {\n      this.viewOffsetX += 10;\n    }\n    if (keyCode === 'k') {\n      this.viewOffsetY -= 10;\n    }\n    if (keyCode === 'i') {\n      this.viewOffsetY += 10;\n    }\n    if (keyCode === 'ArrowRight') {\n      this.right = true;\n    }\n    if (keyCode === 'ArrowLeft') {\n      this.left = true;\n    }\n  };\n\n  /**\n   * My keyboard event function for releasing a key\n   *\n   * @param {KeyboardEvent} event The event containing data\n   */\n  keyGotUp = (event: KeyboardEvent): void => {\n    const keyCode = event.key;\n    // Right arrow\n    if (keyCode === 'ArrowRight') {\n      this.right = false;\n    }\n    // Left arrow\n    if (keyCode === 'ArrowLeft') {\n      this.left = false;\n    }\n  };\n\n  /**\n   * My touch event function\n   *\n   * @param {TouchEvent} event The event containing data\n   * @returns {boolean} Returns false for preventing default browser behavior\n   */\n  startTouch = (event: TouchEvent): boolean => {\n    event.preventDefault();\n    const cnvBounds = this.canvasHolder.getBoundingClientRect();\n    this.startInteraction(\n      event.changedTouches[0].clientX - cnvBounds.left,\n      event.changedTouches[0].clientY - cnvBounds.top,\n    );\n    return false;\n  };\n\n  /**\n   * My touch event function\n   *\n   * @param {TouchEvent} event The event containing data\n   * @returns {boolean} Returns false for preventing default browser behavior\n   */\n  endTouch = (event: TouchEvent): boolean => {\n    event.preventDefault();\n    const cnvBounds = this.canvasHolder.getBoundingClientRect();\n    this.endInteraction(\n      event.changedTouches[0].clientX - cnvBounds.left,\n      event.changedTouches[0].clientY - cnvBounds.top,\n    );\n    return false;\n  };\n\n  /**\n   * My touch event function\n   *\n   * @param {TouchEvent} event The event containing data\n   * @returns {boolean} Returns false for preventing default browser behavior\n   */\n  moveTouch = (event: TouchEvent): boolean => {\n    event.preventDefault();\n    const cnvBounds = this.canvasHolder.getBoundingClientRect();\n    this.mouseX = event.changedTouches[0].clientX - cnvBounds.left;\n    this.mouseY = event.changedTouches[0].clientY - cnvBounds.top;\n    this.mouseX = this.mouseX / this.scaling - this.viewOffsetX / this.scaling;\n    this.mouseY = this.mouseY / this.scaling - this.viewOffsetY / this.scaling;\n    return false;\n  };\n\n  /**\n   * My mouse event function that handles pressing down a mouse key\n   *\n   * @param {TouchEvent} event The event containing data\n   * @returns {boolean} Returns false for preventing default browser behavior\n   */\n  startMouse = (event: MouseEvent): boolean => {\n    this.startInteraction(event.offsetX, event.offsetY);\n    return false;\n  };\n\n  /**\n   * My mouse event function that handles releasing a mouse key\n   *\n   * @param {TouchEvent} event The event containing data\n   * @returns {boolean} Returns false for preventing default browser behavior\n   */\n  endMouse = (event: MouseEvent): boolean => {\n    this.endInteraction(event.offsetX, event.offsetY);\n    return false;\n  };\n\n  /**\n   * My mouse event function that handles mouse movement\n   *\n   * @param {TouchEvent} event The event containing data\n   */\n  handleMouseMovement = (event: MouseEvent): void => {\n    this.mouseX = event.offsetX;\n    this.mouseY = event.offsetY;\n    this.mouseX = this.mouseX / this.scaling - this.viewOffsetX / this.scaling;\n    this.mouseY = this.mouseY / this.scaling - this.viewOffsetY / this.scaling;\n  };\n\n  physicsDraw = (): void => {\n    const ctx = this.cnv.getContext('2d');\n\n    if (ctx) {\n      ctx.fillStyle = palette.green;\n      ctx.strokeStyle = 'black';\n      for (let i = 0; i < this.physics.balls.length; i += 1) {\n        const ball = this.physics.balls[i];\n        ctx.beginPath();\n        ctx.arc(\n          ball.pos.x,\n          ball.pos.y,\n          ball.r,\n          0,\n          2 * Math.PI,\n        );\n        ctx.stroke();\n        ctx.fill();\n\n        ctx.beginPath();\n        ctx.moveTo(ball.pos.x, ball.pos.y);\n        ctx.lineTo(ball.pos.x + ball.r * Math.cos(ball.rotation),\n          ball.pos.y + ball.r * Math.sin(ball.rotation));\n        ctx.stroke();\n      }\n\n      this.physics.bodies.forEach((element) => {\n        ctx.beginPath();\n        ctx.moveTo(\n          element.points[element.points.length - 1].x,\n          element.points[element.points.length - 1].y,\n        );\n        element.points.forEach((p) => {\n          ctx.lineTo(p.x, p.y);\n        });\n        ctx.stroke();\n        ctx.fill();\n\n        ctx.beginPath();\n        ctx.arc(element.pos.x, element.pos.y, 1.5, 0, Math.PI * 2);\n        ctx.stroke();\n      });\n\n      const drawWall = (element: Wall) => {\n        ctx.beginPath();\n        ctx.moveTo(\n          element.points[element.points.length - 1].x,\n          element.points[element.points.length - 1].y,\n        );\n        element.points.forEach((p) => {\n          ctx.lineTo(p.x, p.y);\n        });\n        ctx.fill();\n      };\n      ctx.fillStyle = 'white';\n      this.physics.walls.forEach(drawWall);\n      this.physics.bounds.forEach(drawWall);\n\n      this.physics.fixedBalls.forEach((b) => {\n        ctx.beginPath();\n        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);\n        ctx.fill();\n      });\n      ctx.save();\n      ctx.lineWidth = 2;\n      this.physics.springs.forEach((element) => {\n        if (element instanceof Spring && !(element instanceof Stick)) {\n          let x1;\n          let y1;\n          let x2;\n          let y2;\n          if (element.pinned && typeof element.pinned === 'object') {\n            x1 = element.pinned.x;\n            y1 = element.pinned.y;\n            x2 = element.objects[0].pos.x;\n            y2 = element.objects[0].pos.y;\n          } else {\n            x1 = element.objects[0].pos.x;\n            y1 = element.objects[0].pos.y;\n            x2 = element.objects[1].pos.x;\n            y2 = element.objects[1].pos.y;\n          }\n          let v = new Vec2(x2 - x1, y2 - y1);\n          const c = v.copy;\n          v.rotate(Math.PI / 2);\n          v.setMag(5);\n          let last = new Vec2(x1, y1);\n          const num = Math.floor(element.length / 10);\n          for (let i = 1; i <= num; i += 1) {\n            ctx.strokeStyle = palette.blue;\n            ctx.fillStyle = palette.blue;\n            if (i === num) v = new Vec2(0, 0);\n            ctx.beginPath();\n            ctx.moveTo(last.x, last.y);\n            ctx.lineTo(x1 + (i / num) * c.x + v.x, y1 + (i / num) * c.y + v.y);\n            ctx.stroke();\n            last = new Vec2(x1 + (i / num) * c.x + v.x, y1 + (i / num) * c.y + v.y);\n            v.mult(-1);\n          }\n        } else {\n          ctx.strokeStyle = palette.blue;\n          ctx.fillStyle = palette.blue;\n          ctx.beginPath();\n          ctx.moveTo(element.objects[0].pos.x, element.objects[0].pos.y);\n          ctx.lineTo(\n            (typeof element.pinned === 'object') ? element.pinned.x : element.objects[1].pos.x,\n            (typeof element.pinned === 'object') ? element.pinned.y : element.objects[1].pos.y,\n          );\n          ctx.stroke();\n        }\n        element.objects.forEach((o) => {\n          ctx.strokeStyle = 'black';\n          ctx.fillStyle = palette.blue;\n          ctx.beginPath();\n          ctx.arc(o.pos.x, o.pos.y, 2.5, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.stroke();\n        });\n        if (typeof element.pinned === 'object') {\n          ctx.strokeStyle = 'black';\n          ctx.fillStyle = palette.blue;\n          ctx.beginPath();\n          ctx.arc(element.pinned.x, element.pinned.y, 3, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.stroke();\n        }\n      });\n      ctx.restore();\n    }\n  };\n\n  /**\n   * Spawns a Newton cradle inside the given world at given size and\n   * coordinates\n   *\n   * @param {number} x The x coordinate of it\n   * @param {number} y The y coordinate of it\n   * @param {number} scale The size of it\n   * @param {Physics} phy The world to put it in\n   */\n  spawnNewtonsCradle = (x: number, y: number, scale: number, phy: Physics): void => {\n    const balls = [];\n    const defaultR = 25;\n    const defaultStick = 250;\n    const ballNumber = 8;\n    balls.push(\n      new Ball(new Vec2(x, y), new Vec2(0, 0), scale * defaultR, 1, 0, 0),\n    );\n    let count = 1;\n    for (let i = 0; i < ballNumber - 1; i += 1) {\n      balls.push(\n        new Ball(\n          new Vec2(x + count * scale * defaultR * 1.01 * 2, y),\n          new Vec2(0, 0),\n          scale * 25,\n          1,\n          0,\n          0,\n        ),\n      );\n      count *= -1;\n      if (count > 0) count += 1;\n      if (i === ballNumber - 2) {\n        balls[balls.length - 1].vel.x = -Math.sign(count) * scale * defaultR * 8;\n      }\n    }\n    balls.forEach((ball) => {\n      phy.addBall(ball);\n      const stick = new Stick(defaultStick);\n      stick.attachObject(ball);\n      stick.pinHere(ball.pos.x, ball.pos.y - defaultStick);\n      phy.addSpring(stick);\n      stick.lockRotation();\n    });\n  };\n\n  /**\n   * Gets called when one of the mode buttons get clicked\n   * Swithces to the mode corresponding to the button\n   *\n   * @param {MouseEvent} e The click event\n   */\n  modeButtonClicked = (e: MouseEvent): void => {\n    const modeName = (<HTMLElement>e.target).id.replace('-btn', '');\n    const modeNum = modeNames.indexOf(modeName);\n    this.switchToMode(modeNum);\n  };\n\n  /**\n   * Switches the editor to the given mode\n   * It also puts the corresponding HTML elements on the sidebar\n   *\n   * @param {number} modeNum The mode number to switch to\n   */\n  switchToMode = (modeNum: number): void => {\n    const prevoiusBtn = document.getElementById(`${modeNames[this.mode]}-btn`);\n    if (prevoiusBtn) prevoiusBtn.classList.remove('bg-pink-darker');\n    this.sidebar.innerHTML = '';\n\n    const newBtn = document.getElementById(`${modeNames[modeNum]}-btn`);\n    if (newBtn) newBtn.classList.add('bg-pink-darker');\n    this.mode = modeNum;\n    this.sidebar.appendChild(modes[this.mode].element);\n  };\n\n  /**\n   * It initially creates the buttons for each mode and switches to the first one\n   */\n  setupModes = (): void => {\n    const buttonHolder = document.getElementById('button-holder');\n\n    modeNames.forEach((modeName, i) => {\n      const button = document.createElement('div');\n      button.classList.add('big-button');\n      button.classList.add('fix-width');\n      button.id = `${modeName}-btn`;\n      button.textContent = modes[i].name;\n      button.onclick = this.modeButtonClicked;\n      if (buttonHolder) buttonHolder.appendChild(button);\n    });\n\n    this.switchToMode(this.mode);\n  };\n\n  /**\n   * Setter for the variable timeMultipler for passing it to other scopes\n   *\n   * @param {number} x The new value of timeMultiplier\n   */\n  setTimeMultiplier = (x: number): void => {\n    if (Number.isFinite(x)) this.timeMultiplier = x;\n  };\n\n  /**\n   * Getter for the variable timeMultiplier for passing it to other scopes\n   *\n   * @returns {number} The value of timeMultiplier\n   */\n  getTimeMultiplier = (): number => this.timeMultiplier;\n\n  /**\n   * Setter for the object physics for passing it to other scopes\n   *\n   * @param {Physics} phy The new physics object\n   */\n  setPhysics = (phy: Physics): void => {\n    if (phy instanceof Physics) this.physics = phy;\n  };\n\n  /**\n   * Getter for the physics object for passing it to other scopes\n   *\n   * @returns {Physics} The physics object\n   */\n  getPhysics = (): Physics => this.physics;\n}\n\nexport default Editor;\n", "import Editor from './editor';\n\nwindow.onload = () => {\n  (window as any).editorApp = new Editor();\n};\n"],
  "mappings": "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",
  "names": []
}
