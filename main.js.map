{
  "version": 3,
  "sources": ["../src/vec2.js", "../src/ball.js", "../src/linesegment.js", "../src/wall.js", "../src/spring.js", "../src/stick.js", "../src/softball.js", "../src/body.js", "../src/line.js", "../src/polygon.js", "../src/physics.js", "../editor/src/startPauseControls.js", "../editor/src/mode.js", "../editor/src/modes/ballcreator.js", "../editor/src/modes/rectangle.js", "../editor/src/modes/walldrawer.js", "../editor/src/modes/stickcreator.js", "../editor/src/modes/springcreator.js", "../editor/src/modes/movemode.js", "../editor/src/modes/elasticballcreator.js", "../editor/src/modes/softsquarecreator.js", "../editor/src/modes/deletemode.js", "../editor/src/modes/rectanglebodycreator.js", "../editor/src/index.js"],
  "sourcesContent": ["// every angle is counterclockwise (anticlockwise)\n/** Class representing a 2d vector. */\nclass Vec2 {\n  /**\n   * Create a vector.\n   * @param {number} x - The x value.\n   * @param {number} y - The y value.\n   */\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Get a copy of the vector.\n   * @return {Vec2} The copy.\n   */\n  get copy() {\n    return new Vec2(this.x, this.y);\n  }\n\n  /**\n   * Get the length of the vector.\n   * @return {number} The length.\n   */\n  get length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  /**\n   * Get the length of the vector squared.\n   * @return {number} The length squared.\n   */\n  get sqlength() {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  /**\n   * Get the heading of the vector compared to (1, 0).\n   * @return {number} The angle between (1, 0)\n   * and the vector in anticlockwise direction.\n   */\n  get heading() {\n    if (this.x === 0 && this.y === 0) return 0;\n    if (this.x === 0) return this.y > 0 ? Math.PI / 2 : 1.5 * Math.PI;\n    if (this.y === 0) return this.x > 0 ? 0 : Math.PI;\n    let v = Vec2.normalized(this);\n    if (this.x > 0 && this.y > 0) return Math.asin(v.y);\n    if (this.x < 0 && this.y > 0) return Math.asin(-v.x) + Math.PI / 2;\n    if (this.x < 0 && this.y < 0) return Math.asin(-v.y) + Math.PI;\n    if (this.x > 0 && this.y < 0) return Math.asin(v.x) + 1.5 * Math.PI;\n    return 0;\n  }\n\n  /**\n   * Adds another vector to the vector.\n   * @param {Vec2} a - The other vector.\n   */\n  add(a) {\n    this.x += a.x;\n    this.y += a.y;\n  }\n\n  /**\n   * Subtracts another vector from the vector.\n   * @param {Vec2} a - The other vector.\n   */\n  sub(a) {\n    this.x -= a.x;\n    this.y -= a.y;\n  }\n\n  /**\n   * Multiplies the vector by a scalar.\n   * @param {number} x - The scalar.\n   */\n  mult(x) {\n    this.x *= x;\n    this.y *= x;\n  }\n\n  /**\n   * Divides the vector by a scalar.\n   * @param {number} x - The scalar.\n   */\n  div(x) {\n    this.x /= x;\n    this.y /= x;\n  }\n\n  /**\n   * Linearry interpolates the vector into the other vector by scalar x.\n   * @param {Vec2} other - The other vector.\n   * @param {number} x - The scalar.\n   */\n  lerp(other, x) {\n    this.x += (other.x - this.x) * x;\n    this.y += (other.y - this.y) * x;\n  }\n\n  /**\n   * Get the distance between the vector and the other vector.\n   * Vectors are representing points here.\n   * @param {Vec2} other - The other vector.\n   * @return {number} The distance between them.\n   */\n  dist(other) {\n    return new Vec2(this.x - other.x, this.y - other.y).length;\n  }\n\n  /**\n   * Set the length of the vector.\n   * @param {number} l - The new length value.\n   */\n  setMag(l) {\n    if (this.length === 0) return;\n    this.mult(l / this.length);\n  }\n\n  /**\n   * Rotate the vector anticlockwise.\n   * @param {number} angle Rotation angle in radians\n   */\n  rotate(angle) {\n    let h = this.heading;\n    let v = Vec2.fromAngle(angle + h);\n    v.mult(this.length);\n    this.x = v.x;\n    this.y = v.y;\n  }\n\n  // Static functions:\n  /**\n   * Add two vectors together.\n   * @param {Vec2} a - Vector.\n   * @param {Vec2} b - Other vector.\n   * @return {Vec2} The sum of the vectors.\n   */\n  static add(a, b) {\n    return new Vec2(a.x + b.x, a.y + b.y);\n  }\n\n  /**\n   * Subtracts one vector from another.\n   * @param {Vec2} a - Vector.\n   * @param {Vec2} b - Other vector.\n   * @return {Vec2} The subtraction of the vectors.\n   */\n  static sub(a, b) {\n    return new Vec2(a.x - b.x, a.y - b.y);\n  }\n\n  /**\n   * Multiply the vector by a scalar.\n   * @param {Vec2} v - Vector.\n   * @param {number} x - Scalar.\n   * @return {Vec2} The multiplied vector.\n   */\n  static mult(v, x) {\n    return new Vec2(v.x * x, v.y * x);\n  }\n\n  /**\n   * Divide the vector by a scalar.\n   * @param {Vec2} v - Vector.\n   * @param {number} x - Scalar.\n   * @return {Vec2} The divided vector.\n   */\n  static div(v, x) {\n    return new Vec2(v.x / x, v.y / x);\n  }\n\n  /**\n   * Create a unit vector from an angle.\n   * @param {number} a - The angle.\n   * @return {Vec2} The created vector.\n   */\n  static fromAngle(a) {\n    return new Vec2(Math.cos(a), Math.sin(a));\n  }\n\n  /**\n   * Linearry interpolates a vector into another vector by scalar x.\n   * @param {Vec2} a - A vector.\n   * @param {Vec2} b - Other vector.\n   * @param {number} x - The scalar.\n   * @return {Vec2} The created vector.\n   */\n  static lerp(a, b, x) {\n    return Vec2.add(a, Vec2.mult(Vec2.sub(b, a), x));\n  }\n\n  /**\n   * Get the distance between vectors.\n   * @param {Vec2} a - A vector.\n   * @param {Vec2} b - Other vector\n   * @return {number} The distance between them.\n   */\n  static dist(a, b) {\n    return Vec2.sub(a, b).length;\n  }\n\n  /**\n   * Get the dot product of two vectors.\n   * @param {Vec2} a - A vector.\n   * @param {Vec2} b - Other vector\n   * @return {number} The dot product of them.\n   */\n  static dot(a, b) {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  /**\n   * Get the cross product of two vectors.\n   * @param {Vec2} a - A vector.\n   * @param {Vec2} b - Other vector\n   * @return {number} The cross product of them.\n   */\n  static cross(a, b) {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  /**\n   * Get the angle between two vectors.\n   * @param {Vec2} a - A vector.\n   * @param {Vec2} b - Other vector\n   * @return {number} Angle between them.\n   */\n  static angle(a, b) {\n    return Math.acos(Vec2.dot(a, b) / Math.sqrt(a.sqlength * b.sqlength));\n  }\n\n  /**\n   * Get the angle between two vectors but in the anticlockwise direction.\n   * @param {Vec2} a - A vector.\n   * @param {Vec2} b - Other vector\n   * @return {number} Angle between them.\n   */\n  static angleACW(a, b) {\n    let ah = a.heading;\n    let bh = b.heading;\n    let angle = bh - ah;\n    return angle < 0 ? 2 * Math.PI + angle : angle;\n  }\n\n  /**\n   * Get a vector with the same heading with the input vector\n   * but with length = 1.\n   * @param {Vec2} v - A vector.\n   * @return {Vec2} Vector with length = 0.\n   */\n  static normalized(v) {\n    let l = v.length;\n    return l === 0 ? v : new Vec2(v.x / l, v.y / l);\n  }\n\n  /**\n   * @return {Object} The vector represented in a JS object\n   * Ready to be converted into JSON\n   */\n  toJSObject() {\n    let ret = {};\n\n    ret.x = this.x;\n    ret.y = this.y;\n\n    return ret;\n  }\n\n  /**\n   * Creates a Vec2 class from the given object\n   * @param {Object} obj The object to create the class from\n   * @return {Vec2} The Vec2 object\n   */\n  static fromObject(obj) {\n    return new Vec2(obj.x, obj.y);\n  }\n}\n\nmodule.exports = Vec2;\n", "const Vec2 = require('./vec2');\n\n/**\n * A class representing a ball\n * A ball is an object in the physics engine that\n * has a shape of a circle and it is affected by gravity\n */\nclass Ball {\n  /**\n   * Crete a ball\n   * The mass of the ball is calculated from its radius\n   * @param {Vec2} pos The position of the center of the circle\n   * @param {Vec2} vel The velocity of the circle\n   * @param {number} r The radius of the circe\n   * @param {number} k Coefficient of restitution\n   * @param {number} ang The angular velocity of the ball (optional)\n   * @param {number} fc The friction coefficient (optional, defaults to 0.4)\n   */\n  constructor(pos, vel, r, k, ang, fc) {\n    this.pos = pos.copy;\n    this.lastPos = this.pos.copy;\n    this.r = r;\n    this.fc = 0.4;\n    this.amc = 2 / 5;\n\n    this.rotation = 0;\n\n    if (ang) this.ang = ang;\n    else this.ang = 0;\n\n    if (fc || fc === 0) this.fc = fc;\n\n    if (k) this.k = k;\n    else this.k = 0.8;\n\n    if (vel != undefined) this.vel = vel.copy;\n    else this.vel = new Vec2(0, 0);\n\n    this.id =\n      '_' +\n      Math.random()\n        .toString(36)\n        .substr(2, 9);\n  }\n\n  /**\n   * Get the mass of the ball\n   * @return {number} The mass\n   */\n  get m() {\n    return this.r * this.r * Math.PI;\n  }\n\n  /**\n   * Get the moment of inertia of the ball\n   * @return {number} The moment of inertia\n   */\n  get am() {\n    return this.amc * this.r * this.r * this.m;\n  }\n\n  /**\n   * Gives the angular mass of the ball measured in a given point\n   * @param {Vec2} point The point to measure the angular mass in\n   * @return {number} The adjusted angular mass\n   */\n  getAmInPoint(point) {\n    let ret = this.am;\n\n    ret += Vec2.sub(this.pos, point).sqlength * this.m;\n\n    return ret;\n  }\n\n  /**\n   * Get a copy of the ball that is not a reference to it\n   * @return {Ball} The copy of the ball\n   */\n  get copy() {\n    let ret = new Ball(\n      this.pos.copy,\n      this.vel.copy,\n      this.r,\n      this.k,\n      this.ang,\n      this.fc\n    );\n    ret.lastPos = this.lastPos.copy;\n    ret.rotation = this.rotation;\n    return ret;\n  }\n\n  /**\n   * Moves the ball by the given coordinates\n   * @param {number} x x coordinate\n   * @param {number} y y coordinate\n   */\n  move(x, y) {\n    this.pos.x += x;\n    this.pos.y += y;\n  }\n\n  /**\n   * Rotates the ball with the given angle anticlockwise\n   * @param {number} angle The angle to rotate the ball in radians\n   */\n  rotate(angle) {\n    this.rotation += angle;\n  }\n\n  /**\n   * Checks if two balls are colliding or not\n   * @param {Ball} ball the other ball\n   * @return {boolean} True if they colidre\n   */\n  collided(ball) {\n    if (this.pos.dist(ball.pos) < this.r + ball.r) return true;\n    else return false;\n  }\n\n  /**\n   * Static function for collision between two balls\n   * @param {Ball} ball1 First ball\n   * @param {Ball} ball2 Second ball\n   */\n  static collide(ball1, ball2) {\n    if (!ball1.collided(ball2)) return;\n\n    let pos1 = ball1.pos;\n    let pos2 = ball2.pos;\n    let r1 = ball1.r;\n    let r2 = ball2.r;\n    let k = (ball1.k + ball2.k) / 2;\n    let m1 = ball1.m;\n    let m2 = ball2.m;\n    let dist = Vec2.dist(pos1, pos2);\n    let fc = (ball1.fc + ball2.fc) / 2;\n\n    // Separate the balls\n    let cp1 = pos1.copy;\n    let cp2 = pos2.copy;\n    let too = r1 + r2 - dist;\n    let d = Vec2.sub(pos1, pos2);\n    d.setMag(1);\n    d.mult((too * m2) / (m1 + m2));\n    cp1.add(d);\n    d.setMag(1);\n    d.mult((-too * m1) / (m1 + m2));\n    cp2.add(d);\n    ball1.pos = cp1;\n    ball2.pos = cp2;\n\n    // Stop if they move in opposite directions\n    if (Vec2.dot(d, Vec2.sub(ball1.vel, ball2.vel)) < 0) return;\n\n    d.setMag(1);\n    let vel1Parralel = Vec2.cross(d, ball1.vel);\n    let vel2Parralel = Vec2.cross(d, ball2.vel);\n    let vel1Perpendicular = Vec2.dot(d, ball1.vel);\n    let vel2Perpendicular = Vec2.dot(d, ball2.vel);\n\n    let vk1 = r1 * ball1.ang;\n    let vk2 = r2 * ball2.ang;\n\n    let vel1InPos = vel1Parralel - vk1;\n    let vel2InPos = vel2Parralel + vk2;\n    let effectiveMass1 = 1 / ((1 / m1) + (r1 * r1 / ball1.am));\n    let effectiveMass2 = 1 / ((1 / m2) + (r2 * r2 / ball2.am));\n    let vCommon =\n      (vel1InPos * effectiveMass1 + vel2InPos * effectiveMass2) /\n      (effectiveMass1 + effectiveMass2);\n    let tovCommon1 = vCommon - vel1InPos;\n    let tovCommon2 = vCommon - vel2InPos;\n    let maxDeltaAng1 = tovCommon1 / r1;\n    let maxDeltaAng2 = tovCommon2 / r2;\n\n    // Calculate the new perpendicular velocities\n    let u1Perpendicular =\n      (1 + k) *\n      ((m1 * vel1Perpendicular + m2 * vel2Perpendicular) / (m1 + m2)) -\n      k * vel1Perpendicular;\n    let u2Perpendicular =\n      (1 + k) *\n      ((m1 * vel1Perpendicular + m2 * vel2Perpendicular) / (m1 + m2)) -\n      k * vel2Perpendicular;\n\n    ball1.vel = Vec2.mult(d, u1Perpendicular);\n    ball2.vel = Vec2.mult(d, u2Perpendicular);\n\n    let deltav1Perpendicular = u1Perpendicular - vel1Perpendicular;\n    let deltav2Perpendicular = u2Perpendicular - vel2Perpendicular;\n\n    let deltaAng1 =\n      (-Math.sign(tovCommon1) * (deltav1Perpendicular * fc)) / (ball1.amc * r1);\n    let deltaAng2 =\n      (Math.sign(tovCommon2) * (deltav2Perpendicular * fc)) / (ball2.amc * r2);\n\n    if (deltaAng1 / maxDeltaAng1 > 1) deltaAng1 = maxDeltaAng1;\n    if (deltaAng2 / maxDeltaAng2 > 1) deltaAng2 = maxDeltaAng2;\n\n    ball1.ang -= deltaAng1;\n    ball2.ang += deltaAng2;\n\n    let u1Parralel = vel1Parralel + deltaAng1 * r1;\n    let u2Parralel = vel2Parralel + deltaAng2 * r2;\n\n    d.rotate(Math.PI / 2);\n    ball1.vel.add(Vec2.mult(d, u1Parralel));\n    ball2.vel.add(Vec2.mult(d, u2Parralel));\n  }\n\n  /**\n   *Returns true if the point is inside the ball\n   * @param {Vec2} p The point\n   * @return {boolean} The boolean value\n   */\n  containsPoint(p) {\n    return Vec2.dist(this.pos, p) <= this.r;\n  }\n\n  /**\n   * Calculates the effective velocity of the ball in a\n   * given point from it's velocity and angular velocity\n   * @param {Vec2} point The point to be taken a look at\n   * @return {Vec2} The velocity of the Ball in the given point\n   */\n  velInPlace(point) {\n    let vp = Vec2.sub(point, this.pos);\n    vp.rotate(Math.PI / 2);\n    vp.mult(this.ang);\n    vp.add(this.vel);\n    return vp;\n  }\n\n  /**\n   * Calculates the effective mass of the ball in\n   * a given point when pulled/pushed in a given direction\n   * by a hypothetical force\n   * @param {Vec2} point The given point\n   * @param {Vec2} direction The direction of the force\n   * @return {Number}\n   */\n  effectiveMass(point, direction) {\n    let r = Vec2.sub(point, this.pos);// Vector to the collision point\n    let angle = Vec2.angle(direction, r);\n    let rotationalMass = (Math.sin(angle) ** 2) * (r.length ** 2) / this.am;\n    return 1 / (rotationalMass + (1 / this.m));\n  }\n\n  /**\n   * @return {Object} The ball represented in a JS object\n   * Ready to be converted into JSON\n   */\n  toJSObject() {\n    let ret = {};\n\n    ret.pos = this.pos.toJSObject();\n    ret.lastPos = this.lastPos.toJSObject();\n    ret.r = this.r;\n    ret.fc = this.fc;\n    ret.amc = this.amc;\n    ret.rotation = this.rotation;\n    ret.ang = this.ang;\n    ret.fc = this.fc;\n    ret.k = this.k;\n    ret.vel = this.vel.toJSObject();\n    ret.id = this.id;\n    if (this.layer != undefined) {\n      ret.layer = this.layer;\n    }\n\n    return ret;\n  }\n\n  /**\n   * Creates a Ball class from the given object\n   * @param {Object} obj The object to create the class from\n   * @return {Ball} The Ball object\n   */\n  static fromObject(obj) {\n    let ret = new Ball(\n      Vec2.fromObject(obj.pos),\n      Vec2.fromObject(obj.vel),\n      obj.r,\n      obj.k,\n      obj.ang,\n      obj.fc\n    );\n\n    ret.lastPos = Vec2.fromObject(obj.lastPos);\n    ret.amc = obj.amc;\n    ret.rotation = obj.rotation;\n    ret.vel = Vec2.fromObject(obj.vel);\n    ret.id = obj.id;\n    if (obj.layer != undefined) {\n      ret.layer = obj.layer;\n    }\n\n    return ret;\n  }\n}\n\nmodule.exports = Ball;\n", "const Vec2 = require('./vec2');\n\n/**\n * Class representing a segment of a line\n */\nclass LineSegment {\n  /**\n   * Create a segment\n   * @param {Vec2} a_ Starting point\n   * @param {Vec2} b_ Ending point\n   */\n  constructor(a_, b_) {\n    this.a = a_;\n    this.b = b_;\n  }\n\n  /**\n   * Get the length of the segment\n   * @return {number} The length\n   */\n  get length() {\n    return Vec2.dist(this.a, this.b);\n  }\n\n  /**\n   * Get the distance between a point and the line segment\n   * @param {Vec2} p The point as a vector\n   * @return {number} The distance\n   */\n  distFromPoint(p) {\n    let e = Vec2.sub(this.a, this.b);\n    let A = Vec2.sub(p, this.b);\n    let B = Vec2.sub(p, this.a);\n    let a = A.length;\n    let b = B.length;\n    let c = e.length;\n    if (c === 0) return a;\n    let gamma = Vec2.angle(A, B);\n    let betha = Vec2.angle(A, e);\n    let alpha = Math.PI - gamma - betha;\n    let area = (Math.sin(alpha) * b * c) / 2;\n    let m = (2 * area) / c;\n    if (alpha > Math.PI / 2) return b;\n    if (betha > Math.PI / 2) return a;\n    return m;\n  }\n\n  /**\n   * Get if they intersect or not\n   * If they intersect it returns the intersection point\n   * If they not it returns undefined\n   * @param {LineSegment} segment1 A segment\n   * @param {LineSegment} segment2 Other segment\n   * @return {Vec2} Intersetion point\n   */\n  static intersect(segment1, segment2) {\n    let v1 = Vec2.sub(segment1.b, segment1.a);\n    let a1 = v1.y / v1.x;\n    let c1 = segment1.b.y - segment1.b.x * a1;\n\n    let v2 = Vec2.sub(segment2.b, segment2.a);\n    let a2 = v2.y / v2.x;\n    let c2 = segment2.b.y - segment2.b.x * a2;\n\n    if (v1.x === 0 && v2.x !== 0) {\n      if (\n        (segment1.a.x >= segment2.a.x && segment1.a.x <= segment2.b.x) ||\n        (segment1.a.x <= segment2.a.x && segment1.a.x >= segment2.b.x)\n      ) {\n        let h = a2 * segment1.a.x + c2;\n        if (\n          (h > segment1.a.y && h < segment1.b.y) ||\n          (h < segment1.a.y && h > segment1.b.y)\n        ) {\n          return new Vec2(segment1.a.x, h);\n        }\n      }\n      return undefined;\n    }\n    if (v2.x === 0 && v1.x !== 0) {\n      if (\n        (segment2.a.x >= segment1.a.x && segment2.a.x <= segment1.b.x) ||\n        (segment2.a.x <= segment1.a.x && segment2.a.x >= segment1.b.x)\n      ) {\n        let h = a1 * segment2.a.x + c1;\n        if (\n          (h > segment2.a.y && h < segment2.b.y) ||\n          (h < segment2.a.y && h > segment2.b.y)\n        ) {\n          return new Vec2(segment2.a.x, h);\n        }\n      }\n      return undefined;\n    }\n    if (v1.x === 0 && v2.x === 0) {\n      if (segment1.a.x === segment2.a.x) {\n        let interval1;\n        if (segment1.a.y < segment1.b.y) {\n          interval1 = [segment1.a.y, segment1.b.y];\n        } else {\n          interval1 = [segment1.b.y, segment1.a.y];\n        }\n        let interval2;\n        if (segment2.a.y < segment2.b.y) {\n          interval2 = [segment2.a.y, segment2.b.y];\n        } else {\n          interval2 = [segment2.b.y, segment2.a.y];\n        }\n        let interval = [\n          interval1[0] > interval2[0] ? interval1[0] : interval2[0],\n          interval1[1] < interval2[1] ? interval1[1] : interval2[1],\n        ];\n        if (interval[0] <= interval[1]) {\n          return new Vec2(segment1.a.x, (interval[0] + interval[1]) / 2);\n        }\n      }\n      return undefined;\n    }\n\n    let interval1;\n    if (segment1.a.x < segment1.b.x) {\n      interval1 = [segment1.a.x, segment1.b.x];\n    } else {\n      interval1 = [segment1.b.x, segment1.a.x];\n    }\n    let interval2;\n    if (segment2.a.x < segment2.b.x) {\n      interval2 = [segment2.a.x, segment2.b.x];\n    } else {\n      interval2 = [segment2.b.x, segment2.a.x];\n    }\n    let interval = [\n      interval1[0] > interval2[0] ? interval1[0] : interval2[0],\n      interval1[1] < interval2[1] ? interval1[1] : interval2[1],\n    ];\n    // If they are parralel the only time they intersect is when c1 == c2.\n    if (a1 === a2 && c1 === c2 && interval[0] <= interval[1]) {\n      return new Vec2(\n        (interval[0] + interval[1]) / 2,\n        ((interval[0] + interval[1]) / 2) * a1 + c1\n      );\n    }\n    let x = (c2 - c1) / (a1 - a2);\n    if (x >= interval[0] && x <= interval[1]) {\n      return new Vec2(x, x * a1 + c1);\n    } else return undefined;\n  }\n}\n\nmodule.exports = LineSegment;\n", "const Vec2 = require('./vec2');\nconst LineSegment = require('./linesegment');\n\n/** Class representing a wall\n * Walls are objects that are immovable  and they are rigid\n * It can be convex or concave\n */\nclass Wall {\n  /**\n   * Create a wall\n   * @param {Array<Vec2>} _points Array of points that make up the wall\n   */\n  constructor(_points) {\n    this.points = _points;\n    let pol = this.points;\n    let sum1 = 0;\n    let sum2 = 0;\n    let angle = Vec2.angleACW(\n      Vec2.sub(pol[1], pol[0]),\n      Vec2.sub(pol[pol.length - 1], pol[0])\n    );\n    this.calculateCenterAndRadius();\n\n    sum1 += angle;\n    sum2 += Math.PI * 2 - angle;\n    for (let i = 1; i < pol.length - 1; i++) {\n      angle = Vec2.angleACW(\n        Vec2.sub(pol[(i + 1) % pol.length], pol[i]),\n        Vec2.sub(pol[i - 1], pol[i])\n      );\n      sum1 += angle;\n      sum2 += Math.PI * 2 - angle;\n    }\n    angle = Vec2.angleACW(\n      Vec2.sub(pol[0], pol[pol.length - 1]),\n      Vec2.sub(pol[pol.length - 2], pol[pol.length - 1])\n    );\n    sum1 += angle;\n    sum2 += Math.PI * 2 - angle;\n    if (sum2 > sum1) return;\n    else {\n      let temp = [];\n      for (let i = pol.length - 1; i >= 0; i--) temp.push(pol[i]);\n      this.points = temp;\n    }\n  }\n\n  /**\n   * Function for collision detection and behavior between balls and walls\n   * @param {Ball} ball The ball that is checked if it collides with the wall\n   */\n  collideWithBall(ball) {\n    let heading;\n    let rel;\n\n    this.points.forEach((point, idx) => {\n      let p = new Vec2(point.x, point.y);\n      p.x -= ball.pos.x;\n      p.y -= ball.pos.y;\n      p.mult(-1);\n      if (p.length <= ball.r) {\n        heading = p.heading;\n        rel = p.length;\n      }\n      p = new Vec2(point.x, point.y);\n      let np = new Vec2(\n        this.points[(idx + 1) % this.points.length].x,\n        this.points[(idx + 1) % this.points.length].y\n      );\n      let bp = new Vec2(ball.pos.x, ball.pos.y);\n      let side = new Vec2(np.x - p.x, np.y - p.y);\n      let h = side.heading;\n      p.rotate(-h + Math.PI);\n      np.rotate(-h + Math.PI);\n      bp.rotate(-h + Math.PI);\n      let d = bp.y - (p.y + np.y) / 2;\n      if (d >= -ball.r && d <= ball.r && bp.x >= np.x && bp.x <= p.x) {\n        heading = h - Math.PI / 2;\n        rel = d;\n      }\n    });\n\n    if (heading === 0 || heading) {\n      let pos = new Vec2(ball.pos.x, ball.pos.y);\n      let vel = new Vec2(ball.vel.x, ball.vel.y);\n      pos.rotate(-heading + Math.PI / 2);\n      vel.rotate(-heading + Math.PI / 2);\n\n      if (vel.y > 0) return;\n      vel.y *= -ball.k;\n      pos.y += ball.r - rel;\n      let dvy = vel.y * (1 + 1 / ball.k);\n\n      let deltaAng =\n        (Math.sign(vel.x - ball.ang * ball.r) * (dvy * ball.fc)) /\n        (ball.amc * ball.r);\n      let maxDeltaAng = (vel.x - ball.ang * ball.r) / ball.r;\n\n      if (deltaAng / maxDeltaAng > 1) deltaAng = maxDeltaAng;\n      ball.ang += deltaAng;\n\n      let dvx = deltaAng * ball.am / ball.r / ball.m;\n      vel.x -= dvx;\n\n      pos.rotate(heading - Math.PI / 2);\n      vel.rotate(heading - Math.PI / 2);\n      ball.pos.x = pos.x;\n      ball.pos.y = pos.y;\n      ball.vel.x = vel.x;\n      ball.vel.y = vel.y;\n    }\n  }\n\n  /**\n   *Returns true if the point is inside the body\n   * @param {Vec2} p The point\n   * @return {boolean} The boolean value\n   */\n  containsPoint(p) {\n    let sides = this.sides;\n    let r =\n      Math.max(\n        ...this.points.map((point) => {\n          return Vec2.dist(point, p);\n        })\n      ) + 1;\n\n    let v = Vec2.fromAngle(0);\n    v.setMag(r);\n\n    let testerSegment = new LineSegment(p, Vec2.add(v, p));\n\n    let filtered = sides.filter((side) => {\n      return LineSegment.intersect(side, testerSegment) != undefined;\n    });\n    return filtered.length % 2 == 1;\n  }\n\n  /**\n   * Calculates the center and the bound radius of the wall\n   */\n  calculateCenterAndRadius() {\n    this.center = this.points.reduce((prev, curr) => {\n      return Vec2.add(prev, curr);\n    });\n    this.center.div(this.points.length);\n\n    this.boundRadius = Math.max(\n      this.points.map((p) => {\n        return Vec2.dist(p, this.center);\n      })\n    );\n  }\n\n  /**\n   * Returns an array containing all the sides of the body\n   * @return {Array<LineSegment>} The array of sides\n   */\n  get sides() {\n    return this.points.map((element, index) => {\n      return new LineSegment(\n        element,\n        this.points[(index + 1) % this.points.length]\n      );\n    });\n  }\n\n  /**\n   * @return {Object} The Wall represented in a JS object\n   * Ready to be converted into JSON\n   */\n  toJSObject() {\n    let ret = {};\n\n    ret.points = this.points.map((p) => {\n      return {\n        x: p.x,\n        y: p.y,\n      };\n    });\n\n    return ret;\n  }\n\n  /**\n   * Creates a Wall class from the given object\n   * @param {Object} obj The object to create the class from\n   * @return {Wall} The Wall object\n   */\n  static fromObject(obj) {\n    let ret = new Wall(\n      obj.points.map((p) => {\n        return new Vec2(v.x, v.y);\n      })\n    );\n\n    return ret;\n  }\n}\n\nmodule.exports = Wall;\n", "const Vec2 = require('./vec2');\n\n/**\n * Class representing a string\n * They act like springs in real life\n * You can attach other objects to the ends of them\n * They do not collide with other object neither with each other\n */\nclass Spring {\n  /**\n   * Creates a spring\n   * @param {number} length The unstreched length of the spring\n   * @param {number} springConstant Spring constant\n   */\n  constructor(length, springConstant) {\n    this.length = length;\n    this.springConstant = springConstant;\n    this.pinned = false;\n    this.objects = [];\n    this.rotationLocked = false;\n    this.id =\n      '_' +\n      Math.random()\n      .toString(36)\n      .substr(2, 9);\n  }\n\n  /**\n   * Pins one side of the the spring to a given coordinate in space\n   * @param {number} x x coordinate\n   * @param {number} y y coordinate\n   */\n  pinHere(x, y) {\n    this.pinned = {\n      x: x,\n      y: y,\n    };\n  }\n\n  /**\n   * Removes the pinned tag from the spring\n   * You can now attach it to another object\n   */\n  unpin() {\n    this.pinned = false;\n  }\n\n  /**\n   * Attaches one end of the spring to an object (eg. Ball)\n   * @param {any} object The object that the spring is getting attached to\n   */\n  attachObject(object) {\n    let ob = this.objects;\n    ob.push(object);\n    if (ob.length === 2) {\n      this.pinned = false;\n    }\n    if (ob.length >= 3) {\n      ob = [ob[ob.length - 2], ob[ob.length - 1]];\n    }\n  }\n\n  /**\n   * Locks the objects attached to the ends of the spring\n   * to not rotate around the attach point\n   */\n  lockRotation() {\n    this.rotationLocked = true;\n  }\n\n  /**\n   * Releases the objects attached to the ends of the spring\n   * to rotate around the attach point\n   */\n  unlockRotation() {\n    this.rotationLocked = false;\n  }\n\n  /**\n   * Updates the spring bay the elapsed time\n   * @param {number} t Elapsed time\n   */\n  update(t) {\n    let p1;\n    let p2;\n    if (this.pinned && this.objects[0]) {\n      p2 = this.pinned;\n      p1 = this.objects[0];\n      let dist = new Vec2(p2.x - p1.pos.x, p2.y - p1.pos.y);\n      let dl = dist.length - this.length;\n      dist.setMag(1);\n      dist.mult((dl * this.springConstant * t) / p1.m);\n      p1.vel.x += dist.x;\n      p1.vel.y += dist.y;\n\n      let v = p1.vel;\n      v.rotate(-dist.heading);\n      if (this.rotationLocked) {\n        let s = new Vec2(p2.x, p2.y);\n        let r2 = Vec2.sub(p1.pos, s);\n        let am = r2.length * r2.length * p1.m + p1.am;\n        let ang = (p1.am * p1.ang - r2.length * p1.m * v.y) / am;\n\n        v.y = -ang * r2.length;\n\n        p1.ang = ang;\n      }\n      v.rotate(dist.heading);\n    } else if (this.objects[0] && this.objects[1]) {\n      p1 = this.objects[0];\n      p2 = this.objects[1];\n      let dist = Vec2.sub(p1.pos, p2.pos);\n      let dl = dist.length - this.length;\n      dist.setMag(1);\n      dist.mult(dl * this.springConstant * t);\n      p2.vel.add(Vec2.div(dist, p2.m));\n      p1.vel.add(Vec2.div(dist, -p1.m));\n\n      dist = Vec2.sub(p1.pos, p2.pos);\n      let v1 = p1.vel;\n      let v2 = p2.vel;\n      v1.rotate(-dist.heading);\n      v2.rotate(-dist.heading);\n\n      if (this.rotationLocked) {\n        let s = new Vec2(\n          p1.pos.x * p1.m + p2.pos.x * p2.m,\n          p1.pos.y * p1.m + p2.pos.y * p2.m\n        );\n        s.div(p1.m + p2.m);\n        let r1 = Vec2.sub(p1.pos, s);\n        let r2 = Vec2.sub(p2.pos, s);\n        let am =\n          r1.length * r1.length * p1.m +\n          p1.am +\n          r2.length * r2.length * p2.m +\n          p2.am;\n        let sv = ((v1.y - v2.y) * r2.length) / (r1.length + r2.length) + v2.y;\n        let ang =\n          (p1.am * p1.ang +\n            p2.am * p2.ang -\n            r1.length * p1.m * (v1.y - sv) +\n            r2.length * p2.m * (v2.y - sv)) /\n          am;\n\n        v1.y = -ang * r1.length + sv;\n        v2.y = +ang * r2.length + sv;\n\n        p1.ang = ang;\n        p2.ang = ang;\n      }\n\n      v1.rotate(dist.heading);\n      v2.rotate(dist.heading);\n    }\n  }\n\n  /**\n   * @return {Object} The spring represented in a JS object\n   * Ready to be converted into JSON\n   */\n  toJSObject() {\n    let ret = {};\n\n    ret.length = this.length;\n    ret.springConstant = this.springConstant;\n    ret.pinned = this.pinned;\n    ret.rotationLocked = this.rotationLocked;\n    ret.id = this.id;\n    ret.objects = this.objects.map((o) => o.id);\n    ret.type = this.__proto__ == Spring.prototype ? 'spring' : 'stick';\n\n    return ret;\n  }\n\n  /**\n   * Creates a Spring class from the given object\n   * @param {Object} obj The object to create the class from\n   * @param {Array<Ball>} ballList An array of all the balls in the system\n   * @return {Spring} The Spring object\n   */\n  static fromObject(obj, ballList) {\n    let factory = new TypeSetter();\n    let ret = factory.createStickOrSpring(obj.type,\n      obj.length, obj.springConstant);\n\n    ret.pinned = obj.pinned;\n    ret.rotationLocked = obj.rotationLocked;\n    ret.id = obj.id;\n\n    ret.objects = obj.objects.map((e) => {\n      let arr = ballList.filter((p) => e == p.id);\n      return arr[0];\n    });\n\n    return ret;\n  }\n}\n\n/**\n * Factory for springs and sticks\n */\nfunction TypeSetter() {\n  /**\n   * Creates either a spring or a stick\n   * @param {String} type Specifies the type of the new item\n   * @param {number} length The length of the item\n   * @param {number} springConstant The spring constant\n   * @return {Spring} Returns the item\n   */\n  this.createStickOrSpring = function(type, length, springConstant) {\n    let item;\n    if (type == 'spring') {\n      item = new Spring(length, springConstant);\n    } else if (type == 'stick') {\n      const Stick = require('./stick');\n      item = new Stick(length);\n    }\n\n    return item;\n  };\n}\n\nmodule.exports = Spring;\n", "const Vec2 = require('./vec2');\nconst Spring = require('./spring');\n\n/**\n * Stick class for the physics engine\n * Sticks are not strechable objects that do not collide\n * with other objects but they can hold other objects on their ends\n */\nclass Stick extends Spring {\n  /**\n   * Creates a stick\n   * @param {nuber} length The length of the stick\n   */\n  constructor(length) {\n    super(length, 0);\n    this.springConstant = 0;\n  }\n\n  /**\n   * Updates the stick trough an elapsed time\n   * @param {number} t Elapsed time\n   */\n  update(t) {\n    let p1;\n    let p2;\n    if (this.pinned && this.objects[0]) {\n      p2 = this.pinned;\n      p1 = this.objects[0];\n      let dist = new Vec2(p2.x - p1.pos.x, p2.y - p1.pos.y);\n      dist.setMag(1);\n      dist.mult(-this.length);\n      p1.move(-p1.pos.x + p2.x + dist.x, -p1.pos.y + p2.y + dist.y);\n\n      let v = p1.vel;\n      v.rotate(-dist.heading);\n      v.x = 0;\n\n      if (this.rotationLocked) {\n        let s = new Vec2(p2.x, p2.y);\n        let r2 = Vec2.sub(p1.pos, s);\n        let am = r2.length * r2.length * p1.m + p1.am;\n        let ang = (p1.am * p1.ang - r2.length * p1.m * v.y) / am;\n\n        v.y = -ang * r2.length;\n\n        p1.ang = ang;\n      }\n\n      v.rotate(dist.heading);\n    } else if (this.objects[0] && this.objects[1]) {\n      p1 = this.objects[0];\n      p2 = this.objects[1];\n\n      let dist = Vec2.sub(p1.pos, p2.pos);\n      let dl = this.length - dist.length;\n      dist.setMag(1);\n      let move1 = Vec2.mult(dist, (dl * p2.m) / (p1.m + p2.m));\n      let move2 = Vec2.mult(dist, (-dl * p1.m) / (p1.m + p2.m));\n      p1.move(move1.x, move1.y);\n      p2.move(move2.x, move2.y);\n\n      let v1 = p1.vel;\n      let v2 = p2.vel;\n      v1.rotate(-dist.heading);\n      v2.rotate(-dist.heading);\n      v1.x = v2.x = (p1.m * v1.x + p2.m * v2.x) / (p1.m + p2.m);\n\n      if (this.rotationLocked) {\n        let s = new Vec2(\n          p1.pos.x * p1.m + p2.pos.x * p2.m,\n          p1.pos.y * p1.m + p2.pos.y * p2.m\n        );\n        s.div(p1.m + p2.m);\n        let r1 = Vec2.sub(p1.pos, s);\n        let r2 = Vec2.sub(p2.pos, s);\n        let am =\n          r1.length * r1.length * p1.m +\n          p1.am +\n          r2.length * r2.length * p2.m +\n          p2.am;\n        let sv = ((v1.y - v2.y) * r2.length) / (r1.length + r2.length) + v2.y;\n        let ang =\n          (p1.am * p1.ang +\n            p2.am * p2.ang -\n            r1.length * p1.m * (v1.y - sv) +\n            r2.length * p2.m * (v2.y - sv)) /\n          am;\n\n        v1.y = -ang * r1.length + sv;\n        v2.y = +ang * r2.length + sv;\n\n        p1.ang = ang;\n        p2.ang = ang;\n      }\n\n      v1.rotate(dist.heading);\n      v2.rotate(dist.heading);\n    }\n  }\n}\n\nmodule.exports = Stick;\n", "const Vec2 = require('./vec2');\nconst Ball = require('./ball');\nconst Stick = require('./stick');\nconst LineSegment = require('./linesegment');\n\n/**\n * Class representing a softbody object\n * They work like a ball, with pressure inside\n */\nclass SoftBall {\n  /**\n   * Creates a SoftBall\n   * @param {Vec2} pos The starting position of the soft ball\n   * @param {number} r The radius of the soft ball\n   * @param {number} pressure The \"hardness\" of the soft ball\n   * @param {number} fc Friction coefficient\n   * @param {number} resolution The number of points that make up the ball\n   */\n  constructor(pos, r, pressure, fc, resolution) {\n    this.points = [];\n\n    if (fc || fc === 0) this.fc = fc;\n    else this.fc = 0.4;\n\n    this.pressure = pressure;\n\n    if (!resolution) this.resolution = 30;\n    else this.resolution = resolution;\n\n    r = Math.abs(r);\n    this.r = r;\n\n    let layerNumber = Math.random() * 1000000;\n\n    for (let i = 0; i < this.resolution; i++) {\n      let newPos = new Vec2(pos.x, pos.y);\n      newPos.add(\n        Vec2.mult(Vec2.fromAngle((i / this.resolution) * Math.PI * 2), r)\n      );\n      this.points.push(\n        new Ball(\n          newPos,\n          new Vec2(0, 0),\n          r * Math.sin(Math.PI / this.resolution),\n          0,\n          0,\n          this.fc\n        )\n      );\n      this.points[this.points.length - 1].layer = layerNumber;\n    }\n\n    this.sides = [];\n    for (let i = 0; i < this.resolution; i++) {\n      let side = new Stick(2 * r * Math.sin(Math.PI / this.resolution));\n      side.attachObject(this.points[i]);\n      side.attachObject(this.points[(i + 1) % this.resolution]);\n      if (i % 2 === 0) side.lockRotation();\n      this.sides.push(side);\n    }\n  }\n\n  /**\n   * Updates the pressure-based forces in the soft ball\n   * @param {SoftBall} softBall The soft ball to update\n   * @param {number} t Elapsed time\n   */\n  static updatePressureBasedForces(softBall, t) {\n    let poligons = [];\n    poligons.push([]);\n    softBall.points.forEach((p) => {\n      poligons[0].push(new Vec2(p.pos.x, p.pos.y));\n    });\n\n    if (\n      (function(pol) {\n        let angle = Vec2.angleACW(\n          Vec2.sub(pol[1], pol[0]),\n          Vec2.sub(pol[pol.length - 1], pol[0])\n        );\n        if (angle > Math.PI) return true;\n        for (let i = 1; i < pol.length - 1; i++) {\n          angle = Vec2.angleACW(\n            Vec2.sub(pol[(i + 1) % pol.length], pol[i]),\n            Vec2.sub(pol[i - 1], pol[i])\n          );\n          if (angle > Math.PI) return true;\n        }\n        angle = Vec2.angleACW(\n          Vec2.sub(pol[0], pol[pol.length - 1]),\n          Vec2.sub(pol[pol.length - 2], pol[pol.length - 1])\n        );\n        if (angle > Math.PI) return true;\n        return false;\n      })(poligons[0])\n    ) {\n      const includes = (arr, item) => {\n        for (let i = 0; i < arr.length; i++) {\n          if (arr[i] === item) return true;\n        }\n        return false;\n      };\n      const intersectWithPoligon = function(segment, pol, exceptions) {\n        for (let i = 0; i < pol.length; i++) {\n          if (!includes(exceptions, i)) {\n            let side = new LineSegment(\n              new Vec2(pol[i].x, pol[i].y),\n              new Vec2(pol[(i + 1) % pol.length].x, pol[(i + 1) % pol.length].y)\n            );\n            if (LineSegment.intersect(segment, side)) return true;\n          }\n        }\n        return false;\n      };\n      let found = true;\n\n      checkAllPoligons: while (found) {\n        found = false;\n        for (let i = 0; i < poligons.length; i++) {\n          let pol = poligons[i];\n          let a = Vec2.sub(pol[1], pol[0]);\n          let b = Vec2.sub(pol[pol.length - 1], pol[0]);\n          let angle = Vec2.angleACW(a, b);\n          if (angle > Math.PI) {\n            found = true;\n            let j = 0;\n            let k = j + 2;\n            let newSide = new LineSegment(\n              new Vec2(pol[j].x, pol[j].y),\n              new Vec2(pol[k % pol.length].x, pol[k % pol.length].y)\n            );\n            let newSideHeading = new Vec2(\n              newSide.b.x - newSide.a.x,\n              newSide.b.y - newSide.a.y\n            ).heading;\n            while (\n              !(a.heading > b.heading\n                ? (newSideHeading > a.heading &&\n                    newSideHeading < 2 * Math.PI) ||\n                  (newSideHeading > 0 && newSideHeading < b.heading)\n                : newSideHeading > a.heading && newSideHeading < b.heading) ||\n              intersectWithPoligon(\n                new LineSegment(\n                  new Vec2(pol[j % pol.length].x, pol[j % pol.length].y),\n                  new Vec2(pol[k % pol.length].x, pol[k % pol.length].y)\n                ),\n                pol,\n                [\n                  (pol.length - 1) % pol.length,\n                  j % pol.length,\n                  (k - 1) % pol.length,\n                  k % pol.length,\n                ]\n              )\n            ) {\n              k++;\n              newSide = new LineSegment(\n                new Vec2(pol[j].x, pol[j].y),\n                new Vec2(pol[k % pol.length].x, pol[k % pol.length].y)\n              );\n              newSideHeading = new Vec2(\n                newSide.b.x - newSide.a.x,\n                newSide.b.y - newSide.a.y\n              ).heading;\n            }\n            let pol1 = [];\n            let pol2 = [];\n            for (let l = j; l <= k; l++) {\n              pol1.push(pol[l % pol.length]);\n            }\n            for (let l = k; l <= j + pol.length; l++) {\n              pol2.push(pol[l % pol.length]);\n            }\n            poligons[i] = pol1;\n            poligons.push(pol2);\n            continue checkAllPoligons;\n          }\n          for (let j = 1; j < pol.length; j++) {\n            let a = Vec2.sub(pol[(j + 1) % pol.length], pol[j]);\n            let b = Vec2.sub(pol[j - 1], pol[j]);\n            let angle = Vec2.angleACW(a, b);\n            if (angle > Math.PI) {\n              found = true;\n              let k = j + 2;\n              let newSide = new LineSegment(\n                new Vec2(pol[j].x, pol[j].y),\n                new Vec2(pol[k % pol.length].x, pol[k % pol.length].y)\n              );\n              let newSideHeading = new Vec2(\n                newSide.b.x - newSide.a.x,\n                newSide.b.y - newSide.a.y\n              ).heading;\n              while (\n                !(a.heading > b.heading\n                  ? (newSideHeading > a.heading &&\n                      newSideHeading < 2 * Math.PI) ||\n                    (newSideHeading > 0 && newSideHeading < b.heading)\n                  : newSideHeading > a.heading && newSideHeading < b.heading) ||\n                intersectWithPoligon(newSide, pol, [\n                  (j - 1) % pol.length,\n                  j % pol.length,\n                  (k - 1) % pol.length,\n                  k % pol.length,\n                ])\n              ) {\n                k++;\n                newSide = new LineSegment(\n                  new Vec2(pol[j].x, pol[j].y),\n                  new Vec2(pol[k % pol.length].x, pol[k % pol.length].y)\n                );\n                newSideHeading = new Vec2(\n                  newSide.b.x - newSide.a.x,\n                  newSide.b.y - newSide.a.y\n                ).heading;\n              }\n              let pol1 = [];\n              let pol2 = [];\n              for (let l = j; l <= k; l++) {\n                pol1.push(pol[l % pol.length]);\n              }\n              for (let l = k; l <= j + pol.length; l++) {\n                pol2.push(pol[l % pol.length]);\n              }\n              poligons[i] = pol1;\n              poligons.push(pol2);\n              continue checkAllPoligons;\n            }\n          }\n        }\n      }\n    }\n\n    for (let i = poligons.length - 1; i >= 0; i--) {\n      let pol = poligons[i];\n      while (pol.length > 3) {\n        poligons.push([pol[0], pol[1], pol[2]]);\n        pol.splice(1, 1);\n      }\n    }\n\n    let mSum = 0;\n    poligons.forEach((pol) => {\n      let a = Math.sqrt(\n        Math.pow(pol[0].x - pol[1].x, 2) + Math.pow(pol[0].y - pol[1].y, 2)\n      );\n      let b = Math.sqrt(\n        Math.pow(pol[1].x - pol[2].x, 2) + Math.pow(pol[1].y - pol[2].y, 2)\n      );\n      let c = Math.sqrt(\n        Math.pow(pol[2].x - pol[0].x, 2) + Math.pow(pol[2].y - pol[0].y, 2)\n      );\n      let s = (a + b + c) / 2;\n      let m = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n      mSum += m;\n    });\n\n    let overPressure =\n      softBall.pressure * ((softBall.r * softBall.r * Math.PI) / mSum) -\n      softBall.pressure;\n    softBall.sides.forEach((side) => {\n      let force = Vec2.sub(side.objects[0].pos, side.objects[1].pos);\n      force.mult(overPressure);\n      force.rotate(Math.PI / 2);\n      force.mult(t);\n      side.objects[0].vel.add(Vec2.div(force, side.objects[0].m));\n      side.objects[1].vel.add(Vec2.div(force, side.objects[1].m));\n    });\n  }\n\n  /**\n   * Returns an array containing all the sides of the body\n   * @return {Array<LineSegment>} The array of sides\n   */\n  get sideSegments() {\n    return this.points.map((element, index) => {\n      return new LineSegment(\n        element.pos,\n        this.points[(index + 1) % this.points.length].pos\n      );\n    });\n  }\n\n  /**\n   *Returns true if the point is inside the body\n   * @param {Vec2} p The point\n   * @return {boolean} The boolean value\n   */\n  containsPoint(p) {\n    let sides = this.sideSegments;\n    let r =\n      Math.max(\n        ...this.points.map((point) => {\n          return Vec2.dist(point.pos, p);\n        })\n      ) + 1;\n\n    let v = Vec2.fromAngle(0);\n    v.setMag(r);\n\n    let testerSegment = new LineSegment(p, Vec2.add(v, p));\n\n    let filtered = sides.filter((side) => {\n      return LineSegment.intersect(side, testerSegment) != undefined;\n    });\n    return filtered.length % 2 == 1;\n  }\n\n  /**\n   * @return {Object} The SoftBall represented in a JS object\n   * Ready to be converted into JSON\n   */\n  toJSObject() {\n    let ret = {};\n\n    ret.pressure = this.pressure;\n    ret.fc = this.fc;\n    ret.r = this.r;\n    ret.resolution = this.resolution;\n    ret.points = this.points.map((p) => p.id);\n    ret.sides = this.sides.map((s) => s.id);\n\n    return ret;\n  }\n\n  /**\n   * Creates a SoftBall class from the given object\n   * @param {Object} obj The object to create the class from\n   * @param {Array<Ball>} ballList An array of all the balls in the system\n   * @param {Array<Spring>} springList An array of all the springs in the system\n   * @return {SoftBall} The SoftBall object\n   */\n  static fromObject(obj, ballList, springList) {\n    let ret = Object.create(SoftBall.prototype);\n    console.log(ret);\n\n    ret.pressure = obj.pressure;\n    ret.fc = obj.fc;\n    ret.resolution = obj.resolution;\n    ret.r = obj.r;\n    ret.points = obj.points.map((e) => {\n      let arr = ballList.filter((p) => e == p.id);\n      return arr[0];\n    });\n    ret.sides = obj.sides.map((e) => {\n      let arr = springList.filter((p) => e == p.id);\n      return arr[0];\n    });\n\n    return ret;\n  }\n}\n\nmodule.exports = SoftBall;\n", "const Vec2 = require('./vec2');\nconst LineSegment = require('./linesegment');\n\n/**\n * Class representing a body\n * Bodies are movable objects\n * and they collide with other objects (balls)\n */\nclass Body {\n  /**\n   * Creates a body and calculates it's centre of mass (position)\n   * @param {Array} points The points that make up the body\n   * @param {Vec2} vel The velocity of the body\n   * @param {number} k Coefficient of restitution\n   * @param {number} ang Angular velocity\n   * @param {number} fc Friction coefficient\n   */\n  constructor(points, vel, k, ang, fc) {\n    this.points = points;\n\n    let pol = this.points;\n    let sum1 = 0;\n    let sum2 = 0;\n    let angle = Vec2.angleACW(\n      Vec2.sub(pol[1], pol[0]),\n      Vec2.sub(pol[pol.length - 1], pol[0])\n    );\n    sum1 += angle;\n    sum2 += Math.PI * 2 - angle;\n    for (let i = 1; i < pol.length - 1; i++) {\n      angle = Vec2.angleACW(\n        Vec2.sub(pol[(i + 1) % pol.length], pol[i]),\n        Vec2.sub(pol[i - 1], pol[i])\n      );\n      sum1 += angle;\n      sum2 += Math.PI * 2 - angle;\n    }\n    angle = Vec2.angleACW(\n      Vec2.sub(pol[0], pol[pol.length - 1]),\n      Vec2.sub(pol[pol.length - 2], pol[pol.length - 1])\n    );\n    sum1 += angle;\n    sum2 += Math.PI * 2 - angle;\n    if (sum2 < sum1) {\n      let temp = [];\n      for (let i = pol.length - 1; i >= 0; i--) temp.push(pol[i]);\n      this.points = temp;\n    }\n\n    this.calculatePosAndMass();\n    this.lastPos = this.pos.copy;\n    this.fc = 0.4;\n\n    this.rotation = 0;\n\n    if (ang) this.ang = ang;\n    else this.ang = 0;\n\n    if (fc || fc === 0) this.fc = fc;\n\n    if (k) this.k = k;\n    else this.k = 0.8;\n\n    if (vel != undefined) this.vel = vel.copy;\n    else this.vel = new Vec2(0, 0);\n\n    this.id =\n      '_' +\n      Math.random()\n        .toString(36)\n        .substr(2, 9);\n  }\n\n  /**\n * Gives the angular mass of the body measured in a given point\n * @param {Vec2} point The point to measure the angular mass ins\n * @return {number} The adjusted angular mass\n */\n  getAmInPoint(point) {\n    let ret = this.am;\n\n    ret += Vec2.sub(this.pos, point).sqlength * this.m;\n\n    return ret;\n  }\n\n  /**\n   * Get a copy of the body that is not a reference to it\n   * @return {Body} The copy of the body\n   */\n  get copy() {\n    let pointsCopy = [];\n    for (let i = 0; i < this.points.length; i++) {\n      pointsCopy.push(new Vec2(this.points[i].x, this.points[i].y));\n    }\n    let ret = new Body(pointsCopy, this.vel.copy, this.k, this.ang, this.fc);\n    ret.rotation = this.rotation;\n    ret.lastPos = this.lastPos.copy;\n    ret.pos = this.pos.copy;\n\n    return ret;\n  }\n\n  /**\n   * Moves the body by the given coordinates\n   * It has to move all the points of the body and\n   * also the centre of mass (pos) of the body\n   * @param {number} x x coordinate\n   * @param {number} y y coordinate\n   */\n  move(x, y) {\n    this.pos.x += x;\n    this.pos.y += y;\n    this.points.forEach((p) => {\n      p.x += x;\n      p.y += y;\n    });\n  }\n\n  /**\n   * Function that does the collision detection and\n   * collision behavior between the body and ball\n   * @param {Ball} ball The ball to collide with the body\n   */\n  collideWithBall(ball) {\n    let heading;\n    let rel;\n    let cp;\n\n    if (Vec2.dist(ball.pos, this.pos) > ball.r + this.boundRadius) return;\n\n    this.points.forEach((point, idx) => {\n      let p = new Vec2(point.x, point.y);\n      p.x -= ball.pos.x;\n      p.y -= ball.pos.y;\n      if (p.length <= ball.r) {\n        heading = p.heading + Math.PI;\n        rel = p.length;\n\n        let move = Vec2.fromAngle(heading);\n        move.mult(ball.r - rel);\n        this.move(\n          (move.x * -1 * ball.m) / (this.m + ball.m),\n          (move.y * -1 * ball.m) / (this.m + ball.m)\n        );\n        ball.move(\n          (move.x * 1 * this.m) / (this.m + ball.m),\n          (move.y * 1 * this.m) / (this.m + ball.m)\n        );\n\n        cp = new Vec2(point.x, point.y);\n\n        let a = Vec2.fromAngle(heading);\n        a.mult(-30);\n      }\n      p = new Vec2(point.x, point.y);\n      let np = new Vec2(\n        this.points[(idx + 1) % this.points.length].x,\n        this.points[(idx + 1) % this.points.length].y\n      );\n      let bp = new Vec2(ball.pos.x, ball.pos.y);\n      let side = new Vec2(np.x - p.x, np.y - p.y);\n      let h = side.heading;\n      p.rotate(-h + Math.PI);\n      np.rotate(-h + Math.PI);\n      bp.rotate(-h + Math.PI);\n      let d = bp.y - (p.y + np.y) / 2;\n      if (d >= -ball.r && d <= ball.r && bp.x >= np.x && bp.x <= p.x) {\n        heading = h - Math.PI / 2;\n        rel = d;\n\n        let move = Vec2.fromAngle(heading);\n        move.mult(ball.r - rel);\n        this.move(\n          (move.x * -1 * ball.m) / (this.m + ball.m),\n          (move.y * -1 * ball.m) / (this.m + ball.m)\n        );\n        ball.move(\n          (move.x * 1 * this.m) / (this.m + ball.m),\n          (move.y * 1 * this.m) / (this.m + ball.m)\n        );\n\n        cp = ball.pos.copy;\n        cp.add(Vec2.mult(Vec2.fromAngle(heading + Math.PI), d));\n\n        let a = Vec2.fromAngle(heading);\n        a.mult(-30);\n      }\n    });\n\n    if (heading === 0 || heading) {\n      let v1 = this.vel.copy;\n      let v2 = ball.vel.copy;\n      let ang1 = this.ang;\n      let ang2 = ball.ang;\n      let r1 = Vec2.sub(cp, this.pos);\n      let r2 = Vec2.sub(cp, ball.pos);\n      let am1 = this.am;\n      let am2 = ball.am;\n      let m1 = this.m;\n      let m2 = ball.m;\n      let k = (this.k + ball.k) / 2;\n      let fc = (this.fc + ball.fc) / 2;\n\n      let v1v = r1.copy;\n      let v2v = r2.copy;\n      v1v.rotate(Math.PI / 2);\n      v2v.rotate(-Math.PI / 2);\n      v1v.mult(ang1);\n      v2v.mult(ang2);\n      v1v.add(v1);\n      v2v.add(v2);\n\n      v1v.rotate(-heading);\n      v2v.rotate(-heading);\n\n      let dv1vx =\n        ((1 + k) * (m1 * v1v.x + m2 * v2v.x)) / (m1 + m2) - (k + 1) * v1v.x;\n      let dv2vx =\n        ((1 + k) * (m1 * v1v.x + m2 * v2v.x)) / (m1 + m2) - (k + 1) * v2v.x;\n\n      let vk = (v1v.y * m1 + v2v.y * m2) / (m1 + m2);\n\n      let dv1vy = -Math.sign(v1v.y) * fc * dv1vx;\n      let dv2vy = -Math.sign(v2v.y) * fc * dv2vx;\n      if (Math.abs(vk - v1v.y) > Math.abs(dv1vy)) dv1vy = vk - v1v.y;\n      if (Math.abs(vk - v2v.y) > Math.abs(dv2vy)) dv2vy = vk - v2v.y;\n\n      let dv1v = new Vec2(dv1vx, dv1vy);\n      let dv2v = new Vec2(dv2vx, dv2vy);\n      dv1v.rotate(heading);\n      dv2v.rotate(heading);\n\n      v1.add(dv1v);\n      v2.add(dv2v);\n\n      dv1v.rotate(-r1.heading);\n      dv2v.rotate(-r2.heading);\n\n      let dang1 =\n        (dv1v.y * m1 * r1.length) / (am1 + r1.length * r1.length * m1);\n      let dang2 =\n        -(dv2v.y * m2 * r2.length) / (am2 + r2.length * r2.length * m2);\n\n      ang1 += dang1;\n      ang2 += dang2;\n\n      let vp1 = Vec2.fromAngle(r1.heading - Math.PI / 2);\n      vp1.mult(r1.length * dang1);\n      let vp2 = Vec2.fromAngle(r2.heading - Math.PI / 2);\n      vp2.mult(r2.length * dang2);\n      v2.sub(vp2);\n      v1.add(vp1);\n\n      this.vel = v1;\n      ball.vel = v2;\n\n      this.ang = ang1;\n      ball.ang = ang2;\n    }\n  }\n\n  /**\n   * Calculates the mass, moment od intertia and\n   * the centre of mass of the body\n   */\n  calculatePosAndMass() {\n    let poligons = [];\n    poligons.push([]);\n    this.points.forEach((p) => {\n      poligons[0].push(new Vec2(p.x, p.y));\n    });\n\n    if (this.isConcave) {\n      const includes = (arr, item) => {\n        for (let i = 0; i < arr.length; i++) {\n          if (arr[i] === item) return true;\n        }\n        return false;\n      };\n      const intersectWithPoligon = function(segment, pol, exceptions) {\n        for (let i = 0; i < pol.length; i++) {\n          if (!includes(exceptions, i)) {\n            let side = new LineSegment(\n              new Vec2(pol[i].x, pol[i].y),\n              new Vec2(pol[(i + 1) % pol.length].x, pol[(i + 1) % pol.length].y)\n            );\n            if (LineSegment.intersect(segment, side)) return true;\n          }\n        }\n        return false;\n      };\n      let found = true;\n\n      checkAllPoligons: while (found) {\n        found = false;\n        for (let i = 0; i < poligons.length; i++) {\n          let pol = poligons[i];\n          let a = Vec2.sub(pol[1], pol[0]);\n          let b = Vec2.sub(pol[pol.length - 1], pol[0]);\n          let angle = Vec2.angleACW(a, b);\n          if (angle > Math.PI) {\n            found = true;\n            let j = 0;\n            let k = j + 2;\n            let newSide = new LineSegment(\n              new Vec2(pol[j].x, pol[j].y),\n              new Vec2(pol[k % pol.length].x, pol[k % pol.length].y)\n            );\n            let newSideHeading = new Vec2(\n              newSide.b.x - newSide.a.x,\n              newSide.b.y - newSide.a.y\n            ).heading;\n            while (\n              !(a.heading > b.heading\n                ? (newSideHeading > a.heading &&\n                  newSideHeading < 2 * Math.PI) ||\n                (newSideHeading > 0 && newSideHeading < b.heading)\n                : newSideHeading > a.heading && newSideHeading < b.heading) ||\n              intersectWithPoligon(\n                new LineSegment(\n                  new Vec2(pol[j % pol.length].x, pol[j % pol.length].y),\n                  new Vec2(pol[k % pol.length].x, pol[k % pol.length].y)\n                ),\n                pol,\n                [\n                  (pol.length - 1) % pol.length,\n                  j % pol.length,\n                  (k - 1) % pol.length,\n                  k % pol.length,\n                ]\n              )\n            ) {\n              k++;\n              newSide = new LineSegment(\n                new Vec2(pol[j].x, pol[j].y),\n                new Vec2(pol[k % pol.length].x, pol[k % pol.length].y)\n              );\n              newSideHeading = new Vec2(\n                newSide.b.x - newSide.a.x,\n                newSide.b.y - newSide.a.y\n              ).heading;\n            }\n            let pol1 = [];\n            let pol2 = [];\n            for (let l = j; l <= k; l++) {\n              pol1.push(pol[l % pol.length]);\n            }\n            for (let l = k; l <= j + pol.length; l++) {\n              pol2.push(pol[l % pol.length]);\n            }\n            poligons[i] = pol1;\n            poligons.push(pol2);\n            continue checkAllPoligons;\n          }\n          for (let j = 1; j < pol.length; j++) {\n            let a = Vec2.sub(pol[(j + 1) % pol.length], pol[j]);\n            let b = Vec2.sub(pol[j - 1], pol[j]);\n            let angle = Vec2.angleACW(a, b);\n            if (angle > Math.PI) {\n              found = true;\n              let k = j + 2;\n              let newSide = new LineSegment(\n                new Vec2(pol[j].x, pol[j].y),\n                new Vec2(pol[k % pol.length].x, pol[k % pol.length].y)\n              );\n              let newSideHeading = new Vec2(\n                newSide.b.x - newSide.a.x,\n                newSide.b.y - newSide.a.y\n              ).heading;\n              while (\n                !(a.heading > b.heading\n                  ? (newSideHeading > a.heading &&\n                    newSideHeading < 2 * Math.PI) ||\n                  (newSideHeading > 0 && newSideHeading < b.heading)\n                  : newSideHeading > a.heading && newSideHeading < b.heading) ||\n                intersectWithPoligon(newSide, pol, [\n                  (j - 1) % pol.length,\n                  j % pol.length,\n                  (k - 1) % pol.length,\n                  k % pol.length,\n                ])\n              ) {\n                k++;\n                newSide = new LineSegment(\n                  new Vec2(pol[j].x, pol[j].y),\n                  new Vec2(pol[k % pol.length].x, pol[k % pol.length].y)\n                );\n                newSideHeading = new Vec2(\n                  newSide.b.x - newSide.a.x,\n                  newSide.b.y - newSide.a.y\n                ).heading;\n              }\n              let pol1 = [];\n              let pol2 = [];\n              for (let l = j; l <= k; l++) {\n                pol1.push(pol[l % pol.length]);\n              }\n              for (let l = k; l <= j + pol.length; l++) {\n                pol2.push(pol[l % pol.length]);\n              }\n              poligons[i] = pol1;\n              poligons.push(pol2);\n              continue checkAllPoligons;\n            }\n          }\n        }\n      }\n    }\n\n    for (let i = poligons.length - 1; i >= 0; i--) {\n      let pol = poligons[i];\n      while (pol.length > 3) {\n        poligons.push([pol[0], pol[1], pol[2]]);\n        pol.splice(1, 1);\n      }\n    }\n\n    let mSum = 0;\n    let amSum = 0;\n    let pSum = new Vec2(0, 0);\n    poligons.forEach((pol) => {\n      let a = Math.sqrt(\n        Math.pow(pol[0].x - pol[1].x, 2) + Math.pow(pol[0].y - pol[1].y, 2)\n      );\n      let b = Math.sqrt(\n        Math.pow(pol[1].x - pol[2].x, 2) + Math.pow(pol[1].y - pol[2].y, 2)\n      );\n      let c = Math.sqrt(\n        Math.pow(pol[2].x - pol[0].x, 2) + Math.pow(pol[2].y - pol[0].y, 2)\n      );\n      let s = (a + b + c) / 2;\n      let m = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n      mSum += m;\n      pSum.x += (m * (pol[0].x + pol[1].x + pol[2].x)) / 3;\n      pSum.y += (m * (pol[0].y + pol[1].y + pol[2].y)) / 3;\n    });\n    pSum.div(mSum);\n    this.pos = pSum;\n    this.m = mSum;\n\n    // calculating the moment of inertia finally\n    for (let pol of poligons) {\n      let a = Math.sqrt(\n        Math.pow(pol[0].x - pol[1].x, 2) + Math.pow(pol[0].y - pol[1].y, 2)\n      );\n      let b = Math.sqrt(\n        Math.pow(pol[1].x - pol[2].x, 2) + Math.pow(pol[1].y - pol[2].y, 2)\n      );\n      let c = Math.sqrt(\n        Math.pow(pol[2].x - pol[0].x, 2) + Math.pow(pol[2].y - pol[0].y, 2)\n      );\n      let w = Math.max(a, b, c);\n      let s = (a + b + c) / 2;\n      let m = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n      let h = (2 * m) / w;\n      let wpartial = Math.sqrt(Math.min(a, c, b) ** 2 - h * h);\n      let am = (h * w * (h * h + w * w)) / 24;\n      let d = Math.sqrt((h * h) / 36 + (Math.abs(wpartial - w / 2) / 3) ** 2);\n      am -= d * d * m;\n      am +=\n        new Vec2(\n          (pol[0].x + pol[1].x + pol[2].x) / 3,\n          (pol[0].y + pol[1].y + pol[2].y) / 3\n        ).dist(this.pos) **\n        2 *\n        m;\n      amSum += am;\n    }\n    this.am = amSum;\n\n    this.boundRadius = Math.max(\n      ...this.points.map((p) => {\n        return Vec2.dist(p, this.pos);\n      })\n    );\n  }\n\n  /**\n   * Rotates the body around it's centre of mass by a given ange\n   * Has to do the transformation for all the points\n   * @param {number} angle Rotation angle\n   */\n  rotate(angle) {\n    this.points.forEach((p) => {\n      let point = new Vec2(p.x, p.y);\n      point.sub(this.pos);\n      point.rotate(angle);\n      point.add(this.pos);\n      p.x = point.x;\n      p.y = point.y;\n    });\n    this.rotation += angle;\n  }\n\n  /**\n   * Finds out if the body is concave or not\n   * @return {Boolean} True if the body is concave\n   */\n  get isConcave() {\n    let pol = this.points;\n    let angle = Vec2.angleACW(\n      Vec2.sub(pol[1], pol[0]),\n      Vec2.sub(pol[pol.length - 1], pol[0])\n    );\n    if (angle > Math.PI) return true;\n    for (let i = 1; i < pol.length - 1; i++) {\n      angle = Vec2.angleACW(\n        Vec2.sub(pol[(i + 1) % pol.length], pol[i]),\n        Vec2.sub(pol[i - 1], pol[i])\n      );\n      if (angle > Math.PI) return true;\n    }\n    angle = Vec2.angleACW(\n      Vec2.sub(pol[0], pol[pol.length - 1]),\n      Vec2.sub(pol[pol.length - 2], pol[pol.length - 1])\n    );\n    if (angle > Math.PI) return true;\n    return false;\n  }\n\n  /**\n   * Does the collision algorithm between two bodies\n   * @param {Body} b1 First body\n   * @param {Body} b2 Second body\n   */\n  static collide(b1, b2) {\n    let matches = 0;\n    let heading = 0;\n    let cp = new Vec2(0, 0);\n    let cps = [];\n    let intersect = false;\n    b1.points.forEach((p, idx) => {\n      let side1 = new LineSegment(\n        new Vec2(p.x, p.y),\n        new Vec2(\n          b1.points[(idx + 1) % b1.points.length].x,\n          b1.points[(idx + 1) % b1.points.length].y\n        )\n      );\n      b2.points.forEach((pp, idxx) => {\n        let side2 = new LineSegment(\n          new Vec2(pp.x, pp.y),\n          new Vec2(\n            b2.points[(idxx + 1) % b2.points.length].x,\n            b2.points[(idxx + 1) % b2.points.length].y\n          )\n        );\n        let sect = LineSegment.intersect(side1, side2);\n        if (sect) {\n          matches++;\n          cp.add(sect);\n          cps.push(sect);\n          intersect = true;\n        }\n      });\n    });\n\n    if (!intersect) return;\n    cp.div(matches);\n\n    for (let i = 0; i < Math.floor(matches / 2); i++) {\n      heading += Vec2.sub(cps[2 * i + 1], cps[2 * i]).heading;\n    }\n    heading /= matches / 2;\n    heading += Math.PI / 2;\n\n    let a = Vec2.fromAngle(heading);\n\n    let startAng1 = b1.ang;\n    let startVel1 = b1.vel.copy;\n    let startAng2 = b2.ang;\n    let startVel2 = b2.vel.copy;\n\n    let move1Min = 0;\n    let move1Max = 0;\n    let move2Min = 0;\n    let move2Max = 0;\n    for (let point of b1.points) {\n      move1Min = Math.min(\n        Vec2.dot(a, Vec2.sub(new Vec2(point.x, point.y), cp)),\n        move1Min\n      );\n      move1Max = Math.max(\n        Vec2.dot(a, Vec2.sub(new Vec2(point.x, point.y), cp)),\n        move1Max\n      );\n    }\n    for (let point of b2.points) {\n      move2Min = Math.min(\n        Vec2.dot(a, Vec2.sub(new Vec2(point.x, point.y), cp)),\n        move2Min\n      );\n      move2Max = Math.max(\n        Vec2.dot(a, Vec2.sub(new Vec2(point.x, point.y), cp)),\n        move2Max\n      );\n    }\n    if (Math.abs(move1Min - move2Max) < Math.abs(move2Min - move1Max)) {\n      b1.move(-a.x * move1Min, -a.y * move1Min);\n      b2.move(-a.x * move2Max, -a.y * move2Max);\n    } else {\n      b1.move(-a.x * move1Max, -a.y * move1Max);\n      b2.move(-a.x * move2Min, -a.y * move2Min);\n    }\n\n    let k = (b1.k + b2.k) / 2;\n    let collisionPoints = cps;\n\n    let endAngs1 = [];\n    let endAngs2 = [];\n    let endVels1 = [];\n    let endVels2 = [];\n\n    for (let collisionPoint of collisionPoints) {\n      // Deal with the change in velocity by the collision\n      let normal = Vec2.fromAngle(heading);\n      let vel1 = b1.vel;\n      let vel2 = b2.vel;\n      let pos1 = b1.pos;\n      let pos2 = b2.pos;\n      let r1 = Vec2.sub(pos1, collisionPoint);\n      let r2 = Vec2.sub(pos2, collisionPoint);\n      let angle1 = Vec2.angleACW(normal, r1);\n      let angle2 = Vec2.angleACW(normal, r2);\n      let basicAngle1 = Vec2.angle(normal, r1);\n      let basicAngle2 = Vec2.angle(normal, r2);\n\n      let velInCollisionPoint1 = vel1.copy;\n      let velInCollisionPoint2 = vel2.copy;\n      let rotater1 = r1.copy;\n      let rotater2 = r2.copy;\n      rotater1.mult(-1 * b1.ang);\n      rotater2.mult(-1 * b2.ang);\n      rotater2.rotate(Math.PI / 2);\n      rotater2.rotate(Math.PI / 2);\n      velInCollisionPoint1.add(rotater1);\n      velInCollisionPoint2.add(rotater2);\n      let perpVel1 = Vec2.dot(normal, velInCollisionPoint1);\n      let perpVel2 = Vec2.dot(normal, velInCollisionPoint2);\n      if (Vec2.dot(normal, r1) > Vec2.dot(normal, r2)) {\n        if (perpVel1 >= perpVel2) return;\n      } else if (perpVel2 >= perpVel1) return;\n\n      let m1 =\n        b1.m * Math.abs(Math.cos(basicAngle1)) +\n        (Math.abs(Math.sin(basicAngle1)) * b1.am) / r1.length / r1.length;\n      let m2 =\n        b2.m * Math.abs(Math.cos(basicAngle2)) +\n        (Math.abs(Math.sin(basicAngle2)) * b2.am) / r2.length / r2.length;\n      let perpU1 =\n        (1 + k) * ((m1 * perpVel1 + m2 * perpVel2) / (m1 + m2)) - k * perpVel1;\n      let perpU2 =\n        (1 + k) * ((m1 * perpVel1 + m2 * perpVel2) / (m1 + m2)) - k * perpVel2;\n\n      let deltaVel1;\n      let deltaVel2;\n      if (Vec2.dot(normal, r1) > Vec2.dot(normal, r2)) {\n        if (perpU2 >= perpU1) {\n          deltaVel1 = Vec2.mult(Vec2.normalized(normal), -perpU1 + perpVel1);\n          deltaVel2 = Vec2.mult(Vec2.normalized(normal), -perpU2 + perpVel2);\n        } else {\n          deltaVel1 = Vec2.mult(Vec2.normalized(normal), -perpU1 + perpVel1);\n          deltaVel2 = Vec2.mult(Vec2.normalized(normal), -perpU2 + perpVel2);\n        }\n      } else if (perpU2 <= perpU1) {\n        deltaVel1 = Vec2.mult(Vec2.normalized(normal), -perpU1 + perpVel1);\n        deltaVel2 = Vec2.mult(Vec2.normalized(normal), -perpU2 + perpVel2);\n      } else {\n        deltaVel1 = Vec2.mult(Vec2.normalized(normal), -perpU1 + perpVel1);\n        deltaVel2 = Vec2.mult(Vec2.normalized(normal), -perpU2 + perpVel2);\n      }\n\n      deltaVel1 = Vec2.mult(Vec2.normalized(normal), perpU1 - perpVel1);\n      deltaVel2 = Vec2.mult(Vec2.normalized(normal), perpU2 - perpVel2);\n\n      let deltaAng1 = deltaVel1.copy;\n      let deltaAng2 = deltaVel2.copy;\n\n      deltaVel1.mult(Math.cos(basicAngle1));\n      deltaVel2.mult(Math.cos(basicAngle2));\n      if (Vec2.dot(deltaVel1, r1) < 0) deltaVel1.mult(-1);\n      if (Vec2.dot(deltaVel2, r2) < 0) deltaVel2.mult(-1);\n      b1.vel.add(deltaVel1);\n      b2.vel.add(deltaVel2);\n\n      deltaAng1.sub(Vec2.mult(normal, Vec2.dot(normal, deltaVel1)));\n      deltaAng1.div(r1.length);\n      deltaAng1.rotate(Math.PI / 2);\n      deltaAng1 = Vec2.dot(deltaAng1, r1) / r1.length;\n      b1.ang += deltaAng1;\n\n      deltaAng2.sub(Vec2.mult(normal, Vec2.dot(normal, deltaVel2)));\n      deltaAng2.div(r2.length);\n      deltaAng2.rotate(Math.PI / 2);\n      deltaAng2 = Vec2.dot(deltaAng2, r2) / r2.length;\n      b2.ang += deltaAng2;\n\n      endAngs1.push(b1.ang);\n      endVels1.push(b1.vel);\n      endAngs2.push(b2.ang);\n      endVels2.push(b2.vel);\n\n      b1.ang = startAng1;\n      b1.vel = startVel1;\n      b2.ang = startAng2;\n      b2.vel = startVel2;\n\n      break;\n\n      // Then deal with friction\n      let massParralel =\n        this.m * Math.abs(Math.sin(angle)) +\n        (this.am / r.length / r.length) * Math.abs(Math.cos(angle));\n\n      deltaVel = Vec2.mult(Vec2.normalized(normal), -1 * perpVel);\n\n      let parralelVec = normal.copy;\n      parralelVec.rotate(Math.PI / 2);\n      parralelVec.mult(Math.sign(Vec2.dot(parralelVec, velInCollisionPoint)));\n      if (parralelVec.length == 0) return;\n\n      let parralelVel = Vec2.dot(velInCollisionPoint, parralelVec);\n      let deltaMomentum = Vec2.mult(deltaVel, massInPoint);\n      let deltaVelParralel = Vec2.div(deltaMomentum, massParralel);\n      if (massParralel == 0) deltaVelParralel = 0;\n\n      deltaVelParralel.mult(this.fc);\n      deltaVelParralel = Vec2.mult(parralelVec, deltaVelParralel.length);\n      if (deltaVelParralel.length > parralelVel) {\n        deltaVelParralel.setMag(parralelVel);\n      }\n\n      angle = Vec2.angleACW(parralelVec, r);\n\n      deltaVel = deltaVelParralel;\n      deltaAng = deltaVel.copy;\n\n      deltaVel.mult(Math.cos(angle));\n      this.vel.add(deltaVel);\n\n      deltaAng = deltaAng.length / r.length;\n      deltaAng *= Math.sin(angle);\n      this.ang -= deltaAng;\n\n      endVels.push(this.vel);\n      this.vel = startingVel.copy;\n\n      endAngs.push(this.ang);\n      this.ang = startingAng;\n    }\n\n    if (endAngs1.length != endVels1.length) return;\n    if (endAngs1.length == 0) return;\n    if (endVels1.length == 0) return;\n    if (endAngs2.length != endVels2.length) return;\n    if (endAngs2.length == 0) return;\n    if (endVels2.length == 0) return;\n\n    b1.vel = endVels1.reduce((prev, curr) => {\n      return Vec2.add(prev, curr);\n    });\n    b1.vel.div(endVels1.length);\n    b1.ang = endAngs1.reduce((prev, curr) => {\n      return prev + curr;\n    });\n    b1.ang /= endAngs1.length;\n    b2.vel = endVels2.reduce((prev, curr) => {\n      return Vec2.add(prev, curr);\n    });\n    b2.vel.div(endVels2.length);\n    b2.ang = endAngs2.reduce((prev, curr) => {\n      return prev + curr;\n    });\n    b2.ang /= endAngs2.length;\n\n    return;\n\n    if (!isFinite(this.vel.x) || !isFinite(this.vel.y) || !isFinite(this.ang)) {\n      this.vel = startingVel;\n      this.ang = startingAng;\n    }\n  }\n\n  /**\n   * Detects and reacts to collision with a fixedBall\n   * @param {FixedBall} fixedBall The fixedBall to take the collision with\n   */\n  collideWithFixedBall(fixedBall) {\n    let fbPos = new Vec2(fixedBall.x, fixedBall.y);\n    let collisionPoint;\n\n    if (Vec2.dist(fbPos, this.pos) > this.boundRadius + fixedBall.r) return;\n\n    // Detect collision with sides\n    for (let side of this.sides) {\n      let angle1;\n      let angle2;\n      angle1 = Vec2.angle(Vec2.sub(side.a, side.b), Vec2.sub(fbPos, side.b));\n      angle2 = Vec2.angle(Vec2.sub(side.b, side.a), Vec2.sub(fbPos, side.a));\n\n      if (angle1 < Math.PI / 2 && angle2 < Math.PI / 2) {\n        let d = side.distFromPoint(fbPos);\n        if (d <= fixedBall.r) {\n          let perp = Vec2.sub(side.a, side.b);\n          perp.rotate(Math.PI / 2);\n          perp.setMag(fixedBall.r * 2);\n          let negPerp = Vec2.mult(perp, -1);\n          let detectorSegment = new LineSegment(\n            Vec2.add(perp, fbPos),\n            Vec2.add(negPerp, fbPos)\n          );\n          collisionPoint = LineSegment.intersect(detectorSegment, side);\n          if (collisionPoint != undefined) {\n            perp = Vec2.sub(collisionPoint, fbPos);\n            perp.setMag(fixedBall.r - perp.length);\n            this.move(perp.x, perp.y);\n          }\n        }\n      }\n    }\n\n    // Detect collison with points\n    if (!collisionPoint || collisionPoint == undefined) {\n      pointLoop: for (let point of this.points) {\n        if (Vec2.dist(point, fbPos) < fixedBall.r) {\n          let d = Vec2.sub(point, fbPos);\n          d.setMag(fixedBall.r - d.length);\n          this.move(d.x, d.y);\n          d.setMag(fixedBall.r);\n          collisionPoint = Vec2.add(fbPos, d);\n          break pointLoop;\n        }\n      }\n    }\n\n    if (!collisionPoint || collisionPoint == undefined) return;\n\n    // Deal with the change in velocity by the collision\n    let vel = this.vel;\n    let pos = this.pos;\n    let normal = Vec2.sub(collisionPoint, fbPos);\n    normal.setMag(1);\n    let r = Vec2.sub(pos, collisionPoint);\n    let angle = Vec2.angleACW(normal, r);\n\n    let velInCollisionPoint = vel.copy;\n    let rotater = r.copy;\n    rotater.mult(-1 * this.ang);\n    rotater.rotate(Math.PI / 2);\n    velInCollisionPoint.add(rotater);\n    let perpVel = Vec2.dot(normal, velInCollisionPoint);\n    if (perpVel >= 0) return;\n    perpVel *= 1 + this.k;\n\n    let deltaVel = Vec2.mult(Vec2.normalized(normal), -1 * perpVel);\n    let deltaAng = deltaVel.copy;\n\n    deltaVel.mult(Math.cos(angle));\n    this.vel.add(deltaVel);\n\n    deltaAng = deltaAng.length / r.length;\n    deltaAng *= Math.sin(angle);\n    this.ang += deltaAng;\n\n    // Then deal with friction\n    let massInPoint =\n      this.m * Math.abs(Math.cos(angle)) +\n      (this.am / r.length / r.length) * Math.abs(Math.sin(angle));\n    let massParralel =\n      this.m * Math.abs(Math.sin(angle)) +\n      (this.am / r.length / r.length) * Math.abs(Math.cos(angle));\n\n    deltaVel = Vec2.mult(Vec2.normalized(normal), -1 * perpVel);\n\n    let parralelVec = normal.copy;\n    parralelVec.rotate(Math.PI / 2);\n    parralelVec.mult(Math.sign(Vec2.dot(parralelVec, velInCollisionPoint)));\n    if (parralelVec.length == 0) return;\n\n    let parralelVel = Vec2.dot(velInCollisionPoint, parralelVec);\n    let deltaMomentum = Vec2.mult(deltaVel, massInPoint);\n    let deltaVelParralel = Vec2.div(deltaMomentum, massParralel);\n    if (massParralel == 0) deltaVelParralel = 0;\n\n    deltaVelParralel.mult(this.fc);\n    deltaVelParralel = Vec2.mult(parralelVec, deltaVelParralel.length);\n    if (deltaVelParralel.length > parralelVel) {\n      deltaVelParralel.setMag(parralelVel);\n    }\n\n    angle = Vec2.angleACW(parralelVec, r);\n\n    deltaVel = deltaVelParralel;\n    deltaAng = deltaVel.copy;\n\n    deltaVel.mult(Math.cos(angle));\n    this.vel.add(deltaVel);\n\n    deltaAng = deltaAng.length / r.length;\n    deltaAng *= Math.sin(angle);\n    this.ang -= deltaAng;\n  }\n\n  /**\n   * Does a collision with a wall\n   * @param {Wall} wall The wall to collide with\n   * @return {Array<LineSegment>} Debug data provided\n   */\n  collideWithWall(wall) {\n    if (\n      this.boundRadius + wall.boundRadius <\n      Vec2.dist(this.pos, wall.center)\n    ) {\n      return;\n    }\n\n    let sides = this.sides;\n\n    let debugData = [];\n    let collisionPoints = [];\n    for (let bodySide of sides) {\n      for (let wallSide of wall.sides) {\n        let collisionPoint = LineSegment.intersect(bodySide, wallSide);\n        if (collisionPoint != undefined) {\n          collisionPoints.push(collisionPoint);\n        }\n      }\n    }\n    if (collisionPoints.length < 2) return;\n\n    let startingVel = this.vel.copy;\n    let startingAng = this.ang;\n\n    let endVels = [];\n    let endAngs = [];\n\n    // Need to adjust the position of the Body\n    let normal = Vec2.sub(...collisionPoints);\n    normal.rotate(Math.PI / 2);\n\n    let r = Vec2.sub(collisionPoints[0], this.pos);\n    if (Vec2.dot(normal, r) > 0) normal.mult(-1);\n    normal.setMag(1);\n    if (Vec2.dot(normal, Vec2.sub(this.pos, wall.center)) < 0) {\n      normal.mult(-1);\n    }\n\n    debugData.push(new LineSegment(...collisionPoints));\n    debugData.push(\n      new LineSegment(\n        collisionPoints[0],\n        Vec2.add(collisionPoints[0], Vec2.mult(normal, 20))\n      )\n    );\n    debugData.push(\n      new LineSegment(\n        collisionPoints[1],\n        Vec2.add(collisionPoints[1], Vec2.mult(normal, 20))\n      )\n    );\n    let moveAmounts = [];\n\n    let cp = collisionPoints[0];\n    for (let p of wall.points) {\n      let pointVec = Vec2.sub(p, cp);\n      let dist = Vec2.dot(pointVec, normal);\n      if (dist > 0) {\n        moveAmounts.push(dist);\n      }\n    }\n\n    if (moveAmounts.length > 0) {\n      let moveVector = normal.copy;\n      moveVector.mult(Math.max(...moveAmounts));\n      this.move(moveVector.x, moveVector.y);\n    }\n\n    moveAmounts = [];\n    let midCp = Vec2.add(...collisionPoints);\n    midCp.div(2);\n    if (this.containsPoint(midCp)) {\n      for (let side of sides) {\n        moveAmounts.push(side.distFromPoint(midCp));\n      }\n    }\n\n    if (moveAmounts.length > 0) {\n      let moveVector = normal.copy;\n      moveVector.mult(Math.min(...moveAmounts));\n      if (moveVector.length < this.boundRadius / 2) {\n        this.move(moveVector.x, moveVector.y);\n      }\n    }\n\n    for (let collisionPoint of collisionPoints) {\n      // Deal with the change in velocity by the collision\n      let vel = this.vel;\n      let pos = this.pos;\n      let r = Vec2.sub(pos, collisionPoint);\n      let angle = Vec2.angleACW(normal, r);\n\n      let velInCollisionPoint = vel.copy;\n      let rotater = r.copy;\n      rotater.mult(-1 * this.ang);\n      rotater.rotate(Math.PI / 2);\n      velInCollisionPoint.add(rotater);\n      let perpVel = Vec2.dot(normal, velInCollisionPoint);\n      if (perpVel >= 0) return;\n      perpVel *= 1 + this.k;\n\n      let deltaVel = Vec2.mult(Vec2.normalized(normal), -1 * perpVel);\n      let deltaAng = deltaVel.copy;\n\n      deltaVel.mult(Math.cos(angle));\n      this.vel.add(deltaVel);\n\n      deltaAng = deltaAng.length / r.length;\n      deltaAng *= Math.sin(angle);\n      this.ang += deltaAng;\n\n      // Then deal with friction\n      let massInPoint =\n        this.m * Math.abs(Math.cos(angle)) +\n        (this.am / r.length / r.length) * Math.abs(Math.sin(angle));\n      let massParralel =\n        this.m * Math.abs(Math.sin(angle)) +\n        (this.am / r.length / r.length) * Math.abs(Math.cos(angle));\n\n      deltaVel = Vec2.mult(Vec2.normalized(normal), -1 * perpVel);\n\n      let parralelVec = normal.copy;\n      parralelVec.rotate(Math.PI / 2);\n      parralelVec.mult(Math.sign(Vec2.dot(parralelVec, velInCollisionPoint)));\n      if (parralelVec.length == 0) return;\n\n      let parralelVel = Vec2.dot(velInCollisionPoint, parralelVec);\n      let deltaMomentum = Vec2.mult(deltaVel, massInPoint);\n      let deltaVelParralel = Vec2.div(deltaMomentum, massParralel);\n      if (massParralel == 0) deltaVelParralel = 0;\n\n      deltaVelParralel.mult(this.fc);\n      deltaVelParralel = Vec2.mult(parralelVec, deltaVelParralel.length);\n      if (deltaVelParralel.length > parralelVel) {\n        deltaVelParralel.setMag(parralelVel);\n      }\n\n      angle = Vec2.angleACW(parralelVec, r);\n\n      deltaVel = deltaVelParralel;\n      deltaAng = deltaVel.copy;\n\n      deltaVel.mult(Math.cos(angle));\n      this.vel.add(deltaVel);\n\n      deltaAng = deltaAng.length / r.length;\n      deltaAng *= Math.sin(angle);\n      this.ang -= deltaAng;\n\n      endVels.push(this.vel);\n      this.vel = startingVel.copy;\n\n      endAngs.push(this.ang);\n      this.ang = startingAng;\n    }\n\n    if (endAngs.length != endVels.length) return;\n    if (endAngs.length == 0) return;\n    if (endVels.length == 0) return;\n\n    this.vel = endVels.reduce((prev, curr) => {\n      return Vec2.add(prev, curr);\n    });\n    this.vel.div(endVels.length);\n    this.ang = endAngs.reduce((prev, curr) => {\n      return prev + curr;\n    });\n    this.ang /= endAngs.length;\n\n    if (!isFinite(this.vel.x) || !isFinite(this.vel.y) || !isFinite(this.ang)) {\n      this.vel = startingVel;\n      this.ang = startingAng;\n    }\n\n    return debugData;\n  }\n\n  /**\n   *Returns true if the point is inside the body\n   * @param {Vec2} p The point\n   * @return {boolean} The boolean value\n   */\n  containsPoint(p) {\n    let sides = this.sides;\n    let r =\n      Math.max(\n        ...this.points.map((point) => {\n          return Vec2.dist(point, p);\n        })\n      ) + 1;\n\n    let v = Vec2.fromAngle(0);\n    v.setMag(r);\n\n    let testerSegment = new LineSegment(p, Vec2.add(v, p));\n\n    let filtered = sides.filter((side) => {\n      return LineSegment.intersect(side, testerSegment) != undefined;\n    });\n    return filtered.length % 2 == 1;\n  }\n\n  /**\n   * Returns an array containing all the sides of the body\n   */\n  get sides() {\n    return this.points.map((element, index) => {\n      return new LineSegment(\n        element,\n        this.points[(index + 1) % this.points.length]\n      );\n    });\n  }\n\n  /**\n   * Calculates the effective velocity of the body object in a\n   * given point from it's velocity and angular velocity\n   * @param {Vec2} point The point to be taken a look at\n   * @return {Vec2} The velocity of the Body in the given point\n   */\n  velInPlace(point) {\n    let vp = Vec2.sub(point, this.pos);\n    vp.rotate(Math.PI / 2);\n    vp.mult(this.ang);\n    vp.add(this.vel);\n    return vp;\n  }\n\n  /**\n   * Calculates the effective mass of the body in\n   * a given point when pulled/pushed in a given direction\n   * by a hypothetical force\n   * @param {Vec2} point The given point\n   * @param {Vec2} direction The direction of the force\n   * @return {Number}\n   */\n  effectiveMass(point, direction) {\n    let r = Vec2.sub(point, this.pos);// Vector to the collision point\n    let angle = Vec2.angle(direction, r);\n    let rotationalMass = (Math.sin(angle) ** 2) * (r.length ** 2) / this.am;\n    return 1 / (rotationalMass + (1 / this.m));\n  }\n\n  /**\n   * @return {Object} The Body represented in a JS object\n   * Ready to be converted into JSON\n   */\n  toJSObject() {\n    let ret = {};\n\n    ret.points = this.points.map((p) => {\n      return {\n        x: p.x,\n        y: p.y,\n      };\n    });\n    ret.vel = this.vel.toJSObject();\n    ret.k = this.k;\n    ret.ang = this.ang;\n    ret.fc = this.fc;\n    ret.pos = this.pos.toJSObject();\n    ret.lastPos = this.lastPos.toJSObject();\n    ret.rotation = this.rotation;\n    ret.id = this.id;\n\n    return ret;\n  }\n\n  /**\n   * Creates a Body class from the given object\n   * @param {Object} obj The object to create the class from\n   * @return {Body} The Body object\n   */\n  static fromObject(obj) {\n    let ret = new Body(\n      obj.points.map((p) => {\n        return {\n          x: p.x,\n          y: p.y,\n        };\n      }),\n      Vec2.fromObject(obj.vel),\n      obj.k,\n      obj.ang,\n      obj.fc\n    );\n\n    ret.id = obj.id;\n    ret.pos = Vec2.fromObject(obj.pos);\n    ret.lastPos = Vec2.fromObject(obj.lastPos);\n    ret.rotation = obj.rotation;\n\n    return ret;\n  }\n}\n\nmodule.exports = Body;\n", "const Vec2 = require('./vec2');\nconst LineSegment = require('./linesegment');\n\n/**\n * Class representing a staight line with infinite length\n * Still constructed from two points, but these points do not act as boundaries\n */\nclass Line extends LineSegment {\n    /**\n     * Create an infinite length staight line going through the\n     * given points points on the 2D plane\n     * @param {Vec2} a_ First point\n     * @param {Vec2} b_ Second point\n     */\n    constructor(a_, b_) {\n        super(a_, b_);\n    }\n\n    /**\n     * Returns the length of the line which is always infinite\n     * @return {number} The length, infinite\n     */\n    get length() {\n        return Number.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Get the distance between a point and the line\n     * @param {Vec2} p The point as a vector\n     * @return {number} The distance\n     */\n    distFromPoint(p) {\n        // Create a vector perpendicular to the line with length 1\n        let perpendicular = Vec2.sub(this.a, this.b);\n        perpendicular.setMag(1);\n        perpendicular.rotate(Math.PI / 2);\n\n        let distVec = Vec2.sub(p, this.a);\n        let distance = Math.abs(Vec2.dot(distVec, perpendicular));\n        return distance;\n    }\n\n    /**\n     * Get if they intersect or not\n     * If they intersect it returns the intersection point\n     * If they not it returns undefined\n     * @param {Line} line1 A line\n     * @param {Line} line2 Other line\n     * @return {Vec2} Intersetion point\n     */\n    static intersect(line1, line2) {\n        let v1 = Vec2.sub(line1.b, line1.a);\n        let e1 = v1.y / v1.x;\n        let f1 = line1.b.y - line1.b.x * e1;\n\n        let v2 = Vec2.sub(line2.b, line2.a);\n        let e2 = v2.y / v2.x;\n        let f2 = line2.b.y - line2.b.x * e2;\n\n        if (e1 === e2) {\n            if (line1.distFromPoint(line2.a) == 0) {\n                return new Vec2(\n                    (line1.a.x + line1.b.x + line2.a.x + line2.b.x) / 4,\n                    (line1.a.y + line1.b.y + line2.a.y + line2.b.y) / 4);\n            } else return undefined;\n        } else {\n            let foundX = (f2 - f1) / (e1 - e2);\n            return new Vec2(foundX, (e1 * foundX) + f1);\n        }\n    }\n\n    /**\n     * Returns the intersection point of a line and a line segment\n     * If there is none, it returns undefined\n     * @param {Line} line The line\n     * @param {LineSegment} segment The line segment\n     * @return {Vec2} Intersection point\n     */\n    static intersectWithLineSegment(line, segment) {\n        let v1 = Vec2.sub(line.b, line.a);\n        let e1 = v1.y / v1.x;\n        let f1 = line.b.y - line.b.x * e1;\n\n        let v2 = Vec2.sub(segment.b, segment.a);\n        let e2 = v2.y / v2.x;\n        let f2 = segment.b.y - segment.b.x * e2;\n\n        if (v1.x === 0) {\n            if (v2.x === 0) {\n                if (line.a.x == segment.a.x) {\n                    return new Vec2(\n                        (segment.a.x + segment.b.x) / 2,\n                        (segment.a.y + segment.b.y) / 2);\n                } else return undefined;\n            }\n\n            let foundX = line.a.x;\n            let foundY = (e2 * foundX) + f2;\n            if (Math.min(segment.a.x, segment.b.x) < foundX &&\n                foundX < Math.max(segment.a.x, segment.b.x) &&\n                Math.min(segment.a.y, segment.b.y) < foundY &&\n                Math.max(segment.a.y, segment.b.y) > foundY) {\n                return new Vec2(foundX, foundY);\n            } else return undefined;\n        }\n        if (v2.x === 0) {\n            let foundX = segment.a.x;\n            let foundY = (e1 * foundX) + f1;\n            if (Math.min(segment.a.x, segment.b.x) < foundX &&\n                foundX < Math.max(segment.a.x, segment.b.x) &&\n                Math.min(segment.a.y, segment.b.y) < foundY &&\n                Math.max(segment.a.y, segment.b.y) > foundY) {\n                return new Vec2(foundX, foundY);\n            } else return undefined;\n        }\n\n        if (e1 === e2) {\n            if (line.distFromPoint(segment.a) === 0) {\n                return new Vec2(\n                    (segment.a.x + segment.b.x) / 2,\n                    (segment.a.y + segment.b.y) / 2);\n            } else return undefined;\n        } else {\n            let foundX = (f2 - f1) / (e1 - e2);\n            let foundY = (e1 * foundX) + f1;\n            if (Math.min(segment.a.x, segment.b.x) < foundX &&\n                foundX < Math.max(segment.a.x, segment.b.x) &&\n                Math.min(segment.a.y, segment.b.y) < foundY &&\n                Math.max(segment.a.y, segment.b.y) > foundY) {\n                return new Vec2(foundX, foundY);\n            } else return undefined;\n        }\n    }\n}\n\nmodule.exports = Line;\n", "const Vec2 = require('./vec2');\nconst LineSegment = require('./linesegment');\nconst Line = require('./line');\n\n/**\n * Class representing a mathematical polygon\n */\nclass Polygon {\n    /**\n     * Creates the polygon\n     * @param {Vec2[]} points_ Array of the points for the polygon in order\n     */\n    constructor(points_) {\n        if (points_.length < 3) {\n            throw new Error(\n                'Not enough points in polygon (minimum required: 3)'\n            );\n        }\n        this.points = points_;\n        this.makeAntiClockwise();\n    }\n\n    /**\n     * Returns the vector of the side with the given number\n     * The vector has the orientation of the order of the points\n     * @param {number} num The number of the side\n     * @return {Vec2} The side vector\n     */\n    getSideVector(num) {\n        if (num < 0) num += Math.abs(Math.floor(num)) * this.points.length;\n        return Vec2.sub(this.points[(num + 1) % this.points.length],\n            this.points[num % this.points.length]);\n    }\n\n    /**\n     * Returns the side with the given number as a LineSegment\n     * @param {number} num The number of the side\n     * @return {LineSegment} The side line segment\n     */\n    getSideSegment(num) {\n        if (num < 0) num += Math.abs(Math.floor(num)) * this.points.length;\n        return new LineSegment(this.points[(num + 1) % this.points.length],\n            this.points[num % this.points.length]);\n    }\n\n    /**\n     * Returns the side with the given number as a Line\n     * @param {number} num The number of the side\n     * @return {Line} The side line\n     */\n    getSideLine(num) {\n        if (num < 0) num += Math.abs(Math.floor(num)) * this.points.length;\n        return new Line(this.points[(num + 1) % this.points.length],\n            this.points[num % this.points.length]);\n    }\n\n    /**\n     * @return {number} The number of sides of the polygon\n     */\n    get sides() {\n        return this.points.length;\n    }\n\n    /**\n     * Turns the order of the points to anticlockwise,\n     * which is the standard in mathematics\n     */\n    makeAntiClockwise() {\n        let angleSum = 0;\n\n        for (let i = 1; i <= this.sides; i++) {\n            let vec1 = this.getSideVector(i);\n            let vec2 = this.getSideVector(i - 1);\n            vec2.mult(-1);\n            angleSum += Vec2.angleACW(vec1, vec2);\n        }\n\n        if (this.sides === 3) {\n            if (angleSum > Math.PI * 1.5) this.reverseOrder();\n        } else if (this.sides === 4) {\n            if (Vec2.angleACW(this.getSideVector(1),\n                this.getSideVector(0)) >= Math.PI) {\n                this.reverseOrder();\n            }\n        } else if (this.sides > 4) {\n            let realAngle = angleSum - this.sides * Math.PI;\n            if (realAngle > 0) {\n                this.reverseOrder();\n            }\n        }\n    }\n\n    /**\n     * Reverses the order of points in the polygon\n     */\n    reverseOrder() {\n        this.points = this.points.reverse();\n    }\n\n    /**\n     * Determines if a given point is inside the polygon or not\n     * @param {Vec2} point The point to investigate\n     * @return {boolean} If the point is inside or not\n     */\n    isPointInside(point) {\n        if (Vec2.dist(point, this.centerPoint) > this.boundRadius) return false;\n\n        // Find a point that is outside of the shape for sure\n        let outsidePoint = this.centerPoint.copy;\n        outsidePoint.add(Vec2.mult(new Vec2(1.1, 0.6), this.boundRadius));\n\n        // Create a LineSegment between the points\n        let segment = new LineSegment(point, outsidePoint);\n\n        // Count the intersections\n        let intersectionCount = 0;\n        [...Array(this.sides).keys()].\n            map((number) => this.getSideSegment(number)).forEach((side) => {\n                if (LineSegment.intersect(side, segment)) intersectionCount++;\n            });\n\n        if (intersectionCount % 2 == 0) return false;\n        else if (intersectionCount % 2 == 1) return true;\n    }\n\n    /**\n     * Returns the mathematical average of the point of the polygon\n     * @return {Vec2} The center point\n     */\n    get centerPoint() {\n        let center = new Vec2(0, 0);\n        this.points.forEach((p) => {\n            center.add(p);\n        });\n        center.div(this.sides);\n        return center;\n    }\n\n    /**\n     * Returns the radius of the smallest possible\n     * circle containing the whole polygon centered\n     * around the polygon's centerPoint\n     * The circle's center is the centerPoint of the polygon\n     * @return {number} The radius\n     */\n    get boundRadius() {\n        let center = this.centerPoint;\n        return Math.max(...this.points.map((p) => Vec2.dist(p, center)));\n    }\n\n    /**\n     * @return {LineSegment[]} Array containing the sides of the polygon\n     */\n    get allSides() {\n        return [...Array(this.sides).keys()].\n            map((number) => this.getSideSegment(number));\n    }\n\n    /**\n     * Determines the intersecting area of two polygons\n     * Returns undefined if there is none\n     * @param {Polygon} poly1 The first polygon\n     * @param {Polygon} poly2 The second polygon\n     * @return {Polygon} The intersection area\n     */\n    static intersection(poly1, poly2) {\n        if (Vec2.dist(poly1.centerPoint, poly2.centerPoint) >\n            poly1.boundRadius + poly2.boundRadius) return undefined;\n\n        // Determine intersection points\n        let sideIntersections = [];\n        let sides1 = poly1.allSides;\n        let sides2 = poly2.allSides;\n        sides1.forEach((side1, idx1) => {\n            sides2.forEach((side2, idx2) => {\n                let intersectionOfSides = LineSegment.intersect(side1, side2);\n                if (intersectionOfSides) {\n                    intersectionOfSides['isIntersectionPoint'] = true;\n                    sideIntersections.push({\n                        intersectionPoint: intersectionOfSides,\n                        sideNumber1: idx1,\n                        sideNumber2: idx2,\n                    });\n                };\n            });\n        });\n\n        if (sideIntersections.length === 0) {\n            if (poly1.isPointInside(poly2.points[0])) {\n                return new Polygon(poly2.points.map((p) => p.copy));\n            }\n            if (poly2.isPointInside(poly1.points[0])) {\n                return new Polygon(poly1.points.map((p) => p.copy));\n            }\n        }\n\n        // Put the intersection points into the copy of polygons\n        let new1 = new Polygon(poly1.points.map((p) => p.copy));\n        for (let i = new1.points.length - 1; i >= 0; i--) {\n            let intersectionsOnThis =\n                sideIntersections.filter((it) => it.sideNumber1 == i);\n            if (intersectionsOnThis.length > 1) {\n                intersectionsOnThis.sort((a, b) => {\n                    return Vec2.dist(new1.points[i], a.intersectionPoint)\n                        - Vec2.dist(new1.points[i], b.intersectionPoint);\n                });\n            }\n            if (intersectionsOnThis.length > 0) {\n                new1.points.splice(i + 1, 0,\n                    ...intersectionsOnThis.map((it) => it.intersectionPoint));\n            }\n        }\n        let new2 = new Polygon(poly2.points.map((p) => p.copy));\n        for (let i = new2.points.length - 1; i >= 0; i--) {\n            let intersectionsOnThis =\n                sideIntersections.filter((it) => it.sideNumber2 == i);\n            if (intersectionsOnThis.length > 1) {\n                intersectionsOnThis.sort((a, b) => {\n                    return Vec2.dist(new2.points[i], a.intersectionPoint)\n                        - Vec2.dist(new2.points[i], b.intersectionPoint);\n                });\n            }\n            if (intersectionsOnThis.length > 0) {\n                new2.points.splice(i + 1, 0,\n                    ...intersectionsOnThis.map((it) => it.intersectionPoint));\n            }\n        }\n\n        // Find a starting point outside of the other poly\n        let currInv = {\n            polyNum: 1,\n            pointNum: 0,\n        };\n        for (let i = 0; i < new1.points.length; i++) {\n            if (new1.points[i].isIntersectionPoint) {\n                currInv.pointNum = i;\n                break;\n            } else if (new2.isPointInside(new1.points[i])) {\n                currInv.pointNum = i;\n                break;\n            }\n        }\n        let isDone = false;\n        let finalPoints = [];\n        while (!isDone) {\n            let currentPoly = (currInv.polyNum === 1) ? new1 : new2;\n            let otherPoly = (currInv.polyNum === 1) ? new2 : new1;\n            finalPoints.push(\n                currentPoly.points[\n                    currInv.pointNum % currentPoly.points.length].copy\n            );\n            if (finalPoints.length > 2 &&\n                finalPoints[0].x == finalPoints[finalPoints.length - 1].x &&\n                finalPoints[0].y == finalPoints[finalPoints.length - 1].y) {\n                finalPoints.pop();\n                break;\n            }\n            if (finalPoints.length > new1.points.length + new2.points.length) {\n                break;\n            }\n\n            if (currentPoly.points[currInv.pointNum %\n                currentPoly.points.length].isIntersectionPoint) {\n                if (currentPoly.points[(currInv.pointNum + 1) %\n                    currentPoly.points.length].isIntersectionPoint) {\n                    currInv.pointNum++;\n                } else if (otherPoly.isPointInside(\n                    currentPoly.points[(currInv.pointNum + 1) %\n                    currentPoly.points.length]) &&\n                    !currentPoly.points[(currInv.pointNum + 1) %\n                        currentPoly.points.length].isIntersectionPoint) {\n                    currInv.pointNum++;\n                } else {\n                    currInv.pointNum = otherPoly.points.indexOf(\n                        currentPoly.points[currInv.pointNum %\n                        currentPoly.points.length]) + 1;\n                    currInv.polyNum = (currInv.polyNum === 1) ? 2 : 1;\n                }\n            } else {\n                currInv.pointNum++;\n            }\n        }\n\n        return new Polygon(finalPoints);\n    }\n\n    /**\n     * Creates a regular polygon (circle) with\n     * the given center point and radius\n     * @param {number} radius The radius of the circle\n     * @param {Vec2} center The center of the circle\n     * @param {number} resolution The resolution of the circle\n     * @return {Polygon} The created Polygon\n     */\n    static createCircle(radius, center, resolution = 25) {\n        let pts = [...Array(resolution).keys()].map((number) => {\n            let p = Vec2.fromAngle(2 * Math.PI * number / resolution);\n            p.setMag(radius);\n            p.add(center);\n            return p;\n        });\n        return new Polygon(pts);\n    }\n\n    /**\n     * Creates a fracture diagram based on the given points\n     * Looks like a Voronoi diagram\n     * @param {Vec2[]} middlePoints Points of fractures\n     * @param {number} maxLength Max length of sides on the peripherals\n     * @return {Polygon[]} The fractured shapes\n     */\n    static fracture(middlePoints, maxLength = 500) {\n        let shapes = middlePoints.map((p, i) => {\n            let lines = [];\n            for (let j = 0; j < middlePoints.length; j++) {\n                if (i === j) continue;\n                let otherPoint = middlePoints[j];\n                let avg = Vec2.div(Vec2.add(p, otherPoint), 2);\n                let e = Vec2.sub(p, otherPoint);\n                e.rotate(Math.PI / 2);\n\n                lines.push(new Line(avg, Vec2.add(e, avg)));\n            }\n\n            lines = lines.filter((line, idx) => {\n                let connectingSegment = new LineSegment(line.a, p);\n                for (let j = 0; j < lines.length; j++) {\n                    if (idx === j) continue;\n                    let sectP = Line.intersectWithLineSegment(lines[j], connectingSegment);\n                    if (sectP) return false;\n                }\n                return true;\n            });\n\n            lines = lines.sort((a, b) => {\n                return Vec2.sub(a.a, a.b).heading - Vec2.sub(b.a, b.b).heading;\n            });\n\n            let shape = lines.map((line, index) => {\n                let intersectPoints = [];\n                for (let j = 0; j < lines.length; j++) {\n                    if (index === j) continue;\n                    let newIntersection = Line.intersect(line, lines[j]);\n                    if (newIntersection) intersectPoints.push(newIntersection);\n                }\n                let e = Vec2.sub(line.a, line.b);\n                intersectPoints = intersectPoints.filter((ip) => {\n                    let v = Vec2.sub(ip, p);\n                    e.setMag(1);\n                    let dist = Vec2.dot(v, e);\n                    return dist > 0;\n                });\n                if (intersectPoints.length === 0) {\n                    intersectPoints.push(Vec2.add(Vec2.mult(e, maxLength * 1.2), line.a));\n                }\n                intersectPoints = intersectPoints.sort((a, b) => {\n                    return Vec2.dist(a, p) - Vec2.dist(b, p);\n                });\n                return intersectPoints[0];\n            });\n\n            return shape;\n        });\n\n        return shapes.filter((shape) => shape.length >= 3).map((shape) => new Polygon(shape));\n    }\n}\n\nmodule.exports = Polygon;\n", "const Vec2 = require('./vec2');\nconst Ball = require('./ball');\nconst Wall = require('./wall');\nconst LineSegment = require('./linesegment');\nconst Stick = require('./stick');\nconst Spring = require('./spring');\nconst SoftBall = require('./softball');\nconst Body = require('./body');\nconst Line = require('./line');\nconst Polygon = require('./polygon');\n\n/**\n * Class that creates a new world ba the physics engine\n */\nclass Physics {\n  /**\n   * Create and initalize a new world\n   */\n  constructor() {\n    this.balls = [];\n    this.bodies = [];\n    this.fixedBalls = [];\n    this.softBalls = [];\n\n    this.walls = [];\n\n    this.bounds = [];\n\n    this.springs = [];\n\n    // Air friction has to be between 0 and 1\n    // 0 - no movement\n    // 1 - no friction\n    this.airFriction = 1;\n\n    this.gravity = new Vec2(0, 0);\n\n    this.debugData = [];\n  }\n\n  /**\n   * Updates the world by a given amount of time\n   * @param {number} t Elapsed time\n   * @param {boolean} precise If this is true,\n   * then the simulation is going to be more precise\n   */\n  update(t, precise) {\n    // Resets debug data\n    this.debugData = [];\n\n    // Do the simulation on the reversed system\n    // if the simulation is in precise mode\n    let clonedSystem = precise ? this.copy : new Physics();\n    if (precise) {\n      clonedSystem.bodies.reverse();\n      clonedSystem.balls.reverse();\n      clonedSystem.update(t, false);\n    }\n\n    // At first move objets\n    for (let i = 0; i < this.balls.length; i++) {\n      // Move\n      this.balls[i].lastPos = this.balls[i].pos.copy;\n      this.balls[i].pos.add(Vec2.mult(this.balls[i].vel, t));\n\n      // Angular velocity\n      this.balls[i].rotation += this.balls[i].ang * t;\n      this.balls[i].rotation %= Math.PI * 2;\n    }\n    for (let i = 0; i < this.bodies.length; i++) {\n      this.bodies[i].lastPos = this.bodies[i].pos.copy;\n      this.bodies[i].move(this.bodies[i].vel.x * t, this.bodies[i].vel.y * t);\n      this.bodies[i].rotate(this.bodies[i].ang * t);\n    }\n\n    // Update springs multiple times\n    for (let i = 0; i < 3; i++) {\n      for (let element of this.springs) {\n        element.update(t / 3 / 2);\n      }\n    }\n\n    for (let i = 0; i < this.balls.length; i++) {\n      // Apply gravity\n      if (this.gravity) {\n        this.balls[i].vel.add(new Vec2(this.gravity.x * t, this.gravity.y * t));\n      }\n\n      // Collision\n      for (let j = i + 1; j < this.balls.length; j++) {\n        if (\n          this.balls[i].layer != this.balls[j].layer ||\n          (!this.balls[i].layer && !this.balls[j].layer)\n        ) {\n          Ball.collide(this.balls[i], this.balls[j]);\n        }\n      }\n\n      // Collision with walls\n      for (let wall of this.walls) {\n        wall.collideWithBall(this.balls[i]);\n      }\n\n      // Collision with fixed balls\n      for (let b of this.fixedBalls) {\n        let ball = this.balls[i];\n\n        let heading;\n        let rel = 0;\n        let p = new Vec2(b.x, b.y);\n        p.x -= ball.pos.x;\n        p.y -= ball.pos.y;\n        p.mult(-1);\n        if (p.length <= ball.r + b.r) {\n          heading = p.heading;\n          rel = p.length;\n        }\n\n        fixedBallCollision: if (heading === 0 || heading) {\n          let pos = new Vec2(ball.pos.x, ball.pos.y);\n          let vel = new Vec2(ball.vel.x, ball.vel.y);\n          pos.rotate(-heading + Math.PI / 2);\n          vel.rotate(-heading + Math.PI / 2);\n\n          if (vel.y > 0) break fixedBallCollision;\n          vel.y *= -ball.k;\n          pos.y += ball.r + b.r - rel;\n          let dvy = vel.y * (1 + 1 / ball.k);\n\n          let deltaAng =\n            (Math.sign(vel.x - ball.ang * ball.r) * (dvy * ball.fc)) /\n            (ball.amc * ball.r);\n          let maxDeltaAng = (vel.x - ball.ang * ball.r) / ball.r;\n\n          if (deltaAng / maxDeltaAng > 1) deltaAng = maxDeltaAng;\n          deltaAng *= ball.amc / (ball.amc + 1);\n          ball.ang += deltaAng;\n\n          let dvx = deltaAng * ball.r;\n\n          vel.x -= dvx;\n\n          pos.rotate(heading - Math.PI / 2);\n          vel.rotate(heading - Math.PI / 2);\n          ball.pos.x = pos.x;\n          ball.pos.y = pos.y;\n          ball.vel.x = vel.x;\n          ball.vel.y = vel.y;\n        }\n      }\n\n      // Bounce off the edges\n      for (let bound of this.bounds) {\n        bound.collideWithBall(this.balls[i]);\n      }\n    }\n\n    for (let i = 0; i < this.bodies.length; i++) {\n      for (let ball of this.balls) {\n        if (\n          ball.layer != this.bodies[i].layer ||\n          (!ball.layer && !this.bodies[i].layer)\n        ) {\n          this.bodies[i].collideWithBall(ball);\n        }\n      }\n\n      for (let j = i + 1; j < this.bodies.length; j++) {\n        if (\n          this.bodies[i].layer != this.bodies[j].layer ||\n          (!this.bodies[j].layer && !this.bodies[i].layer)\n        ) {\n          Body.collide(this.bodies[i], this.bodies[j]);\n        }\n      }\n\n      // Body vs fixedBall collisions\n      for (let body of this.bodies) {\n        for (let fixedBall of this.fixedBalls) {\n          body.collideWithFixedBall(fixedBall);\n        }\n      }\n\n      // Body vs wall collisions\n      for (let body of this.bodies) {\n        for (let wall of this.walls) {\n          let additionalDebugData = body.collideWithWall(wall);\n          if (additionalDebugData) {\n            this.debugData.push(...additionalDebugData);\n          }\n        }\n      }\n\n      // Body vs world boundary collision\n      for (let body of this.bodies) {\n        for (let bound of this.bounds) {\n          let additionalDebugData = body.collideWithWall(bound);\n          if (additionalDebugData) {\n            this.debugData.push(...additionalDebugData);\n          }\n        }\n      }\n\n      // Apply gravity\n      if (this.gravity) {\n        this.bodies[i].vel.add(\n          new Vec2(this.gravity.x * t, this.gravity.y * t)\n        );\n      }\n    }\n\n    // Update soft balls\n    this.softBalls.forEach((sb) => {\n      SoftBall.updatePressureBasedForces(sb, t);\n    });\n\n    // Update springs again multiple times\n    for (let i = 0; i < 3; i++) {\n      for (let element of this.springs) {\n        element.update(t / 3 / 2);\n      }\n    }\n\n    // Apply air friction\n    this.balls.forEach((b) => {\n      b.vel.mult(Math.pow(this.airFriction, t));\n      b.ang *= Math.pow(this.airFriction, t);\n    });\n    this.bodies.forEach((b) => {\n      b.vel.mult(Math.pow(this.airFriction, t));\n      b.ang *= Math.pow(this.airFriction, t);\n    });\n\n    // Then take the average of this system and the other system\n    // if in precise mode\n    if (precise) {\n      clonedSystem.bodies.reverse();\n      clonedSystem.balls.reverse();\n\n      // Take the average of the balls\n      this.balls.forEach((ball, i) => {\n        ball.move(\n          (clonedSystem.balls[i].pos.x - ball.pos.x) * 0.5,\n          (clonedSystem.balls[i].pos.y - ball.pos.y) * 0.5\n        );\n        ball.vel.add(\n          new Vec2(\n            (clonedSystem.balls[i].vel.x - ball.vel.x) * 0.5,\n            (clonedSystem.balls[i].vel.y - ball.vel.y) * 0.5\n          )\n        );\n        ball.rotation = (ball.rotation + clonedSystem.balls[i].rotation) / 2;\n        ball.ang = (ball.ang + clonedSystem.balls[i].ang) / 2;\n      });\n\n      // Take the average of the bodies\n      this.bodies.forEach((body, i) => {\n        let other = clonedSystem.bodies[i];\n        body.move(\n          (other.pos.x - body.pos.x) * 0.5,\n          (other.pos.y - body.pos.y) * 0.5\n        );\n        body.vel.add(\n          new Vec2(\n            (other.vel.x - body.vel.x) * 0.5,\n            (other.vel.y - body.vel.y) * 0.5\n          )\n        );\n        body.rotate((other.rotation - body.rotation) / 2);\n        body.ang = (body.ang + other.ang) / 2;\n      });\n    }\n  }\n\n  /**\n   * Returns a copy of this system\n   * @return {Physics} The copy of this system\n   */\n  get copy() {\n    let ret = new Physics();\n    ret.balls = this.getCopyOfBalls();\n    ret.bodies = this.getCopyOfBodies();\n    ret.fixedBalls = this.fixedBalls;\n    ret.walls = this.walls;\n    ret.bounds = this.bounds;\n    ret.gravity = this.gravity;\n\n    this.springs.forEach((spring) => {\n      let TypeOfSpring = spring.constructor == Spring ? Spring : Stick;\n      let copiedSpring = new TypeOfSpring(spring.length, spring.springConstant);\n      copiedSpring.rotationLocked = spring.rotationLocked;\n      copiedSpring.pinned = spring.pinned;\n\n      spring.objects.forEach((obj) => {\n        let idx = this.balls.indexOf(obj);\n        if (idx != -1) copiedSpring.attachObject(ret.balls[idx]);\n        else {\n          idx = this.bodies.indexOf(obj);\n          if (idx != -1) copiedSpring.attachObject(ret.bodies[idx]);\n        }\n      });\n\n      ret.springs.push(copiedSpring);\n    });\n\n    return ret;\n  }\n\n  /**\n   * Air friction. has to be between 0 and 1\n   * 0 - no movement\n   * 1 - no friction\n   * @param {number} airFriction Has to be between 0 and 1\n   */\n  setAirFriction(airFriction) {\n    if (!isFinite(airFriction)) return;\n    this.airFriction = airFriction;\n    if (this.airFriction < 0) this.airFriction = 0;\n    if (this.airFriction > 1) this.airFriction = 1;\n  }\n\n  /**\n   * Sets the gravity in the world\n   * @param {Vec2} dir The acceleration vector of the gravity\n   */\n  setGravity(dir) {\n    this.gravity = dir.copy;\n  }\n\n  /**\n   * Appends a new ball to the world\n   * @param {Ball} ball Ball to add to the world\n   */\n  addBall(ball) {\n    if (\n      typeof addBodyNotBall != 'undefined' &&\n      isFinite(addBodyNotBall) &&\n      addBodyNotBall > 2\n    ) {\n      const getPointsForBall = (pos, r, resolution) => {\n        let points = [];\n\n        for (let i = 0; i < resolution; i++) {\n          let newPoint = Vec2.fromAngle((i / resolution) * 2 * Math.PI);\n          newPoint.mult(r);\n          newPoint.add(pos);\n          points.push(newPoint);\n        }\n\n        return points;\n      };\n\n      this.bodies.push(\n        new Body(\n          getPointsForBall(ball.pos, ball.r, addBodyNotBall),\n          ball.vel,\n          ball.k,\n          ball.ang,\n          ball.fc\n        )\n      );\n    } else {\n      this.balls.push(ball);\n    }\n  }\n\n  /**\n   * Appends a new body to the world\n   * @param {Body} body Body to add to the world\n   */\n  addBody(body) {\n    this.bodies.push(body);\n  }\n\n  /**\n   * Appends a new soft ball to the world\n   * @param {SoftBall} softBall SoftBall to be added to the world\n   */\n  addSoftBall(softBall) {\n    this.balls.push(...softBall.points);\n    this.springs.push(...softBall.sides);\n\n    this.softBalls.push(softBall);\n  }\n\n  /**\n   * Appends a new soft square to the world\n   * @param {Vec2} pos The position of the soft square\n   * @param {number} sideSize The size of the square\n   * @param {number} fc Friction coefficient\n   * @param {Vec2} vel The initial velocity of the soft square\n   */\n  addSoftSquare(pos, sideSize, fc, vel) {\n    let softSquare = new SoftBall(\n      pos,\n      Math.sqrt((sideSize * sideSize) / Math.PI),\n      1,\n      fc,\n      24\n    );\n    softSquare.sides.forEach((side) => {\n      side.length = (0.96 * 4 * sideSize) / softSquare.resolution;\n    });\n    softSquare.points.forEach((b) => {\n      b.vel = vel.copy;\n    });\n\n    this.balls.push(...softSquare.points);\n    this.springs.push(...softSquare.sides);\n\n    let springStrength = sideSize * sideSize * 200;\n\n    let bigStick = new Spring(\n      Math.sqrt(softSquare.r * softSquare.r * Math.PI),\n      springStrength / 2\n    );\n    bigStick.attachObject(softSquare.points[0]);\n    bigStick.attachObject(softSquare.points[softSquare.resolution / 2]);\n    this.springs.push(bigStick);\n\n    bigStick = new Spring(\n      Math.sqrt(softSquare.r * softSquare.r * Math.PI),\n      springStrength / 2\n    );\n    bigStick.attachObject(softSquare.points[softSquare.resolution / 4]);\n    bigStick.attachObject(softSquare.points[(3 * softSquare.resolution) / 4]);\n    this.springs.push(bigStick);\n\n    bigStick = new Spring(\n      Math.sqrt(2 * softSquare.r * softSquare.r * Math.PI),\n      springStrength\n    );\n    bigStick.attachObject(softSquare.points[softSquare.resolution / 8]);\n    bigStick.attachObject(softSquare.points[(5 * softSquare.resolution) / 8]);\n    this.springs.push(bigStick);\n\n    bigStick = new Spring(\n      Math.sqrt(2 * softSquare.r * softSquare.r * Math.PI),\n      springStrength\n    );\n    bigStick.attachObject(softSquare.points[(3 * softSquare.resolution) / 8]);\n    bigStick.attachObject(softSquare.points[(7 * softSquare.resolution) / 8]);\n    this.springs.push(bigStick);\n  }\n\n  /**\n   * Appends a rectangular wall to the world\n   * @param {number} x x coordinate of the rectangular wall\n   * @param {number} y y coordinate of the rectangular wall\n   * @param {number} w width of the rectangular wall\n   * @param {number} h height of the rectangular wall\n   */\n  addRectWall(x, y, w, h) {\n    let points = [];\n    points.push(new Vec2(x - w / 2, y - h / 2));\n    points.push(new Vec2(x + w / 2, y - h / 2));\n    points.push(new Vec2(x + w / 2, y + h / 2));\n    points.push(new Vec2(x - w / 2, y + h / 2));\n    this.walls.push(new Wall(points));\n  }\n\n  /**\n   * Appends a rectangular body to the world\n   * @param {number} x x coordinate of the rectangular body\n   * @param {number} y y coordinate of the rectangular body\n   * @param {number} w width of the rectangular body\n   * @param {number} h height of the rectangular body\n   * @param {number} fc friction coefficient of the body\n   * @param {number} k coefficient of restitution of the body\n   */\n  addRectBody(x, y, w, h, fc, k) {\n    let points = [];\n    points.push(new Vec2(x - w / 2, y - h / 2));\n    points.push(new Vec2(x + w / 2, y - h / 2));\n    points.push(new Vec2(x + w / 2, y + h / 2));\n    points.push(new Vec2(x - w / 2, y + h / 2));\n    this.bodies.push(new Body(points, new Vec2(0, 0), k, 0, fc));\n  }\n\n  /**\n   * Append a new wall to the world\n   * @param {Wall} wall Wall to append to the world\n   */\n  addWall(wall) {\n    this.walls.push(wall);\n  }\n\n  /**\n   * Appends a fixed ball to the world\n   * A fixed ball is immovable and other objects collide with it\n   * @param {number} x x coordinate of the fixed ball\n   * @param {number} y y coordinate of the fixed ball\n   * @param {number} r radius of the fixed ball\n   */\n  addFixedBall(x, y, r) {\n    this.fixedBalls.push({\n      x: x,\n      y: y,\n      r: r,\n    });\n  }\n\n  /**\n   * Appends a new spring to the world\n   * @param {Spring} spring Spring to add to the world\n   */\n  addSpring(spring) {\n    this.springs.push(spring);\n  }\n\n  /**\n   * Sets the size of the world (without this the world\n   * does not have bounds)\n   * @param {number} x x coordinate of the centre of the world\n   * @param {number} y y coordinate of the centre of the world\n   * @param {number} w Width of the world\n   * @param {number} h Height of the world\n   */\n  setBounds(x, y, w, h) {\n    this.bounds = [];\n\n    const getRectBody = (x_, y_, w_, h_) => {\n      let points = [];\n      points.push(new Vec2(x_ - w_ / 2, y_ - h_ / 2));\n      points.push(new Vec2(x_ + w_ / 2, y_ - h_ / 2));\n      points.push(new Vec2(x_ + w_ / 2, y_ + h_ / 2));\n      points.push(new Vec2(x_ - w_ / 2, y_ + h_ / 2));\n      return new Wall(points);\n    };\n\n    this.bounds.push(getRectBody(x - w, y, 2 * w, 4 * h));\n    this.bounds.push(getRectBody(x + 2 * w, y, 2 * w, 4 * h));\n    this.bounds.push(getRectBody(x, y - h, 4 * w, h * 2));\n    this.bounds.push(getRectBody(x, y + 2 * h, 4 * w, 2 * h));\n  }\n\n  /**\n   * Search for any object at the given coordinate then returns it\n   * Return false if nothing is found\n   * @param {number} x x coordinate\n   * @param {number} y y coordinate\n   * @return {Ball} The found object\n   */\n  getObjectAtCoordinates(x, y) {\n    let ret = undefined;\n    let v = new Vec2(x, y);\n    this.balls.forEach((ball) => {\n      if (ball.containsPoint(v)) ret = ball;\n    });\n    this.bodies.forEach((body) => {\n      if (body.containsPoint(v)) ret = body;\n    });\n    this.walls.forEach((wall) => {\n      if (wall.containsPoint(v)) ret = wall;\n    });\n    this.fixedBalls.forEach((e) => {\n      if (Vec2.dist(new Vec2(e.x, e.y), new Vec2(x, y)) <= e.r) ret = e;\n    });\n    this.softBalls.forEach((softBall) => {\n      if (softBall.containsPoint(v)) ret = softBall;\n    });\n    return ret;\n  }\n\n  /**\n   * Returns an array of copies of all balls in the system\n   * @return {Array<Ball>} The array of the copied balls\n   */\n  getCopyOfBalls() {\n    let ret = [];\n    this.balls.forEach((item) => {\n      ret.push(item.copy);\n    });\n    return ret;\n  }\n\n  /**\n   * Returns an array of copies of all bodies in the system\n   * @return {Array<Body>} The array of the copied bodies\n   */\n  getCopyOfBodies() {\n    let ret = [];\n    this.bodies.forEach((item) => {\n      ret.push(item.copy);\n    });\n    return ret;\n  }\n\n  /**\n   * Removes the given object from the system\n   * @param {any} obj The object to remove\n   */\n  removeObjFromSystem(obj) {\n    let idx = this.balls.indexOf(obj);\n    if (idx != -1) {\n      let toReturn = false;\n      this.softBalls.forEach((s) => {\n        if (s.points.includes(this.balls[idx])) {\n          this.removeObjFromSystem(s);\n          toReturn = true;\n        }\n      });\n      if (toReturn) return;\n      this.springs.forEach((s) => {\n        if (s.objects.includes(this.balls[idx])) this.removeObjFromSystem(s);\n      });\n      this.balls.splice(idx, 1);\n      return;\n    }\n    idx = this.bodies.indexOf(obj);\n    if (idx != -1) {\n      this.bodies.splice(idx, 1);\n      return;\n    }\n    idx = this.walls.indexOf(obj);\n    if (idx != -1) {\n      this.walls.splice(idx, 1);\n      return;\n    }\n    idx = this.fixedBalls.indexOf(obj);\n    if (idx != -1) {\n      this.fixedBalls.splice(idx, 1);\n      return;\n    }\n    idx = this.springs.indexOf(obj);\n    if (idx != -1) {\n      this.springs.splice(idx, 1);\n      let toReturn = false;\n      this.softBalls.forEach((s) => {\n        if (s.points.includes(this.springs[idx])) {\n          this.removeObjFromSystem(s);\n          toReturn = true;\n        }\n      });\n      if (toReturn) return;\n      return;\n    }\n    idx = this.softBalls.indexOf(obj);\n    if (idx != -1) {\n      let sf = this.softBalls[idx];\n      this.softBalls.splice(idx, 1);\n      sf.points.forEach((p) => {\n        this.removeObjFromSystem(p);\n      });\n      return;\n    }\n  }\n\n  /**\n   * Finds the ball or body with the given id\n   * @param {String} id The id of the object to find\n   * @return {any} The data of the object\n   */\n  getItemDataFromId() {\n    let ret = {};\n    let filter = (b) => b.id === id;\n\n    let balls = this.balls.filter(filter);\n    if (balls.length >= 1) {\n      ret.type = 'ball';\n      ret.num = this.balls.indexOf(balls[0]);\n      return ret;\n    }\n\n    let bodies = this.bodies.filter(filter);\n    if (bodies.length >= 1) {\n      ret.type = 'body';\n      ret.num = this.bodies.indexOf(bodies[0]);\n      return ret;\n    }\n\n    let springs = this.springs.filter(filter);\n    if (springs.length >= 1) {\n      ret.type = 'spring';\n      ret.num = this.springs.indexOf(springs[0]);\n      return ret;\n    }\n  }\n\n  /**\n   * @return {Object} The physics world represented in a JS object\n   * Ready to be converted into JSON\n   */\n  toJSObject() {\n    let ret = {};\n\n    ret.balls = this.balls.map((b) => {\n      return b.toJSObject();\n    });\n    ret.bounds = this.bounds.map((w) => {\n      return w.toJSObject();\n    });\n    ret.walls = this.walls.map((w) => {\n      return w.toJSObject();\n    });\n    ret.bodies = this.bodies.map((b) => {\n      return b.toJSObject();\n    });\n    ret.springs = this.springs.map((s) => {\n      return s.toJSObject();\n    });\n    ret.softBalls = this.softBalls.map((s) => {\n      return s.toJSObject();\n    });\n\n    ret.fixedBalls = this.fixedBalls;\n    ret.airFriction = this.airFriction;\n    ret.gravity = this.gravity.toJSObject();\n\n    // saving version too, for having backwards compatibility later\n    ret.version = require('../package.json').version;\n\n    return ret;\n  }\n\n  /**\n   * Creates a Physics class from the given object\n   * @param {Object} obj The object to create the class from\n   * @return {Physics} The Physics object\n   */\n  static fromObject(obj) {\n    let newWorld = new Physics();\n\n    newWorld.balls = obj.balls.map((b) => Ball.fromObject(b));\n    newWorld.bounds = obj.bounds.map((b) => Wall.fromObject(b));\n    newWorld.walls = obj.walls.map((w) => Wall.fromObject(w));\n    newWorld.bodies = obj.bodies.map((b) => Body.fromObject(b));\n    newWorld.springs = obj.springs.map((s) =>\n      Spring.fromObject(s, newWorld.balls)\n    );\n    newWorld.softBalls = obj.softBalls.map((s) =>\n      SoftBall.fromObject(s, newWorld.balls, newWorld.springs)\n    );\n\n    newWorld.fixedBalls = obj.fixedBalls;\n    newWorld.airFriction = obj.airFriction;\n    newWorld.gravity = Vec2.fromObject(obj.gravity);\n\n    return newWorld;\n  }\n\n  /**\n   * @return {String} The physics object in JSON format in a string\n   */\n  toJSON() {\n    return JSON.stringify(this.toJSObject());\n  }\n\n  /**\n   * Recreates the phyisics object from JSON\n   * @param {String} jsonString The JSON containing the physics object\n   * @return {Physics} The created Physics object\n   */\n  static fromJSON(jsonString) {\n    return Physics.fromObject(JSON.parse(jsonString));\n  }\n}\n\nPhysics.Ball = Ball;\nPhysics.Body = Body;\nPhysics.Vec2 = Vec2;\nPhysics.Wall = Wall;\nPhysics.LineSegment = LineSegment;\nPhysics.Spring = Spring;\nPhysics.Stick = Stick;\nPhysics.SoftBall = SoftBall;\nPhysics.Line = Line;\nPhysics.Polygon = Polygon;\n\nmodule.exports = Physics;\n", "const Physics = require('../../src/physics');\n\nmodule.exports = function(translator) {\n  this.startingState = translator.getPhysics().toJSObject();\n  this.inStartingState = true;\n\n  document.getElementById('pause').onclick = () => {\n    if (translator.getTimeMultiplier() !== 0) translator.setTimeMultiplier(0);\n    else {\n      translator.setTimeMultiplier(1);\n      if (this.inStartingState == true) {\n        this.startingState = translator.getPhysics().toJSObject();\n      }\n      this.inStartingState = false;\n    }\n  };\n\n  document.getElementById('revert').onclick = () => {\n    translator.setTimeMultiplier(0);\n    translator.setPhysics(Physics.fromObject(this.startingState));\n    this.inStartingState = true;\n  };\n\n  document.getElementById('clear all').onclick = () => {\n    this.inStartingState = true;\n\n    const physics = translator.getPhysics();\n    physics.balls = [];\n    physics.walls = [];\n    physics.softBalls = [];\n    physics.springs = [];\n    physics.bodies = [];\n  };\n\n  document.getElementById('set start').onclick = () => {\n    this.startingState = translator.getPhysics().toJSObject();\n    this.inStartingState = true;\n    translator.setTimeMultiplier(0);\n  };\n};\n", "/**\n * Class representing a mode for the editor\n */\nclass Mode {\n  /**\n   * Creats a new mode\n   * @param {string} name The name of the mode\n   * @param {string} description The description of the mode\n   * @param {function} drawFunc The drawing function of the mode\n   * @param {function} startInteractionFunc The function that gets\n   * called at the start of an interaction\n   * @param {function} endInteractionFunc The function that gets\n   * called at the end of an interaction\n   * @param {function} keyGotUpFunc The function that gets\n   * called at releasing a key\n   * @param {function} keyGotDownFunc The function that gets\n   * called at pressing down a key\n   */\n  constructor(\n      name,\n      description,\n      drawFunc,\n      startInteractionFunc,\n      endInteractionFunc,\n      keyGotUpFunc,\n      keyGotDownFunc\n  ) {\n    this.name = name;\n    this.description = description;\n    this.drawFunc = drawFunc;\n    this.startInteractionFunc = startInteractionFunc;\n    this.endInteractionFunc = endInteractionFunc;\n    this.keyGotUpFunc = keyGotUpFunc;\n    this.keyGotDownFunc = keyGotDownFunc;\n  }\n}\n\nmodule.exports = Mode;\n", "const Mode = require('../mode.js');\nconst BallPhysics = require('../../../src/physics');\n\nconst BallCreatorMode = new Mode(\n  'Ball creator',\n  '',\n  function(\n    ctx,\n    mouseX,\n    mouseY,\n    lastX,\n    lastY,\n    defaultSize,\n    mouseDown,\n    physics,\n    choosed,\n    dt\n  ) {\n    ctx.strokeStyle = 'black';\n\n    ctx.beginPath();\n    ctx.arc(mouseX, mouseY, defaultSize, 0, 2 * Math.PI);\n    ctx.stroke();\n\n    if (lastX != 0 && lastY != 0) {\n      ctx.beginPath();\n      ctx.moveTo(mouseX, mouseY);\n      ctx.lineTo(lastX, lastY);\n      ctx.stroke();\n    }\n  },\n  function(physics, x, y, mouseX, mouseY) { },\n  function(physics, x, y, mouseX, mouseY, lastX, lastY) {\n    if (lastX != 0 && lastY != 0) {\n      const newBall = new BallPhysics.Ball(\n        new BallPhysics.Vec2(lastX, lastY),\n        new BallPhysics.Vec2(lastX - mouseX, lastY - mouseY),\n        defaultSize,\n        k,\n        0,\n        fc\n      );\n      if (\n        isFinite(newBall.pos.x) &&\n        isFinite(newBall.pos.y) &&\n        isFinite(newBall.vel.x) &&\n        isFinite(newBall.vel.y)\n      ) {\n        physics.addBall(newBall);\n      } else {\n        newBall.vel.x = 0;\n        newBall.vel.y = 0;\n        physics.addBall(newBall);\n      }\n    }\n  },\n  function() { },\n  function() { }\n);\n\nmodule.exports = BallCreatorMode;\n", "const Mode = require('../mode.js');\n\nconst RectangleMode = new Mode(\n    'Rectangle wall',\n    '',\n    function(\n        ctx,\n        mouseX,\n        mouseY,\n        lastX,\n        lastY,\n        defaultSize,\n        mouseDown,\n        physics,\n        choosed,\n        dt\n    ) {\n      if (lastX != 0 && lastY != 0) {\n        ctx.strokeStyle = 'black';\n        ctx.strokeRect(mouseX, mouseY, lastX - mouseX, lastY - mouseY);\n      }\n    },\n    function(physics, x, y, mouseX, mouseY) {},\n    function(physics, x, y, mouseX, mouseY, lastX, lastY) {\n      if (lastX != 0 && lastY != 0) {\n        physics.addRectWall(\n            lastX / 2 + mouseX / 2,\n            lastY / 2 + mouseY / 2,\n            2 * Math.abs(lastX / 2 - mouseX / 2),\n            2 * Math.abs(lastY / 2 - mouseY / 2)\n        );\n      }\n    },\n    function() {},\n    function() {}\n);\n\nmodule.exports = RectangleMode;\n", "const Mode = require('../mode.js');\n\nconst WallDrawerMode = new Mode(\n    'Wall drawer',\n    '',\n    function(\n        ctx,\n        mouseX,\n        mouseY,\n        lastX,\n        lastY,\n        defaultSize,\n        mouseDown,\n        physics,\n        choosed,\n        dt,\n        offsets\n    ) {\n      ctx.strokeStyle = 'black';\n      ctx.beginPath();\n      ctx.arc(mouseX, mouseY, defaultSize, 0, 2 * Math.PI);\n      ctx.stroke();\n      if (lastX != 0 && lastY != 0) {\n        physics.addFixedBall(mouseX / offsets.scaling -\n        offsets.viewOffsetX / offsets.scaling,\n        mouseY / offsets.scaling -\n        offsets.viewOffsetY / offsets.scaling, defaultSize);\n      }\n    },\n    function(physics, x, y, mouseX, mouseY) {\n    },\n    function(physics, x, y, mouseX, mouseY, lastX, lastY) {\n    },\n    function() { },\n    function() { }\n);\n\nmodule.exports = WallDrawerMode;\n", "const Mode = require('../mode.js');\nconst BallPhysics = require('../../../src/physics');\n\nconst StickCreatorMode = new Mode(\n    'Stick creator',\n    '',\n    function(\n        ctx,\n        mouseX,\n        mouseY,\n        lastX,\n        lastY,\n        defaultSize,\n        mouseDown,\n        physics,\n        choosed,\n        dt\n    ) {\n      if (lastX != 0 && lastY != 0) {\n        ctx.strokeStyle = 'black';\n        ctx.beginPath();\n        ctx.moveTo(mouseX, mouseY);\n        ctx.lineTo(lastX, lastY);\n        ctx.stroke();\n      }\n    },\n    function(physics, x, y, mouseX, mouseY, choosed) {},\n    function(physics, x, y, mouseX, mouseY, lastX, lastY, choosed) {\n      if (lastX != 0 && lastY != 0) {\n        mode3: {\n          let newChoosed = physics.getObjectAtCoordinates(mouseX, mouseY);\n          let stick;\n          const Thing = BallPhysics.Stick;\n          if (!newChoosed) {\n            newChoosed = {\n              x: mouseX,\n              y: mouseY,\n              pinPoint: true,\n            };\n          }\n\n          if (\n            choosed == newChoosed ||\n          (choosed == undefined && newChoosed == undefined)\n          ) {\n            break mode3;\n          } else if (choosed.pinPoint && newChoosed.pinPoint) break mode3;\n          else if (choosed.pinPoint) {\n            stick = new Thing(\n                Math.sqrt(\n                    Math.pow(choosed.x - newChoosed.pos.x, 2) +\n                Math.pow(choosed.y - newChoosed.pos.y, 2)\n                ),\n                springConstant\n            );\n            stick.attachObject(newChoosed);\n            stick.pinHere(choosed.x, choosed.y);\n          } else if (newChoosed.pinPoint) {\n            stick = new Thing(\n                Math.sqrt(\n                    Math.pow(choosed.pos.x - newChoosed.x, 2) +\n                Math.pow(choosed.pos.y - newChoosed.y, 2)\n                ),\n                springConstant\n            );\n            stick.attachObject(choosed);\n            stick.pinHere(newChoosed.x, newChoosed.y);\n          } else {\n            stick = new Thing(\n                Math.sqrt(\n                    Math.pow(choosed.pos.x - newChoosed.pos.x, 2) +\n                Math.pow(choosed.pos.y - newChoosed.pos.y, 2)\n                ),\n                springConstant\n            );\n            stick.attachObject(choosed);\n            stick.attachObject(newChoosed);\n          }\n          physics.addSpring(stick);\n          if (lockRotation) {\n            stick.lockRotation();\n          }\n        }\n      }\n    },\n    function() {},\n    function() {}\n);\n\nmodule.exports = StickCreatorMode;\n", "const Mode = require('../mode.js');\nconst BallPhysics = require('../../../src/physics');\n\nconst SpringCreatorMode = new Mode(\n    'Spring creator',\n    '',\n    function(\n        ctx,\n        mouseX,\n        mouseY,\n        lastX,\n        lastY,\n        defaultSize,\n        mouseDown,\n        physics,\n        choosed,\n        dt\n    ) {\n      if (lastX != 0 && lastY != 0) {\n        ctx.strokeStyle = 'black';\n        ctx.beginPath();\n        ctx.moveTo(mouseX, mouseY);\n        ctx.lineTo(lastX, lastY);\n        ctx.stroke();\n      }\n    },\n    function(physics, x, y, mouseX, mouseY, choosed) {},\n    function(physics, x, y, mouseX, mouseY, lastX, lastY, choosed) {\n      if (lastX != 0 && lastY != 0) {\n        mode3: {\n          let newChoosed = physics.getObjectAtCoordinates(mouseX, mouseY);\n          let stick;\n          const Thing = BallPhysics.Spring;\n          if (!newChoosed) {\n            newChoosed = {\n              x: mouseX,\n              y: mouseY,\n              pinPoint: true,\n            };\n          }\n\n          if (\n            choosed == newChoosed ||\n          (choosed == undefined && newChoosed == undefined)\n          ) {\n            break mode3;\n          } else if (choosed.pinPoint && newChoosed.pinPoint) break mode3;\n          else if (choosed.pinPoint) {\n            stick = new Thing(\n                Math.sqrt(\n                    Math.pow(choosed.x - newChoosed.pos.x, 2) +\n                Math.pow(choosed.y - newChoosed.pos.y, 2)\n                ),\n                springConstant\n            );\n            stick.attachObject(newChoosed);\n            stick.pinHere(choosed.x, choosed.y);\n          } else if (newChoosed.pinPoint) {\n            stick = new Thing(\n                Math.sqrt(\n                    Math.pow(choosed.pos.x - newChoosed.x, 2) +\n                Math.pow(choosed.pos.y - newChoosed.y, 2)\n                ),\n                springConstant\n            );\n            stick.attachObject(choosed);\n            stick.pinHere(newChoosed.x, newChoosed.y);\n          } else {\n            stick = new Thing(\n                Math.sqrt(\n                    Math.pow(choosed.pos.x - newChoosed.pos.x, 2) +\n                Math.pow(choosed.pos.y - newChoosed.pos.y, 2)\n                ),\n                springConstant\n            );\n            stick.attachObject(choosed);\n            stick.attachObject(newChoosed);\n          }\n          physics.addSpring(stick);\n          if (lockRotation) {\n            stick.lockRotation();\n          }\n        }\n      }\n    },\n    function() {},\n    function() {}\n);\n\nmodule.exports = SpringCreatorMode;\n", "const Mode = require('../mode.js');\n\nlet pmouseX = 0;\nlet pmouseY = 0;\n\nconst convertSpace = (x, y, offsets) => {\n  return {\n    x: x / offsets.scaling - offsets.viewOffsetX / offsets.scaling,\n    y: y / offsets.scaling - offsets.viewOffsetY / offsets.scaling,\n  };\n};\n\nconst MoveMode = new Mode(\n    'Move',\n    '',\n    function(\n        ctx,\n        mouseX,\n        mouseY,\n        lastX,\n        lastY,\n        defaultSize,\n        mouseDown,\n        physics,\n        choosed,\n        dt,\n        offsets\n    ) {\n      const converted = convertSpace(mouseX, mouseY, offsets);\n      const pconverted = convertSpace(pmouseX, pmouseY, offsets);\n      if (choosed && !choosed.pinPoint) {\n        choosed.move(converted.x - choosed.pos.x, converted.y - choosed.pos.y);\n        if (dt === 0) {\n          choosed.vel.x = 0;\n          choosed.vel.y = 0;\n        } else {\n          choosed.vel.x = (converted.x - pconverted.x) / dt;\n          choosed.vel.y = (converted.y - pconverted.y) / dt;\n        }\n        choosed.ang = 0;\n      }\n\n      pmouseX = mouseX;\n      pmouseY = mouseY;\n    },\n    function(physics, x, y, mouseX, mouseY) { },\n    function(physics, x, y, mouseX, mouseY, lastX, lastY) { },\n    function() { },\n    function() { }\n);\n\nmodule.exports = MoveMode;\n", "const Mode = require('../mode.js');\nconst BallPhysics = require('../../../src/physics');\n\nconst ElasticBallCreatorMode = new Mode(\n    'Elastic ball creator',\n    '',\n    function(\n        ctx,\n        mouseX,\n        mouseY,\n        lastX,\n        lastY,\n        defaultSize,\n        mouseDown,\n        physics,\n        choosed,\n        dt\n    ) {\n      ctx.strokeStyle = 'black';\n\n      ctx.beginPath();\n      ctx.arc(mouseX, mouseY, defaultSize, 0, 2 * Math.PI);\n      ctx.stroke();\n\n      if (lastX != 0 && lastY != 0) {\n        ctx.beginPath();\n        ctx.moveTo(mouseX, mouseY);\n        ctx.lineTo(lastX, lastY);\n        ctx.stroke();\n      }\n    },\n    function(physics, x, y, mouseX, mouseY) {},\n    function(physics, x, y, mouseX, mouseY, lastX, lastY) {\n      if (lastX != 0 && lastY != 0) {\n        const newBall = new BallPhysics.Ball(\n            new BallPhysics.Vec2(lastX, lastY),\n            new BallPhysics.Vec2(lastX - mouseX, lastY - mouseY),\n            defaultSize,\n            k,\n            0,\n            fc\n        );\n        if (\n          isFinite(newBall.pos.x) &&\n        isFinite(newBall.pos.y) &&\n        isFinite(newBall.vel.x) &&\n        isFinite(newBall.vel.y)\n        ) {\n          const sb = new BallPhysics.SoftBall(\n              newBall.pos,\n              defaultSize,\n              1000000,\n              fc,\n              24\n          );\n          sb.points.forEach((p) => {\n            p.vel = newBall.vel.copy;\n          });\n          physics.addSoftBall(sb);\n        }\n      }\n    },\n    function() {},\n    function() {}\n);\n\nmodule.exports = ElasticBallCreatorMode;\n", "const Mode = require('../mode.js');\nconst BallPhysics = require('../../../src/physics');\n\nconst SoftSquareCreatorMode = new Mode(\n    'Soft square creator',\n    '',\n    function(\n        ctx,\n        mouseX,\n        mouseY,\n        lastX,\n        lastY,\n        defaultSize,\n        mouseDown,\n        physics,\n        choosed,\n        dt\n    ) {\n      ctx.strokeStyle = 'black';\n\n      ctx.beginPath();\n      ctx.moveTo(mouseX - defaultSize, mouseY - defaultSize);\n      ctx.lineTo(mouseX + defaultSize, mouseY - defaultSize);\n      ctx.lineTo(mouseX + defaultSize, mouseY + defaultSize);\n      ctx.lineTo(mouseX - defaultSize, mouseY + defaultSize);\n      ctx.lineTo(mouseX - defaultSize, mouseY - defaultSize);\n      ctx.stroke();\n\n      if (lastX != 0 && lastY != 0) {\n        ctx.beginPath();\n        ctx.moveTo(mouseX, mouseY);\n        ctx.lineTo(lastX, lastY);\n        ctx.stroke();\n      }\n    },\n    function(physics, x, y, mouseX, mouseY) {},\n    function(physics, x, y, mouseX, mouseY, lastX, lastY) {\n      if (lastX != 0 && lastY != 0) {\n        const newBall = new BallPhysics.Ball(\n            new BallPhysics.Vec2(lastX, lastY),\n            new BallPhysics.Vec2(lastX - mouseX, lastY - mouseY),\n            defaultSize,\n            k,\n            0,\n            fc\n        );\n        if (\n          isFinite(newBall.pos.x) &&\n        isFinite(newBall.pos.y) &&\n        isFinite(newBall.vel.x) &&\n        isFinite(newBall.vel.y)\n        ) {\n          physics.addSoftSquare(newBall.pos, defaultSize * 2, fc, newBall.vel);\n        }\n      }\n    },\n    function() {},\n    function() {}\n);\n\nmodule.exports = SoftSquareCreatorMode;\n", "const Mode = require('../mode.js');\n\nconst MoveMode = new Mode(\n    'Delete',\n    '',\n    function(\n        ctx,\n        mouseX,\n        mouseY,\n        lastX,\n        lastY,\n        defaultSize,\n        mouseDown,\n        physics,\n        choosed,\n        dt\n    ) {},\n    function(physics, x, y, mouseX, mouseY, choosed) {\n      if (choosed) physics.removeObjFromSystem(choosed);\n    },\n    function(physics, x, y, mouseX, mouseY, lastX, lastY) {},\n    function() {},\n    function() {}\n);\n\nmodule.exports = MoveMode;\n", "const Mode = require('../mode.js');\n\nconst RectangleBodyMode = new Mode(\n    'Rectangle body (experimental)',\n    '',\n    function(\n        ctx,\n        mouseX,\n        mouseY,\n        lastX,\n        lastY,\n        defaultSize,\n        mouseDown,\n        physics,\n        choosed,\n        dt\n    ) {\n      if (lastX != 0 && lastY != 0) {\n        ctx.strokeStyle = 'black';\n        ctx.strokeRect(mouseX, mouseY, lastX - mouseX, lastY - mouseY);\n      }\n    },\n    function(physics, x, y, mouseX, mouseY) {},\n    function(physics, x, y, mouseX, mouseY, lastX, lastY, choosed, fc, k) {\n      if (lastX != 0 && lastY != 0) {\n        physics.addRectBody(\n            lastX / 2 + mouseX / 2,\n            lastY / 2 + mouseY / 2,\n            2 * Math.abs(lastX / 2 - mouseX / 2),\n            2 * Math.abs(lastY / 2 - mouseY / 2),\n            0.18,\n            0.1\n        );\n      }\n    },\n    function() {},\n    function() {}\n);\n\nmodule.exports = RectangleBodyMode;\n", "const BallPhysics = require('../../src/physics');\n\nconst Physics = BallPhysics;\nconst Ball = BallPhysics.Ball;\nconst Vec2 = BallPhysics.Vec2;\nconst Spring = BallPhysics.Spring;\nconst Stick = BallPhysics.Stick;\n\nconst startPauseControlsFunction = require('./startPauseControls');\n\nlet physics;\nlet cnv;\nlet mouseX = 0;\nlet mouseY = 0;\n// eslint-disable-next-line no-unused-vars\nlet mouseDown = 0;\nwindow.defaultSize;\nwindow.k = 0.5;\nwindow.fc = 2;\nwindow.springConstant = 2000;\nwindow.scaling = 1;\nwindow.viewOffsetX = 0;\nwindow.viewOffsetY = 0;\nlet mode = 0;\nlet lastX = 0;\nlet lastY = 0;\nlet timeMultiplier = 1;\nlet lastFrameTime;\nwindow.lockRotation = false;\nwindow.time = true;\nlet choosed = false;\nlet mx = 0;\nmy = 0;\nconst preciseMode = false;\n\nconst modes = [\n  require('./modes/ballcreator.js'),\n  require('./modes/rectangle.js'),\n  require('./modes/walldrawer.js'),\n  require('./modes/stickcreator.js'),\n  require('./modes/springcreator.js'),\n  require('./modes/movemode.js'),\n  require('./modes/elasticballcreator.js'),\n  require('./modes/softsquarecreator.js'),\n  require('./modes/deletemode.js'),\n  require('./modes/rectanglebodycreator.js'),\n];\n\nlet left = false;\nlet right = false;\n\n/**\n * Called when the page loaded\n */\nwindow.onload = () => {\n  cnv = document.getElementById('defaulCanvas0');\n\n  physics = new Physics();\n  physics.setBounds(0, 0, cnv.width, cnv.height);\n  physics.setGravity(new Vec2(0, 1000));\n  physics.setAirFriction(0.9);\n\n  cnv.addEventListener('touchstart', startTouch, false);\n  cnv.addEventListener('touchend', endTouch, false);\n  cnv.addEventListener('touchmove', moveTouch, false);\n  cnv.addEventListener('mousedown', startMouse, false);\n  cnv.addEventListener('mouseup', endMouse, false);\n  cnv.addEventListener('mousemove', handleMouseMovement, false);\n  document.addEventListener('keydown', keyGotDown, false);\n  document.addEventListener('keyup', keyGotUp, false);\n  window.addEventListener('resize', resizeCanvas, false);\n  cnv.addEventListener(\n    'mousedown',\n    function() {\n      mouseDown = 1;\n    },\n    false\n  );\n  cnv.addEventListener(\n    'mouseup',\n    function() {\n      mouseDown = 0;\n    },\n    false\n  );\n\n  resizeCanvas();\n  window.defaultSize = (cnv.width + cnv.height) / 80;\n\n  startPauseControlsFunction(new Translator());\n\n  requestAnimationFrame(drawFunction);\n};\n\n/**\n * Function that is called when the window gest resized\n */\nfunction resizeCanvas() {\n  cnv.width = window.innerWidth;\n  cnv.height = window.innerHeight;\n  physics.setBounds(0, 0, cnv.width, cnv.height);\n}\n\n/**\n * My draw function\n */\nfunction drawFunction() {\n  if (!isFinite(lastFrameTime)) lastFrameTime = performance.now();\n  let elapsedTime = performance.now() - lastFrameTime;\n  if (!isFinite(elapsedTime)) {\n    elapsedTime = 0;\n  }\n  elapsedTime /= 1000;\n\n  mouseX = isFinite(mouseX) ? mouseX : mx;\n  mouseY = isFinite(mouseY) ? mouseY : my;\n  if (mouseX && isFinite(mouseX)) mx = mouseX;\n  if (mouseY && isFinite(mouseY)) my = mouseY;\n\n  const ctx = cnv.getContext('2d');\n\n  // paint the background\n  ctx.fillStyle = 'rgb(51, 51, 51)';\n  ctx.fillRect(0, 0, cnv.width, cnv.height);\n\n  // Draw the logo up there and some coordinates\n  ctx.strokeStyle = 'black';\n  ctx.fillStyle = 'white';\n  ctx.fillText('BallPhysics', 10, 10);\n  ctx.fillText('Mode: ' + modes[mode].name, 10, 25);\n  ctx.fillText(\n    Math.round(mouseX).toString() + ' ' + Math.round(mouseY).toString(),\n    10,\n    40\n  );\n  ctx.fillText(\n    Math.round(lastX).toString() + ' ' + Math.round(lastY).toString(),\n    10,\n    55\n  );\n\n  modes[mode].drawFunc(\n    ctx,\n    mouseX,\n    mouseY,\n    lastX,\n    lastY,\n    defaultSize * window.scaling,\n    mouseDown,\n    physics,\n    choosed,\n    elapsedTime * timeMultiplier,\n    {\n      scaling: window.scaling,\n      viewOffsetX: window.viewOffsetX,\n      viewOffsetY: window.viewOffsetY,\n    }\n  );\n\n  // the size indicator for creating balls\n  ctx.strokeStyle = 'black';\n\n  physicsDraw(cnv);\n\n  if (!time) return;\n\n  if (physics.balls[0]) {\n    if (right) physics.balls[0].ang -= Math.PI * 100 * elapsedTime;\n    if (left) physics.balls[0].ang += Math.PI * 100 * elapsedTime;\n  }\n\n  elapsedTime *= timeMultiplier;\n  physics.update(elapsedTime / 5, preciseMode);\n  physics.update(elapsedTime / 5, preciseMode);\n  physics.update(elapsedTime / 5, preciseMode);\n  physics.update(elapsedTime / 5, preciseMode);\n  physics.update(elapsedTime / 5, preciseMode);\n\n  pmouseX = mouseX;\n  pmouseY = mouseY;\n\n  lastFrameTime = performance.now();\n  requestAnimationFrame(drawFunction);\n}\n\n/**\n * Gets called on the start of an interaction with the canvas\n * @param {number} x The x position of the mouse of the finger on the canvas\n * @param {number} y The y position of the mouse of the finger on the canvas\n */\nfunction startInteraction(x, y) {\n  mouseX = x;\n  mouseY = y;\n  choosed = physics.getObjectAtCoordinates(\n    mouseX / window.scaling - window.viewOffsetX / window.scaling,\n    mouseY / window.scaling - window.viewOffsetY / window.scaling);\n  if (!choosed) {\n    choosed = {\n      x: mouseX / window.scaling - window.viewOffsetX / window.scaling,\n      y: mouseY / window.scaling - window.viewOffsetY / window.scaling,\n      pinPoint: true,\n    };\n  }\n  lastX = mouseX;\n  lastY = mouseY;\n\n  modes[mode].startInteractionFunc(physics,\n    x / window.scaling - window.viewOffsetX / window.scaling,\n    y / window.scaling - window.viewOffsetY / window.scaling,\n    mouseX / window.scaling - window.viewOffsetX / window.scaling,\n    mouseY / window.scaling - window.viewOffsetY / window.scaling,\n    choosed);\n}\n\n/**\n * Gets called on the end of an interaction with the canvas\n * @param {number} x The x position of the mouse of the finger on the canvas\n * @param {number} y The y position of the mouse of the finger on the canvas\n */\nfunction endInteraction(x, y) {\n  mouseX = x;\n  mouseY = y;\n\n  modes[mode].endInteractionFunc(\n    physics,\n    x / window.scaling - window.viewOffsetX / window.scaling,\n    y / window.scaling - window.viewOffsetY / window.scaling,\n    mouseX / window.scaling - window.viewOffsetX / window.scaling,\n    mouseY / window.scaling - window.viewOffsetY / window.scaling,\n    lastX / window.scaling - window.viewOffsetX / window.scaling,\n    lastY / window.scaling - window.viewOffsetY / window.scaling,\n    choosed,\n    fc,\n    k\n  );\n\n  if (lastX === 0 && lastY === 0) return;\n\n  lastX = 0;\n  lastY = 0;\n  choosed = false;\n}\n\n/**\n * My keyboard event function for pressing down a key\n * @param {KeyboardEvent} event The event containing data\n */\nfunction keyGotDown(event) {\n  keyCode = event.key;\n  if (keyCode === 'ArrowUp') {\n    mode += 1;\n    mode %= modes.length;\n  }\n  if (keyCode === 'ArrowDown') {\n    mode -= 1;\n    mode = mode === -1 ? modes.length - 1 : mode;\n  }\n  if (keyCode === 's') {\n    spawnNewtonsCradle(cnv.width / 2, cnv.height / 2, 0.5, physics);\n  }\n  if (keyCode === 'a') {\n    window.scaling += 0.01;\n  }\n  if (keyCode === 'd') {\n    window.scaling -= 0.01;\n  }\n  if (keyCode === 'j') {\n    window.viewOffsetX -= 10;\n  }\n  if (keyCode === 'l') {\n    window.viewOffsetX += 10;\n  }\n  if (keyCode === 'k') {\n    window.viewOffsetY -= 10;\n  }\n  if (keyCode === 'i') {\n    window.viewOffsetY += 10;\n  }\n  if (keyCode === 'ArrowRight') {\n    right = true;\n  }\n  if (keyCode === 'ArrowLeft') {\n    left = true;\n  }\n}\n\n/**\n * My keyboard event function for releasing a key\n * @param {KeyboardEvent} event The event containing data\n */\nfunction keyGotUp(event) {\n  keyCode = event.key;\n  // Right arrow\n  if (keyCode === 'ArrowRight') {\n    right = false;\n  }\n  // Left arrow\n  if (keyCode === 'ArrowLeft') {\n    left = false;\n  }\n}\n\n/**\n * My touch event function\n * @param {TouchEvent} event The event containing data\n * @return {boolean} Returns false for preventing default browser behavior\n */\nfunction startTouch(event) {\n  event.preventDefault();\n  if (cnv.width - event.changedTouches[0].clientX < cnv.width / 100) {\n    mode += 1;\n    mode %= modes.length;\n    return;\n  }\n  if (event.changedTouches[0].clientX < cnv.width / 100) {\n    mode -= 1;\n    mode = mode === -1 ? modes.length - 1 : mode;\n    return;\n  }\n  startInteraction(\n    event.changedTouches[0].clientX,\n    event.changedTouches[0].clientY\n  );\n  return false;\n}\n\n/**\n * My touch event function\n * @param {TouchEvent} event The event containing data\n * @return {boolean} Returns false for preventing default browser behavior\n */\nfunction endTouch(event) {\n  event.preventDefault();\n  endInteraction(\n    event.changedTouches[0].clientX,\n    event.changedTouches[0].clientY\n  );\n  return false;\n}\n\n/**\n * My touch event function\n * @param {TouchEvent} event The event containing data\n * @return {boolean} Returns false for preventing default browser behavior\n */\nfunction moveTouch(event) {\n  event.preventDefault();\n  mouseX = event.changedTouches[0].clientX;\n  mouseY = event.changedTouches[0].clientY;\n  return false;\n}\n\n/**\n * My mouse event function that handles pressing down a mouse key\n * @param {TouchEvent} event The event containing data\n * @return {boolean} Returns false for preventing default browser behavior\n */\nfunction startMouse(event) {\n  startInteraction(event.clientX, event.clientY);\n  return false;\n}\n\n/**\n * My mouse event function that handles releasing a mouse key\n * @param {TouchEvent} event The event containing data\n * @return {boolean} Returns false for preventing default browser behavior\n */\nfunction endMouse(event) {\n  endInteraction(event.clientX, event.clientY);\n  return false;\n}\n\n/**\n * My mouse event function that handles mouse movement\n * @param {TouchEvent} event The event containing data\n */\nfunction handleMouseMovement(event) {\n  mouseX = event.clientX;\n  mouseY = event.clientY;\n}\n\nconst physicsDraw = function(cnv) {\n  const ctx = cnv.getContext('2d');\n  ctx.save();\n  ctx.translate(window.viewOffsetX, window.viewOffsetY);\n  ctx.scale(window.scaling, window.scaling);\n\n  ctx.fillStyle = 'green';\n  ctx.strokeStyle = 'black';\n  for (let i = 0; i < physics.balls.length; i++) {\n    ctx.beginPath();\n    ctx.arc(\n      physics.balls[i].pos.x,\n      physics.balls[i].pos.y,\n      physics.balls[i].r,\n      0,\n      2 * Math.PI\n    );\n    ctx.stroke();\n    ctx.fill();\n\n    ctx.save();\n    ctx.translate(physics.balls[i].pos.x, physics.balls[i].pos.y);\n    ctx.rotate(-Math.PI / 2 - physics.balls[i].rotation);\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(0, physics.balls[i].r);\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  physics.bodies.forEach((element) => {\n    ctx.beginPath();\n    ctx.moveTo(\n      element.points[element.points.length - 1].x,\n      element.points[element.points.length - 1].y\n    );\n    element.points.forEach((p) => {\n      ctx.lineTo(p.x, p.y);\n    });\n    ctx.stroke();\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.arc(element.pos.x, element.pos.y, 1.5, 0, Math.PI * 2);\n    ctx.stroke();\n  });\n\n  const drawWall = (element) => {\n    ctx.beginPath();\n    ctx.moveTo(\n      element.points[element.points.length - 1].x,\n      element.points[element.points.length - 1].y\n    );\n    element.points.forEach((p) => {\n      ctx.lineTo(p.x, p.y);\n    });\n    ctx.fill();\n  };\n  ctx.fillStyle = 'white';\n  physics.walls.forEach(drawWall);\n  ctx.fillStyle = 'yellow';\n  physics.bounds.forEach(drawWall);\n\n  physics.fixedBalls.forEach((b) => {\n    ctx.beginPath();\n    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);\n    ctx.fill();\n  });\n  ctx.save();\n  ctx.lineWidth = 2;\n  ctx.strokeStyle = '#ADD8E6';\n  ctx.fillStyle = '#ADD8E6';\n  physics.springs.forEach((element) => {\n    if (element instanceof Spring && !(element instanceof Stick)) {\n      let x1;\n      let y1;\n      let x2;\n      let y2;\n      if (element.pinned) {\n        x1 = element.pinned.x;\n        y1 = element.pinned.y;\n        x2 = element.objects[0].pos.x;\n        y2 = element.objects[0].pos.y;\n      } else {\n        x1 = element.objects[0].pos.x;\n        y1 = element.objects[0].pos.y;\n        x2 = element.objects[1].pos.x;\n        y2 = element.objects[1].pos.y;\n      }\n      let v = new Vec2(x2 - x1, y2 - y1);\n      const c = v.copy;\n      v.rotate(Math.PI / 2);\n      v.setMag(5);\n      let last = new Vec2(x1, y1);\n      const num = Math.floor(element.length / 10);\n      for (let i = 1; i <= num; i++) {\n        if (i === num) v = new Vec2(0, 0);\n        ctx.beginPath();\n        ctx.moveTo(last.x, last.y);\n        ctx.lineTo(x1 + (i / num) * c.x + v.x, y1 + (i / num) * c.y + v.y);\n        ctx.stroke();\n        last = new Vec2(x1 + (i / num) * c.x + v.x, y1 + (i / num) * c.y + v.y);\n        v.mult(-1);\n      }\n    } else {\n      ctx.beginPath();\n      ctx.moveTo(element.objects[0].pos.x, element.objects[0].pos.y);\n      ctx.lineTo(\n        element.pinned ? element.pinned.x : element.objects[1].pos.x,\n        element.pinned ? element.pinned.y : element.objects[1].pos.y\n      );\n      ctx.stroke();\n    }\n    element.objects.forEach((o) => {\n      ctx.beginPath();\n      ctx.arc(o.pos.x, o.pos.y, 2.5, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n    });\n    if (element.pinned) {\n      ctx.beginPath();\n      ctx.arc(element.pinned.x, element.pinned.y, 3, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n    }\n  });\n  ctx.restore();\n\n  // Visualizing debug data\n  for (segment of physics.debugData) {\n    ctx.strokeStyle = 'red';\n    ctx.beginPath();\n    ctx.moveTo(segment.a.x, segment.a.y);\n    ctx.lineTo(segment.b.x, segment.b.y);\n    ctx.stroke();\n  }\n\n  ctx.restore();\n};\n\n/**\n * Spawns a Newton cradle inside the given world at given size and\n * coordinates\n * @param {number} x The x coordinate of it\n * @param {number} y The y coordinate of it\n * @param {number} scale The size of it\n * @param {Physics} phy The world to put it in\n */\nfunction spawnNewtonsCradle(x, y, scale, phy) {\n  const balls = [];\n  const defaultR = 25;\n  const defaultStick = 250;\n  const ballNumber = 8;\n  balls.push(\n    new Ball(new Vec2(x, y), new Vec2(0, 0), scale * defaultR, 1, 0, 0)\n  );\n  let count = 1;\n  for (let i = 0; i < ballNumber - 1; i++) {\n    balls.push(\n      new Ball(\n        new Vec2(x + count * scale * defaultR * 1.01 * 2, y),\n        new Vec2(0, 0),\n        scale * 25,\n        1,\n        0,\n        0\n      )\n    );\n    count *= -1;\n    if (count > 0) count += 1;\n    if (i === ballNumber - 2) {\n      balls[balls.length - 1].vel.x = -Math.sign(count) * scale * defaultR * 8;\n    }\n  }\n  balls.forEach((ball) => {\n    phy.addBall(ball);\n    const stick = new Stick(defaultStick);\n    stick.attachObject(ball);\n    stick.pinHere(ball.pos.x, ball.pos.y - defaultStick);\n    phy.addSpring(stick);\n    stick.lockRotation();\n  });\n}\n\n/**\n * Setter for the variable timeMultipler for passing it to other scopes\n * @param {number} x The new value of timeMultiplier\n */\nfunction setTimeMultiplier(x) {\n  if (isFinite(x)) timeMultiplier = x;\n}\n\n/**\n * Getter for the variable timeMultiplier for passing it to other scopes\n * @return {number} The value of timeMultiplier\n */\nfunction getTimeMultiplier() {\n  return timeMultiplier;\n}\n\n/**\n * Setter for the object physics for passing it to other scopes\n * @param {number} phy The new objejet physics\n */\nfunction setPhysics(phy) {\n  if (phy instanceof Physics) physics = phy;\n}\n\n/**\n * Getter for the physics object for passing it to other scopes\n * @return {number} The object physics\n */\nfunction getPhysics() {\n  return physics;\n}\n\n/**\n * The translator for passing to other scopes\n */\nconst Translator = function() {\n  this.setTimeMultiplier = setTimeMultiplier;\n  this.getTimeMultiplier = getTimeMultiplier;\n  this.getPhysics = getPhysics;\n  this.setPhysics = setPhysics;\n};\n"],
  "mappings": "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",
  "names": []
}
